<!DOCTYPE html>
<html lang=zh>
<head>
    <meta charset="utf-8">
    
    <title>第二章 ES6 基础 | 歪马行空</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="JavaScript语言的第六版中引入了大量的非破坏性语法改进。本章我们将讨论其中的大部分内容。大部分的改变都是语法糖，能够使用ES5的代码进行实现，虽然需要使用更复杂的代码。还有一部分改变并不仅仅是语法糖，比如在本章最后，我们将会介绍let和const这两种完全不同的声明变量的方式。 对象字面量的语法在ES6发生了">
<meta name="keywords" content="翻译">
<meta property="og:type" content="article">
<meta property="og:title" content="第二章 ES6 基础">
<meta property="og:url" content="http://verymuch.com/2017/11/01/第二章-ES6-基础/index.html">
<meta property="og:site_name" content="歪马行空">
<meta property="og:description" content="JavaScript语言的第六版中引入了大量的非破坏性语法改进。本章我们将讨论其中的大部分内容。大部分的改变都是语法糖，能够使用ES5的代码进行实现，虽然需要使用更复杂的代码。还有一部分改变并不仅仅是语法糖，比如在本章最后，我们将会介绍let和const这两种完全不同的声明变量的方式。 对象字面量的语法在ES6发生了改变，就让我们从这方面开始讲述吧。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://verymuch.com/images/practical-modern-javascript.gif">
<meta property="og:updated_time" content="2017-12-12T03:21:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第二章 ES6 基础">
<meta name="twitter:description" content="JavaScript语言的第六版中引入了大量的非破坏性语法改进。本章我们将讨论其中的大部分内容。大部分的改变都是语法糖，能够使用ES5的代码进行实现，虽然需要使用更复杂的代码。还有一部分改变并不仅仅是语法糖，比如在本章最后，我们将会介绍let和const这两种完全不同的声明变量的方式。 对象字面量的语法在ES6发生了改变，就让我们从这方面开始讲述吧。">
<meta name="twitter:image" content="http://verymuch.com/images/practical-modern-javascript.gif">
    

    
        <link rel="alternate" href="/" title="歪马行空" type="application/atom+xml" />
    

    
        <link rel="icon" href="/css/images/avatar2.jpg" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">歪马行空</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="https://github.com/verymuch">GitHub</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar0.jpg" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="https://github.com/verymuch">GitHub</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar0.jpg" />
            <h2 id="name">verymuch</h2>
            <h3 id="title">Web Developer ( FE )</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Beijing, China</span>
            <a id="follow" target="_blank" href="https://github.com/verymuch/">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                8
                <span>文章</span>
            </div>
            <div class="article-info-block">
                5
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="http://github.com/verymuch" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="twitter" class=tooltip>
                            <i class="fa fa-twitter"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="facebook" class=tooltip>
                            <i class="fa fa-facebook"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="dribbble" class=tooltip>
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="rss" class=tooltip>
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main"><article id="post-第二章-ES6-基础" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            第二章 ES6 基础
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/11/01/第二章-ES6-基础/">
            <time datetime="2017-11-01T08:53:14.000Z" itemprop="datePublished">2017-11-01</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/翻译/">翻译</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>JavaScript语言的第六版中引入了大量的非破坏性语法改进。本章我们将讨论其中的大部分内容。大部分的改变都是语法糖，能够使用ES5的代码进行实现，虽然需要使用更复杂的代码。还有一部分改变并不仅仅是语法糖，比如在本章最后，我们将会介绍<code>let</code>和<code>const</code>这两种完全不同的声明变量的方式。</p>
<p>对象字面量的语法在ES6发生了改变，就让我们从这方面开始讲述吧。</p>
<a id="more"></a>
<h2><span id="21-对象字面量">2.1 对象字面量</span></h2><p><em>对象字面量</em>是指使用<code>{}</code>缩写语法进行对象声明的形式，具体语法格式如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> book=&#123;</span><br><span class="line">  title: <span class="string">'Modular ES6'</span>,</span><br><span class="line">  author: <span class="string">'Nicolas'</span>,</span><br><span class="line">  publisher: <span class="string">'O ́Reilly'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6中对象字面量语法有一些小的改进：属性值缩写，可计算属性名和方法定义。下面我们来学习一下这些内容，并介绍一下它们的用法。</p>
<h3><span id="211-属性值缩写">2.1.1 属性值缩写</span></h3><p>有时我们会声明一个对象，该对象有一个或多个属性值的属性名和所引用的变量名相同。比如，有一个<code>listeners</code>数组，为了将其赋值给对象字面量中名为<code>listeners</code>的属性名，必须重复输入该名称。下面的这段代码很好地展示了包含两个重复属性的对象字面量：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listeners = [] </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line"><span class="keyword">var</span> events = &#123;</span><br><span class="line">  listeners: listeners,</span><br><span class="line">  listen: listen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ES6中，如果我们遇到这种问题，借助新的属性值缩写语法就可以省略属性值和分号。如下例所示，新的ES6语法进行了隐性赋值：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listeners = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> events = &#123; listeners, listen &#125;</span><br></pre></td></tr></table></figure>
<p>随着接下来对于本书第二章的学习，我们会发现属性值缩写在不影响代码含义的情况下，能够有效地减少重复代码的书写。在下面的代码片段中，我重新实现了浏览器中的持久存储API<code>localStorage</code>的部分内容，可以将其看成是内存存储的填充实现[注释 1]。如果没有使用缩写语法，<code>storage</code>对象看起来会更加冗长：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> storage = &#123; getItem, setItem, clear &#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItem</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key <span class="keyword">in</span> store ? store[key] : <span class="literal">null</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setItem</span><span class="params">(key, value)</span> </span>&#123; </span><br><span class="line">  store[key] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  store = &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 中有很多旨在减少所维护代码的复杂性的特性，属性值缩写只是我们所要介绍的第一个特性。一旦你习惯了这一新语法，你就会发现代码的可读性和开发者的生产效率都得到了提升。</p>
<h3><span id="212-可计算属性名">2.1.2 可计算属性名</span></h3><p>如下面的ES5代码所示，有时，我们可能需要声明这样一个对象：包含属性名基于其他变量或者JavaScript表达式的属性。在本例中，假设<code>expertise</code>是作为一个函数参数，而我们事先并不知道它的值：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> expertise = <span class="string">'journalism'</span> </span><br><span class="line"><span class="selector-tag">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sharon'</span>,</span><br><span class="line">  age: <span class="number">27</span> </span><br><span class="line">&#125;</span><br><span class="line">person[expertise] = &#123;</span><br><span class="line">  years: <span class="number">5</span>,</span><br><span class="line">  interests: [<span class="string">'international'</span>, <span class="string">'politics'</span>, <span class="string">'internet'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ES6中，对象字面量并不限制使用静态名称来声明。使用可计算属性名，可以用方括号将任何表达式包裹起来，作为属性名使用。当声明执行时，表达式才会被计算，并被当做属性名使用。下面的例子向我们展示了上例中所看到的代码如何用一步声明<code>person</code>对象，而不需要借助第二个声明来添加<code>expertise</code>属性。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> expertise = <span class="string">'journalism'</span> </span><br><span class="line"><span class="selector-tag">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sharon'</span>,</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  [expertise]: &#123;</span><br><span class="line">    years: <span class="number">5</span>,</span><br><span class="line">    interests: [<span class="string">'international'</span>, <span class="string">'politics'</span>, <span class="string">'internet'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性值缩写和可计算属性名不能同时使用。属性值缩写只是用来避免重复的在编译时执行的语法糖，而可计算属性名是在运行时进行计算的。如果下例所示，当我们试图同时使用这两个冲突的特性时，系统会抛出一个语法错误的异常。多数情况下，这种组合使用会导致代码难以理解，所以最好不要同时使用这两个特性。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> expertise = <span class="string">'journalism'</span> </span><br><span class="line"><span class="selector-tag">var</span> journalism = &#123;</span><br><span class="line">  years: <span class="number">5</span>,</span><br><span class="line">  interests: [<span class="string">'international'</span>, <span class="string">'politics'</span>, <span class="string">'internet'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Sharon'</span>,</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  [expertise] <span class="comment">// 语法错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可计算属性名有一个常用的使用场景，即如下面的代码所示，当我们想要将一个实体添加到一个对象映射中，并且想使用实体的<code>id</code>字段作为键值，就可以使用可计算属性名。我们可以直接在<code>groceries</code>对象字面量中进行内联声明，而不需要单独使用第三条声明语句将<code>grocery</code>添加到<code>groceries</code>映射中。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> grocery = &#123; </span><br><span class="line">  id: <span class="string">'bananas'</span>,</span><br><span class="line">  name: <span class="string">'Bananas'</span>,</span><br><span class="line">  units: <span class="number">6</span>,</span><br><span class="line">  price: <span class="number">10</span>, </span><br><span class="line">  currency: <span class="string">'USD'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">var</span> groceries = &#123;</span><br><span class="line">  [grocery.id]: grocery</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种使用场景：当一个函数接受一个参数，并用该参数构建一个对象并返回。如果用ES5的代码来实现，则需要分配一个变量进行对象字面量的声明，然后添加一个动态计算的属性，最后返回这个对象。下面的例子展示了这一使用场景，创建一个信封，之后能够用于Ajax消息，这些消息主要遵循以下约定：当发生错误时，有一个<code>error</code>属性，用于描述发生了什么错误；在结果正常时，有一个<code>success</code>属性表示成功：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> getEnvelope(<span class="keyword">type</span>, description) &#123; </span><br><span class="line">  var envelope = &#123;</span><br><span class="line">    <span class="keyword">data</span>: &#123;&#125; </span><br><span class="line">  &#125;</span><br><span class="line">  envelope[<span class="keyword">type</span>] = description</span><br><span class="line">  <span class="keyword">return</span> envelope </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可计算属性名能够帮我们用更简明的代码实现同样的函数，仅使用一条语句就能够实现：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">getEnvelope</span>(type, description) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="type">&#123;</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    [<span class="keyword">type</span>]: description</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="方法的定义">方法的定义</span></h3><p>通常，我们会通过向对象添加一个属性的方式来为该对象声明一个方法。在下面的代码片段中，我们将创建一个能够支持多种事件类型的小型事件发射器。时间发射器的<code>emitter#on</code>方法可以用来注册事件监听函数，<code>emitter#emit</code>方法可以用来触发事件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emitter = &#123;</span><br><span class="line">  events: &#123;&#125;,</span><br><span class="line">  on: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">type</span>, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events[<span class="keyword">type</span>] === <span class="literal">undefined</span>) &#123; </span><br><span class="line">      <span class="keyword">this</span>.events[<span class="keyword">type</span>] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.events[<span class="keyword">type</span>].push(fn) </span><br><span class="line">  &#125;,</span><br><span class="line">  emit: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">type</span>, event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events[<span class="keyword">type</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.events[<span class="keyword">type</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      fn(event) </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从ES6开始，我们可以使用新的方法定义语法在对象字面量中进行方法的声明。这时，我们可以省略分号和<code>function</code>关键字。新的方法定义语法可以作为传统的使用<code>function</code>关键字声明方法的一种更加简洁的替代方案。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emitter = &#123;</span><br><span class="line">  events: &#123;&#125;,</span><br><span class="line">  on(<span class="class"><span class="keyword">type</span>, <span class="title">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events[<span class="class"><span class="keyword">type</span>] <span class="title">===</span> <span class="title">undefined</span>) </span>&#123; </span><br><span class="line">      <span class="keyword">this</span>.events[<span class="class"><span class="keyword">type</span>] </span>= []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.events[<span class="class"><span class="keyword">type</span>].<span class="title">push</span>(<span class="params">fn</span>) </span></span><br><span class="line"><span class="class">  &#125;,</span></span><br><span class="line"><span class="class">  <span class="title">emit</span>(<span class="params">type, event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events[<span class="class"><span class="keyword">type</span>] <span class="title">===</span> <span class="title">undefined</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.events[<span class="class"><span class="keyword">type</span>].<span class="title">forEach</span>(<span class="params">function (fn</span>) </span>&#123;</span><br><span class="line">      fn(event) </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数是ES6中的另一种函数声明方式，它有好几种形式。现在让我们来探究一下箭头函数到底是什么，它们是如何声明的以及它们的语法形式。</p>
<h2><span id="22-箭头函数">2.2 箭头函数</span></h2><p>在JavaScript中，我们通常使用类似下面的代码进行函数声明：函数名，参数列表和函数体。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="keyword">name</span>(parameters) &#123; </span><br><span class="line">  // <span class="function"><span class="keyword">function</span></span> body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以创建一个匿名函数，这是需要省略函数的名称，并将其赋值给一个变量或者对象的属性，也可以直接进行调用。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="function"><span class="keyword">function</span> <span class="params">(parameters)</span> </span>&#123; </span><br><span class="line">  <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ES6中，我们可以使用另一种方式来声明匿名函数，即箭头函数。值得一提的是，箭头函数有几种不同的写法。下面的所示代码中的箭头函数和前面刚看过的匿名函数非常相似。唯一的不同就是缺少了<code>function</code>关键字，并且在参数列表的右侧多了个<code>=&gt;</code>箭头。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="function">(<span class="params">parameters</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管箭头函数看起来和常规的匿名函数很相似，但是本质上它们是完全不同的：箭头函数不能显示地命名，不过现代的运行环境会将箭头函数所赋予的变量名作为函数名；不能用作构造函数，也没有<code>prototype</code>属性，所以不能使用<code>new</code>关键字调用箭头函数；箭头函数被绑定到词法作用域中，这样是为什么它们不会改变<code>this</code>含义的原因。</p>
<p>让我们深入了解它们与传统函数的语义差异，声明箭头函数的多种方法以及它们的实际用例。</p>
<!-- 从这里开始保证每一句话 -->
<h3><span id="221-词法作用域">2.2.1 词法作用域</span></h3><p>箭头函数不会创建新的作用域，在箭头函数的函数体内，<code>this</code>、<code>arguments</code>以及<code>super</code>指向所在的父级作用域。来看一下下面的例子。创建一个<code>timer</code>计时器对象，对象上有一个<code>seconds</code>计数器属性和一个<code>start</code>方法，这个方法就是用我们前面所学习的方法定义语法创建的。然后我们开启这个计时器，等待几秒钟，然后打印出已经过去的秒数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = &#123;</span><br><span class="line">  seconds: <span class="number">0</span>, </span><br><span class="line">  start() &#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">      <span class="keyword">this</span>.seconds++</span><br><span class="line">    &#125;, <span class="number">1000</span>) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">timer.start()</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(timer.seconds) </span><br><span class="line">&#125;, <span class="number">3500</span>)</span><br><span class="line"><span class="comment">// &lt;- 3</span></span><br></pre></td></tr></table></figure>
<p>如果我们使用常规的匿名函数来定义传入<code>setInterval</code>的函数，而不是使用箭头函数的话，<code>this</code>将绑定到匿名函数的上下文中，而不是<code>start</code>方法的上下文中。这时，如果想实现上面的<code>timer</code>计时器，可以在<code>start</code>方法的开头加上类似<code>var self = this</code>的声明语句，然后在<code>setInterval</code>函数内部引用<code>self</code>即可。由此可见，使用箭头函数，能够避免为保持上下文引用而额外增加的复杂性，只关注代码的功能即可。</p>
<p>同样地，ES6中箭头函数的作用域绑定也意味着当使用<code>.call</code>、<code>.apply</code>、<code>.bind</code>等方法调用函数时也无法改变<code>this</code>的指向。这一限制通常是很有作用的，因为这能够保证上下文不被修改。</p>
<p>现在我们再看一下下面这个例子。你认为<code>console.log</code>会输出出什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">puzzle</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">puzzle(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>答案是<code>arguments</code>指向匿名函数的上下文，因此传入匿名函数的参数会被输出。在本里中，这些参数是<code>1, 2, 3</code>。</p>
<p>如果将上例重点匿名函数换为箭头函数，结果会如何呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">puzzle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">puzzle(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>这时，<code>arguments</code>对象指向<code>puzzle</code>函数的上下文，因为箭头函数并不会创建闭包。因此，<code>&#39;a&#39;, &#39;b&#39;, &#39;c&#39;</code>将被输出。</p>
<p>上面我有提到箭头函数有几种写法，但到目前为止，我们只使用了完整版的写法。其他几种写法是什么呢？</p>
<h3><span id="222-箭头函数的写法">2.2.2 箭头函数的写法</span></h3><p>让我们再一起回顾下目前所学的箭头格式语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="function">(<span class="params">parameters</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果箭头函数只有一个参数，则可以省略圆括号。当然，这不是必须的。当将箭头函数传递到其他方法中时，这么做很有用，因为这样能够减少圆括号的数量，从而使得代码更加可读。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">double</span> = <span class="keyword">value</span> =&gt; &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">value</span> * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用箭头函数来声明简单函数时，则完整的写法是较为麻烦的，就如上面的<code>double</code>方法一样。接下来要说的这种箭头函数的写法与函数体有关。我们可以使用<code>value * 2</code>表达式来代替函数体。当函数被调用时，表达式会被计算，结果则作为返回值返回。这时，<code>return</code>语句是隐式的，并且不需要使用花括号包裹函数体，而是使用一个简单的表示来替代：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">double</span> = (<span class="keyword">value</span>) =&gt; <span class="keyword">value</span> * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>我们还可以同时省略括号和return语句，这样箭头函数会更加简洁：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">double</span> = <span class="keyword">value</span> =&gt; <span class="keyword">value</span> * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h4><span id="隐式返回对象字面量">隐式返回对象字面量</span></h4><p>当想要隐式返回对象字面量时，则需要使用圆括号将对象字面量包裹起来。否则，编译器会将花括号当成函数体的开始和结束标志。
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var objectFactory = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; modular: <span class="string">'es6'</span> &#125;)</span><br></pre></td></tr></table></figure></p>
<p>下例中，JavaScript就将花括号当成了箭头函数的函数体。此外，<code>number</code>会被当成是一个<code>label</code>[注释 2]，然后有一个没有做任何事的<code>value</code>表达式。既然函数体没有返回任何内容，则映射的结果就是<code>undefined</code>：
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">1, 2, 3</span>].map(<span class="keyword">value</span> =&gt; &#123; number: <span class="keyword">value</span> &#125;) </span><br><span class="line"><span class="comment">// &lt;- [undefined, undefined, undefined]</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们作为隐式返回的对象字面量具有多个属性，编译器无法识别第二个属性，因此会跑出一个<code>SyntaxError</code>异常：
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">1, 2, 3</span>].map(<span class="keyword">value</span> =&gt; &#123; number: <span class="keyword">value</span>, verified: <span class="literal">true</span> &#125;) </span><br><span class="line"><span class="comment">// &lt;- SyntaxError</span></span><br></pre></td></tr></table></figure></p>
<p>在对象字面量外添加圆括号可以解决该问题，这样编译器就不会再将其当做函数体，此时的对象声明即为我们想要隐式返回的对象字面量。
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">].map(value</span> <span class="string">=&gt;</span> <span class="string">(&#123;</span> <span class="attr">number:</span> <span class="string">value,</span> <span class="attr">verified:</span> <span class="literal">true</span> <span class="string">&#125;))</span> </span><br><span class="line"><span class="string">/*</span> <span class="string">&lt;-</span> <span class="string">[</span></span><br><span class="line">      <span class="string">&#123;</span> <span class="attr">number:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">verified:</span> <span class="literal">true</span> <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#123;</span> <span class="attr">number:</span> <span class="number">2</span><span class="string">,</span> <span class="attr">verified:</span> <span class="literal">true</span> <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#123;</span> <span class="attr">number:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">verified:</span> <span class="literal">true</span> <span class="string">&#125;]</span></span><br><span class="line"><span class="string">*/</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>现在你应该已经理解什么是箭头函数了，接下来我们思考下箭头函数的优点以及正确的用法。</p>
<h3><span id="223-优点和用法">2.2.3 优点和用法</span></h3><p>一般来说，我们不应该盲目地使用ES6的特性。相反地，最好在使用每个特性前都仔细思考下使用了这个新特性后是否真的能提高代码的可读性和可维护性。严格来说，ES6特性并不比现有特性好，因此最好不要随意使用它们。</p>
<p>箭头函数在某些情况下并不适用。比如，当一个函数包含很多行代码时，这时候使用箭头函数对代码并不能起到改进作用。箭头函数更适合用于简短的实例中，比如当<code>function</code>关键字和语法模板占函数表达式的很大一部分时。</p>
<p>适当地为函数命名能使得人类理解起来更容易。箭头函数不能显示地命名，但是可以通过赋值给其他变量的方式，隐式地命名。在下例中，我们将箭头函数赋值给了<code>throwError</code>变量。当调用函数式的过程中发生错误时，调用栈能够正确地定位到<code>throwError</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throwError = <span class="function"><span class="params">message</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line">throwError(<span class="string">'this is a warning'</span>)</span><br><span class="line">&lt;- Uncaught <span class="built_in">Error</span>: <span class="keyword">this</span> is a warning</span><br><span class="line">  at throwError</span><br></pre></td></tr></table></figure>
<p>当需要定义一个在任何情况下词法作用域都不改变的匿名函数时，使用箭头函数是很整洁的，并且在某些情况下，它还可以是我们的代码更加整洁。在大多数函数式编程的情况下，箭头函数是特别有用的，比如使用数组对象的<code>.map</code>、<code>.filter</code>或者<code>.reduce</code>等方法。具体示例如下图所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">1,2,3,4</span>]</span><br><span class="line">  .map(<span class="keyword">value</span> =&gt; <span class="keyword">value</span> * <span class="number">2</span>)</span><br><span class="line">  .filter(<span class="keyword">value</span> =&gt; <span class="keyword">value</span> &gt; <span class="number">2</span>)</span><br><span class="line">  .forEach(<span class="keyword">value</span> =&gt; console.log(<span class="keyword">value</span>))</span><br><span class="line"><span class="comment">// &lt;- 4</span></span><br><span class="line"><span class="comment">// &lt;- 6</span></span><br><span class="line"><span class="comment">// &lt;- 8</span></span><br></pre></td></tr></table></figure>
<h2><span id="23-解构赋值">2.3 解构赋值</span></h2><p>解构赋值是ES6中最灵活最有表现力的特性之一。同时，它也是最简单的。它可以将对象的属性值绑定到任意多的变量上。解构赋值可以用于对象、数组以及函数参数列表中。让我们先从对象开始一点一点介绍吧。</p>
<h3><span id="231-对象的解构">2.3.1 对象的解构</span></h3><p>假设我们有一个程序，程序中有一些漫画书的角色，Bruce Wayne是这些角色中的一个，我们现在想要引用用于描述Bruce Wayne的对象中的属性。下面的代码就是用于描述蝙蝠侠的示例对象：</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var character = &#123; </span><br><span class="line">  name: <span class="symbol">'Bruce'</span>, </span><br><span class="line">  pseudonym: <span class="symbol">'Batman'</span>,</span><br><span class="line">  metadata: &#123;</span><br><span class="line">    age: <span class="number">34</span>,</span><br><span class="line">    gender: <span class="symbol">'male'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  batarang: [<span class="symbol">'gas</span> pellet', <span class="symbol">'bat</span>-mobile control', <span class="symbol">'bat</span>-cuffs']</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想要声明一个<code>pseudonym</code>变量，并引用<code>character.pseudonym</code>的值，我们可能会写出如下的代码片段。如果我们需要在多个地方引用<code>pseudonym</code>，我们更希望能够避免每次都输入<code>character.pseudonym</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> pseudonym = character.pseudonym</span><br></pre></td></tr></table></figure>
<p>如果在赋值语句中使用解构赋值，则语法会变得更加清晰。在下面的例子中能够看出，使用解构赋值后，我们不需要重复两次输入<code>pseudonym</code>，并且仍能清晰地表达含义。下面的这段代码和上面用ES5的编写的代码是等价的。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var</span> &#123; <span class="attribute">pseudonym</span> &#125; = character</span><br></pre></td></tr></table></figure>
<p>通过<code>var</code>声明时，使用逗号隔开能一次声明多个变量。同样地，在结构赋值的花括号中也可以声明多个变量。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var &#123; pseudonym, <span class="built_in">name</span> &#125; = <span class="built_in">character</span></span><br></pre></td></tr></table></figure>
<p>并且，我们可以在同一个<code>var</code>语句中同时使用常规的变量声明和解构赋值。这种用法一开始看起来可能很奇怪，而且还要看我们所使用的JavaScript代码样式规范是否允许在单个语句中声明多个变量。不管如何，从这一点还是能够看出解构语法的灵活性。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var</span> &#123; <span class="attribute">pseudonym</span> &#125; = character, two = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果想要提取<code>pseudonym</code>属性，并将其声明为<code>alias</code>变量，我们可以使用下面这种解构语法，可以称之为<em>别名</em>语法。除了<code>alias</code>之外，我们可以使用任何其他合法的变量名。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123; pseudonym: <span class="keyword">alias</span> &#125; = <span class="keyword">character</span> </span><br><span class="line">console.<span class="keyword">log</span>(<span class="keyword">alias</span>)</span><br><span class="line"><span class="comment">// &lt;- 'Batman'</span></span><br></pre></td></tr></table></figure>
<p>别名看起来并不比ES5的写法<code>alias = character.pseudonym</code>简单。不过如果解构赋值支持深度解构的话，就另当别论了。如下面代码所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> &#123; metadata: &#123; gender &#125; &#125; = character</span><br></pre></td></tr></table></figure>
<p>在类似上面这种情况，当我们需要解构一个嵌套较深的属性值时，使用别名能够更清晰地传递属性名。试想一下，一个叫<code>code</code>的属性名，并不能如<code>colorCode</code>一样清晰表达所指的内容。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var &#123; <span class="string">metadata:</span> &#123; <span class="string">gender:</span> characterGender &#125; &#125; = character</span><br></pre></td></tr></table></figure>
<p>上面我们所看到的这种情况是很常见的，因为属性通常是基于其宿主对象命名的。<code>palette.color.code</code>的含义很清楚，而单独使用<code>code</code>则可以表示很多内容，所以在结构赋值中使用类似<code>colorCode</code>的别名能够将上下文含义带入到变量中。</p>
<p>在ES5中，访问一个不存在的属性时，会返回<code>undefined</code>。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="keyword">character</span>.boots) </span><br><span class="line">// &lt;- undefined </span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">character</span>[<span class="string">'boots'</span>]) </span><br><span class="line">// &lt;- undefined</span><br></pre></td></tr></table></figure>
<p>在解构赋值中也同样如此。当进行解构赋值的属性不存在时，同样会得到<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; boots &#125; = character </span><br><span class="line"><span class="built_in">console</span>.log(boots)</span><br><span class="line"><span class="comment">// &lt;- undefined</span></span><br></pre></td></tr></table></figure>
<p>当解构声明中访问的是一个嵌套属性，并且嵌套属性的父对象是<code>null</code>或<code>undefined</code>时，会抛出异常，就像在其他情况下访问<code>null</code>或<code>undefined</code>的属性会报错一样。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> &#123; boots: &#123; size &#125; &#125; = character </span><br><span class="line"><span class="comment">// &lt;- Exception</span></span><br><span class="line"><span class="selector-tag">var</span> &#123; missing &#125; = null</span><br><span class="line"><span class="comment">// &lt;- Exception</span></span><br></pre></td></tr></table></figure>
<p>由于解构赋值主要是语法糖，所以看一下下面的ES5等价代码，就能够清楚地知道上述的代码为何会抛出异常了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> nothing = null</span><br><span class="line"><span class="selector-tag">var</span> missing = nothing<span class="selector-class">.missing</span> </span><br><span class="line"><span class="comment">// &lt;- Exception</span></span><br></pre></td></tr></table></figure>
<p>在解构赋值中，我们可以为这些值为<code>undefined</code>的属性提供默认值。默认值可以使任何类型的值：如数值、字符串、函数、对象或者对其他变量的引用等。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var&#123;boots=&#123;<span class="built_in">size</span>:<span class="number">10</span>&#125;&#125;=<span class="keyword">character</span></span><br><span class="line">console.<span class="built_in">log</span>(boots)</span><br><span class="line">// &lt;- &#123; <span class="built_in">size</span>: <span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure>
<p>默认值在嵌套属性的解构中也可以使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">metadata</span>: &#123; enemy = <span class="string">'Satan'</span> &#125; &#125; = character </span><br><span class="line"><span class="built_in">console</span>.log(enemy)</span><br><span class="line"><span class="comment">// &lt;- 'Satan'</span></span><br></pre></td></tr></table></figure>
<p>当和别名结合使用时，应如下所示，将别名放在前面，默认值放在后面：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var &#123; boots: footwear = &#123; <span class="built_in">size</span>: <span class="number">10</span> &#125; &#125; = <span class="keyword">character</span></span><br></pre></td></tr></table></figure>
<p>在解构的模式部分可以使用可计算属性名语法。这种情况下，则必须提供一个别名作为变量名。这是因为可计算属性名中允许任意表达式，所以编译器无法推断出变量的名称。下例中，即使用了别名和可计算属性从<code>character</code>对象中提取出了<code>boots</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; [<span class="string">'boo'</span> + <span class="string">'ts'</span>]: characterBoots &#125; = character </span><br><span class="line"><span class="built_in">console</span>.log(characterBoots)</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br></pre></td></tr></table></figure>
<p>这一写法可能没有什么用途，因为<code>characterBoots = character[type]</code>比<code>{ [type]: characterBoots } = character</code>简单很多。也就是说，可计算属性名声明对象字面量的属性名时很有用，但是在解构赋值中却恰恰相反。</p>
<p>这些就是对象解构的相关内容。那么数组的解构又是怎么样的呢？</p>
<h3><span id="232-数组的解构">2.3.2 数组的解构</span></h3><p>数组的解构语法和对象解构比较相似。下例中，展示了如何将<code>coordinates</code>数组解构成<code>x</code>和<code>y</code>两个变量。可以看到，我们不再是使用花括号，而是使用了方括号，这就表示我们使用的是数组解构，而不是对象解构。使用解构我们能够在不显示引用索引情况下清晰地为数组中的值命名，而不需要使用类似<code>x = coordi nates[0]</code>这样的代码。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> coordinates = [<span class="number">12</span>, -<span class="number">7</span>] </span><br><span class="line"><span class="selector-tag">var</span> [x, y] = coordinates </span><br><span class="line">console.log(x)</span><br><span class="line"><span class="comment">// &lt;- 12</span></span><br></pre></td></tr></table></figure>
<p>使用数组解构时，我们可以跳过不感兴趣或者不需要引用的值。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> names = [<span class="string">'James'</span>, <span class="string">'L.'</span>, <span class="string">'Howlett'</span>] </span><br><span class="line"><span class="selector-tag">var</span> [ firstName, , lastName ] = names </span><br><span class="line">console.log(lastName)</span><br><span class="line"><span class="comment">// &lt;- 'Howlett'</span></span><br></pre></td></tr></table></figure>
<p>和对象解构相似，数组解构也可以设定默认值。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> names = [<span class="string">'James'</span>, <span class="string">'L.'</span>]</span><br><span class="line"><span class="selector-tag">var</span> [ firstName = <span class="string">'John'</span>, , lastName = <span class="string">'Doe'</span> ] = names </span><br><span class="line">console.log(lastName)</span><br><span class="line"><span class="comment">// &lt;- 'Doe'</span></span><br></pre></td></tr></table></figure>
<p>在ES5中，当我们需要交换两个变量的值时，通常需要引入第三个临时变量。如以下代码所示。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="attribute">left</span>=<span class="number">5</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="attribute">right</span> = <span class="number">7</span> </span><br><span class="line"><span class="selector-tag">var</span> aux = <span class="attribute">left</span> </span><br><span class="line"><span class="attribute">left</span> = right </span><br><span class="line"><span class="attribute">right</span> = aux</span><br></pre></td></tr></table></figure>
<p>解构使我们可以不用声明<code>aux</code>变量，而是专注于原本的意图。这也是解构能够使我们的表达更加清晰有效率的另一种使用场景。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">left</span>=<span class="number">5</span></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">right</span> = <span class="number">7</span></span><br><span class="line">[<span class="built_in">left</span>, <span class="built_in">right</span>] = [<span class="built_in">right</span>, <span class="built_in">left</span>]</span><br></pre></td></tr></table></figure>
<p>我们将要讨论最后一个关于解构的内容，即函数的参数。</p>
<h3><span id="233-函数参数的默认值">2.3.3 函数参数的默认值</span></h3><p>ES6中，函数的参数也能够指定默认值。下面的这个例子中，就为<code>exponent</code>参数定义了一个最常用的默认值。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">powerOf</span>(base, exponent = 2) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="type">Math.pow(base,</span> exponent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数的参数也可以指定默认值。当为箭头函数的参数指定默认值时，哪怕只有一个参数，也要用圆括号将箭头函数的参数列表包裹起来。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var double = <span class="function"><span class="params">(input = <span class="number">0</span>)</span> =&gt;</span> input * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>和一些其他编程语言不同，不限制只能给函数的最后一个参数设置默认值。可以为任何一个参数设置默认值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="title">sumOf</span>(<span class="params">a=1,b=2,c=3</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> a+b+c</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sumOf(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="number">4</span>)) </span><br><span class="line"><span class="comment">// &lt;- 1 + 2 + 4 = 7</span></span><br></pre></td></tr></table></figure>
<p>在JavaScript中，向函数传递一个包含多个属性的<code>options</code>对象参数的情况是再常见不过的了。如果使用函数的时候没有传递<code>options</code>，我们可以为其设定一个默认值。具体代码如下所示。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var defaultOptions = &#123; brand: <span class="string">'Volkswagen'</span>, <span class="keyword">make</span>: <span class="number">1999</span> &#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">carFactory</span><span class="params">(options = defaultOptions)</span> &#123;</span></span><br><span class="line">  console.<span class="built_in">log</span>(<span class="keyword">options</span>.brand)</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="keyword">options</span>.<span class="keyword">make</span>)</span><br><span class="line">&#125;</span><br><span class="line">carFactory()</span><br><span class="line">// &lt;- <span class="string">'Volkswagen'</span> </span><br><span class="line">// &lt;- <span class="number">1999</span></span><br></pre></td></tr></table></figure>
<p>这一方法存在一个问题，即如果<code>carFactory</code>的使用者传入了一个<code>options</code>对象，那么所有的默认值就都没用了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">carFactory</span><span class="params">(&#123; make: <span class="number">2000</span> &#125;)</span></span> </span><br><span class="line"><span class="comment">// &lt;- undefined</span></span><br><span class="line"><span class="comment">// &lt;- 2000</span></span><br></pre></td></tr></table></figure>
<p>我们可以同时使用函数参数的默认值和解构赋值，这样能够获得更好的结果。</p>
<h3><span id="234-函数参数的解构">2.3.4 函数参数的解构</span></h3><p>与只提供一个默认值相比，还有一个更好的方法，那就是对整个<code>options</code>进行解构，并在解构模式中，为每个属性都指定默认值。这个方法使我们能够不通过<code>options</code>对象就能引用<code>options</code>中的每个选项，但我们也不能直接引用<code>options</code>了，这在某些情况下可能会发生问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">carFactory</span>(<span class="params">&#123; brand = <span class="string">'Volkswagen'</span>, make = <span class="number">1999</span> &#125;</span>) </span>&#123; <span class="built_in">console</span>.log(brand)</span><br><span class="line"><span class="built_in">console</span>.log(make)</span><br><span class="line">&#125;</span><br><span class="line">carFactory(&#123; <span class="attr">make</span>: <span class="number">2000</span> &#125;) <span class="comment">// &lt;- 'Volkswagen'</span></span><br><span class="line"><span class="comment">// &lt;- 2000</span></span><br></pre></td></tr></table></figure>
<p>然而，这种情况下，如果使用者没有传入<code>options</code>对象，默认值会再一次缺失。也就是说，如果没有传入<code>options</code>对象参数，<code>carFactory</code>会报错。不过如下面的代码所示，为<code>options</code>添加一个空对象作为默认值，就能避免这一问题。然后这个空对象就会被解构模式中设定了默认值的属性一一填充。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">carFactory</span>(<span class="params">&#123; </span></span></span><br><span class="line"><span class="function"><span class="params">  brand = <span class="string">'Volkswagen'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  make = <span class="number">1999</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125; = &#123;&#125;</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(brand) </span><br><span class="line">  <span class="built_in">console</span>.log(make)</span><br><span class="line">&#125;</span><br><span class="line">carFactory()</span><br><span class="line"><span class="comment">// &lt;- 'Volkswagen' </span></span><br><span class="line"><span class="comment">// &lt;- 1999</span></span><br></pre></td></tr></table></figure>
<p>除了默认值以外，我们还可以在函数参数中使用解构来描述函数能够处理的对象的结构。参考以下代码，假设有一个<code>car</code>对象，对象上包含多个属性。<code>car</code>对象中描述了它的拥有者、类型、品牌、制造时间以及拥有者购买时的偏好。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">car=&#123;</span> </span><br><span class="line"><span class="attr">  owner:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    id:</span> <span class="string">'e2c3503a4181968c'</span><span class="string">,</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">'Donald Draper'</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">  brand:</span> <span class="string">'Peugeot'</span><span class="string">,</span></span><br><span class="line"><span class="attr">  make:</span> <span class="number">2015</span><span class="string">,</span></span><br><span class="line"><span class="attr">  model:</span> <span class="string">'208'</span><span class="string">,</span></span><br><span class="line"><span class="attr">  preferences:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    airbags:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    airconditioning:</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    color:</span> <span class="string">'red'</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果在某个函数中只想提取对象中的某些属性作为参数，则可以通过解构来提前显示地引用这些属性。这样做的好处就是在看到函数声明时，我们就能知道函数中需要使用哪些属性。</p>
<p>当我们提前解构所需要的每个属性时，当输入不正确时，就很容易发现。下面的例子中向我们展示了如何在参数列表中指定我们所需的每一个属性，从而表明<code>getCarProductiModel</code>结构方法能够处理的参数对象解构。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> getCarProductModel = (&#123; brand, make, model &#125;) =&gt; (&#123; </span><br><span class="line">  sku: brand + <span class="string">':'</span> + make + <span class="string">':'</span> + model,</span><br><span class="line">  brand,</span><br><span class="line">  make,</span><br><span class="line">  model</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="title">getCarProductModel</span><span class="params">(car)</span></span></span><br></pre></td></tr></table></figure>
<p>除了设置默认值和填充<code>options</code>对象外，解构还有很多其他的有用之处。下面让我们一起来看看。</p>
<h3><span id="235-解构的用法">2.3.5 解构的用法</span></h3><p>当一个函数返回一个对象或者数组时，解构使我们能够更简洁地处理返回值。
如下例所示，函数返回一个包含一些坐标的对象，而我们只对其中的<code>x</code>和<code>y</code>感兴趣。我们可以不用借助中间变量<code>point</code>，并且不会影响代码的可读性。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCoordinates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; x: <span class="number">10</span>, y: <span class="number">22</span>, z: <span class="number">-1</span>, type: <span class="string">'3d'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; x, y &#125; = getCoordinates()</span><br></pre></td></tr></table></figure>
<p>默认值的使用会产生一定的重复。假设存在一个<code>random</code>函数，函数会生成一个值在<code>min</code>和<code>max</code>之间的随机整数，默认生成1和10之间的值。在类似Python和C#的强类型语言里，使用这样一种方式来作为命名属性的替代方案是一件特别有趣的事情。这种能够为选项参数定义默认值，并且允许使用者独自覆盖的模式使用起来是非常灵活的。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">random</span>(&#123; <span class="built_in">min</span> = <span class="number">1</span>, <span class="built_in">max</span> = <span class="number">10</span> &#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> Math.<span class="built_in">floor</span>(Math.<span class="built_in">random</span>() * (<span class="built_in">max</span> - <span class="built_in">min</span>)) + <span class="built_in">min</span></span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">random</span>())</span><br><span class="line"><span class="comment">// &lt;- 7</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">random</span>(&#123; <span class="built_in">max</span>: <span class="number">24</span> &#125;)) </span><br><span class="line"><span class="comment">// &lt;- 18</span></span><br></pre></td></tr></table></figure>
<p>解构也非常适合用于正则表达式中。解构使我们能够在不使用索引值的情况下命名匹配结果数组中的数据。下面就有这样一个例子：通过正则表达式解析一个简单的日期，并且使用解构将解析出来的值分别赋值给对用的日期部分，即年月日等。在本例子中，匹配结果数组的第一个元素是原始输入，所以我们直接丢弃即可。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">splitDate</span>(<span class="params">date</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> rdate = <span class="regexp">/(\d+).(\d+).(\d+)/</span> </span><br><span class="line">  <span class="keyword">return</span> rdate.exec(<span class="built_in">date</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [ , year, month, day] = splitDate(<span class="string">'2015-11-06'</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意的是正则表达式未匹配的情况，这时匹配结果为<code>null</code>。所以如下例所示，最好在结构之前进行错误处理。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">matches</span> = splitDate('<span class="number">2015</span>-<span class="number">11</span>-<span class="number">06</span>') </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">matches</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [, year, month, day] = <span class="keyword">matches</span></span><br></pre></td></tr></table></figure>
<p>接下来我们来关注一下扩展运算符和reset参数。</p>
<h2><span id="24-rest参数和扩展运算符">2.4 Rest参数和扩展运算符</span></h2><p>在ES6之前，处理任意数量的函数参数是很复杂的，必须借助<code>arguments</code>来处理。<code>arguments</code>不是一个数组，但是具有<code>length</code>属性。通常，我们会使用<code>Array#slice.call</code>方法来将<code>arguments</code>对象转换为真正的数组。具体代码如下所示。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">list</span> = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>) </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">list</span>.join(<span class="string">', '</span>)</span><br><span class="line">&#125;</span><br><span class="line">join(<span class="string">'first'</span>, <span class="string">'second'</span>, <span class="string">'third'</span>) </span><br><span class="line"><span class="comment">// &lt;- 'first, second, third'</span></span><br></pre></td></tr></table></figure>
<p>ES6中有更好的方式解决这一问题，那就是rest参数。</p>
<h3><span id="241-rest参数">2.4.1 Rest参数</span></h3><p>我们可以在函数的最后一个参数前添加三个点，将该参数转变为一个特殊的“剩余参数”。当rest参数是函数中的唯一一个参数时，则它会获取到所有传入函数的参数：这和上述使用<code>.slice</code>处理的结果是一样的，但是这样能够取消对复杂结构<code>arguments</code>的需求，而是在参数列表中就进行制定。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span><span class="params">(<span class="rest_arg">...list</span>)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> list.join(<span class="string">', '</span>)</span><br><span class="line">&#125;</span><br><span class="line">join(<span class="string">'first'</span>, <span class="string">'second'</span>, <span class="string">'third'</span>) </span><br><span class="line"><span class="comment">// &lt;- 'first, second, third'</span></span><br></pre></td></tr></table></figure>
<p>rest参数之前的参数不会被包含在<code>list</code>参数中。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span><span class="params">(separator, <span class="rest_arg">...list</span>)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> list.join(separator)</span><br><span class="line">&#125;</span><br><span class="line">join(<span class="string">'; '</span>, <span class="string">'first'</span>, <span class="string">'second'</span>, <span class="string">'third'</span>) </span><br><span class="line"><span class="comment">// &lt;- 'first; second; third'</span></span><br></pre></td></tr></table></figure>
<p>注意，如果是箭头函数中包含rest参数，哪怕只有一个参数，也必须放置在圆括号内。否则，会抛出<code>SyntaxError</code>格式异常。下面的例子就完美展示了如何结合箭头函数和rest参数生成更简洁的函数式表达式。</p>
<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var sumAll = <span class="function"><span class="params">(...numbers)</span> =&gt;</span> numbers.reduce( </span><br><span class="line">  (total, <span class="built_in">next</span>) =&gt; total + <span class="built_in">next</span></span><br><span class="line">)</span><br><span class="line">console.log(sumAll(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>)) // &lt;- <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>与上面的代码相比，明显地，使用ES5实现的相同函数要更加复杂。虽然上面的实现方式较为简洁，但是这样的<code>sumAll</code>函数会对没有使用过<code>.reduce</code>方法的使用者产生困扰，并且同时使用两个箭头函数也会带来一定的困扰。这是一个复杂的权衡，也是我们将在本书第二部分讨论的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> numbers = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>) </span><br><span class="line">  <span class="keyword">return</span> numbers.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">total, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> total + next </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sumAll(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>)) </span><br><span class="line"><span class="comment">// &lt;- 8</span></span><br></pre></td></tr></table></figure>
<p>接下来我们一起讨论下扩展运算符。它也会用到<code>...</code>，但用法会稍有不同。</p>
<h3><span id="242-扩展运算符">2.4.2 扩展运算符</span></h3><p>扩展运算符可以用于将可遍历对象转换为数组。扩展运算符能够有效地将数组或者函数调用表达式展开。下例中，使用了<code>...arguments</code>将函数参数转换成了一个数组。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">cast</span>() &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="type">[...arguments]</span></span><br><span class="line">&#125;</span><br><span class="line">cast(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>) </span><br><span class="line">// &lt;- [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<p>我们也可以使用扩展运算符将一个字符串分割成数组，数组中元素为组成字符串的每个字符。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">'show me'</span>]</span><br><span class="line">// &lt;- [<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'o'</span>, <span class="string">'w'</span>, <span class="string">' '</span>, <span class="string">'m'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>
<p>扩展运算符的左右还可以添加其他内容，并且会得到你所期待的结果。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">cast</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">['left',</span> ...arguments, <span class="symbol">'right</span>']</span><br><span class="line">&#125;</span><br><span class="line">cast(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">// &lt;- [<span class="symbol">'left</span>', <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="symbol">'right</span>']</span><br></pre></td></tr></table></figure>
<p>扩展运算符非常适合用来拼接多个数组。如下例所示，我们可以在一个数组字面量中展开任意数组，将其中的元素放置到指定位置。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var all = [<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>, ...[<span class="number">5</span>], <span class="number">6</span>, <span class="number">7</span>] </span><br><span class="line">console.log(all)</span><br><span class="line"><span class="comment">// &lt;- [1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>
<p>值得一提的是，扩展运算符不是只能用于数组和<code>arguments</code>中，它可以用于任何对象字面量中。遍历器是ES6中新引入的一种机制，它允许我们将对象转换成一种可被遍历的内容，我们将在<a href="">第4章</a>深入讨论这一部分的内容。</p>
<blockquote>
<h2><span id="shift操作和扩展运算">shift操作和扩展运算</span></h2><p>当我们想要从一个数组的开头处获取一个或者两个元素，通常可以使用<code>.shift</code>方法。下面的代码虽然在功能上能够实现，但是却难以一眼就理解，因为代码中使用了两次<code>.shift</code>方法，但是每次从数组的开头取到的是不同的值。和许多其他的ES6之前的情况相似，重点是让语言去做我们想做的事情。
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">list</span> = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>] </span><br><span class="line"><span class="keyword">var</span> first = <span class="built_in">list</span>.shift()</span><br><span class="line"><span class="keyword">var</span> second = <span class="built_in">list</span>.shift() </span><br><span class="line"><span class="built_in">console</span>.log(first)</span><br><span class="line"><span class="comment">// &lt;- 'a'</span></span><br></pre></td></tr></table></figure></p>
<p>ES6中，可以将数组的解构和扩展运算符结合使用。下面的代码和前面的代码相似。我们仅用一句代码即可实现，并且这一行代码比重复使用<code>list.shift</code>方法更具描述性。
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var [first, second, ...other] = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>] console.log(other)</span><br><span class="line">// &lt;- [<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure></p>
<p>使用扩展运算符我们可以关注所要实现的功能，不用关心语言本身。在ES6的新特性上，提高代码的表达力并减少在语言限制上所花费的时间是很常见的。</p>
</blockquote>
<p>在ES6之前，当我们有一个动态的参数列表需要用于某个函数调用时，我们会使用<code>.aplly</code>方法。这么做并不优雅，因为<code>.apply</code>也会改变this的指向，而在此时，我们并不希望<code>this</code>指向自身。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span>.<span class="title">apply</span></span>(null, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>
<p>除了扩展数组之外，我们还可以在函数调用中使用扩展运算符。如下例所示，我们可以使用扩展运算符向<code>multiply</code>函数传递任意数值作为参数。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="title">left</span>, <span class="title">right</span>) &#123; </span></span><br><span class="line">  <span class="literal">return</span> left * <span class="literal">right</span></span><br><span class="line">&#125;</span><br><span class="line">var <span class="built_in">result</span> = <span class="built_in">multiply</span>(...[<span class="number">2</span>, <span class="number">3</span>]) </span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">result</span>)</span><br><span class="line">// &lt;- <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>在函数调用中扩展参数可以和常规参数一起使用，只有有必要，可以使用任意数量的扩展参数，如同上文在数组字面量中一样。下面示例中，调用了<code>print</code>方法，并传入了一对常规参数和一对在参数列表中扩展开的数组。注意，使用rest参数<code>list</code>能够取到所有传入的参数。扩展运算符和rest参数可以使代码意图更加清晰，且不会稀释代码库。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span><span class="params">(<span class="rest_arg">...list</span>)</span> </span>&#123; </span><br><span class="line">  console.log(list)</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>, ...[<span class="number">5</span>]) </span><br><span class="line"><span class="comment">// &lt;- [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>使用<code>.apply</code>方法就是还有一个不足之处，即当和<code>new</code>关键字一起实例化对象时，会非常冗长。一起来看下使用<code>new</code>和<code>.apply</code>来创建<code>Date</code>对象的示例。先不管在JavaScript中日期中的月份是从0开始的，即<code>11</code>指12月。思考一下除了这之外，为了实例化一个对象，我们向语言做了多少妥协。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (<span class="built_in">Date</span>.bind.apply(<span class="built_in">Date</span>, [<span class="built_in">null</span>, <span class="number">2015</span>, <span class="number">11</span>, <span class="number">31</span>])) </span><br><span class="line"><span class="comment">// &lt;- Thu Dec 31 2015</span></span><br></pre></td></tr></table></figure>
<p>如下所示，扩展运算符能够避免这些复杂性，我们只需要关注重要的内容。下例的<code>new</code>实例中，在<code>Date</code>函数使用了<code>...</code>来扩展动态的参数列表。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Date(...[<span class="number">2015</span>, <span class="number">11</span>, <span class="number">31</span>]) </span><br><span class="line"><span class="comment">// &lt;- Thu Dec 31 2015</span></span><br></pre></td></tr></table></figure>
<p>下表总结了上述我们所讨论的扩展运算符的使用场景。</p>
<table>
<thead>
<tr>
<th>使用场景</th>
<th>ES5</th>
<th>ES6</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组的连接</td>
<td>[1, 2].concat(more)</td>
<td>[1, 2, …more]</td>
</tr>
<tr>
<td>将一个数组放入列表中</td>
<td>list.push.apply(list, items)</td>
<td>list.push(…items)</td>
</tr>
<tr>
<td>解构</td>
<td>a = list[0], other = list.slice(1)</td>
<td>[a, …other] = list</td>
</tr>
<tr>
<td><code>new</code>关键字和<code>apply</code>方法</td>
<td>new (Date.bind.apply(Date, [null,2015,31,8]))</td>
<td>new Date(… [2015,31,8])</td>
</tr>
</tbody>
</table>
<h2><span id="25-模板字符串">2.5 模板字符串</span></h2><p>和JavaScript中的常规字符串相比，模板字符串有着巨大的改善。如下所示，模板字符串不是使用单引号或者双引号进行声明，而是使用反引号”`”。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">text</span> = `This <span class="keyword">is</span> <span class="keyword">my</span> <span class="keyword">first</span> template literal`</span><br></pre></td></tr></table></figure>
<p>由于模板字符串使用反引号来作为定界符，则我们在使用模板字符串来声明字符串时就不需要再转义其中的<code>&#39;</code>和<code>&quot;</code>。具体示例如下：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var text = `I<span class="symbol">'m</span> <span class="string">"amazed"</span> <span class="keyword">at</span> these opportunities!`</span><br></pre></td></tr></table></figure>
<p>模板字符串的功能中最值得一提的就是可以再其中插入JavaScript表达式。</p>
<h3><span id="251-字符串插值">2.5.1 字符串插值</span></h3><p>使用模板字符串，我们可以在模板中插入任意的JavaScript表达式。当执行到模板字符串表达式时，会计算表达式，并将结果返回。下例中，在模板字符串内插入了一个<code>name</code>变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Shannon'</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">`Hello, <span class="subst">$&#123; name &#125;</span>!`</span> </span><br><span class="line"><span class="built_in">console</span>.log(text)</span><br><span class="line"><span class="comment">// &lt;- 'Hello, Shannon!'</span></span><br></pre></td></tr></table></figure>
<p>前面已经说了，除了变量之外，我们可以使用任意的JavaScript表达式。我们可以将模板字符串的表达式当做是模板执行之前定义的一个变量，然后将各变量和其余字符串连接起来。这么做的好处就是代码变得更容易维护，因为不需要再手动的将各字符串和表达式拼接起来。不过在这些表达式中所使用的变量、所调用的函数等都必须在当前作用域内是可用的。</p>
<p>你想要在模板字符串中插入怎样的内置表达式逻辑，都取决于你自己的编码风格。下面的代码片段实力化了一个<code>Date</code>对象，并将其放在模板字符串中。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`The <span class="built_in">time</span> <span class="built_in">and</span> <span class="built_in">date</span> is $&#123; new <span class="built_in">Date</span>().toLocaleString() &#125;.` </span><br><span class="line">// &lt;- 'the <span class="built_in">time</span> <span class="built_in">and</span> <span class="built_in">date</span> is <span class="number">8</span>/<span class="number">26</span>/<span class="number">2015</span>, <span class="symbol">3:15</span><span class="symbol">:20</span> PM'</span><br></pre></td></tr></table></figure>
<p>同样也可以在模板字符串中插入数学运算。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`The result of <span class="number">2</span>+<span class="number">3</span> equals $&#123; <span class="number">2</span> + <span class="number">3</span> &#125;` </span><br><span class="line"><span class="comment">// &lt;- 'The result of 2+3 equals 5'</span></span><br></pre></td></tr></table></figure>
<p>甚至可以嵌套模板字符串，因为它们也是合法的JavaScript表达式。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`This template literal $&#123; `is $&#123; <span class="string">'nested'</span> &#125;` &#125;!` </span><br><span class="line"><span class="comment">// &lt;- 'This template literal is nested!'</span></span><br></pre></td></tr></table></figure>
<p>模板字符串还有另一个好处，它支持多行字符串。</p>
<h3><span id="252-多行模板字符串">2.5.2 多行模板字符串</span></h3><p>在模板字符串之前，如果想要在JavaScript中表示一个多行字符串，必须借助转义符、字符串连接、数组，甚至是借助注释。下面的代码总结了ES6之前最常见的几种多行字符串表示法。</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var escaped = </span><br><span class="line"><span class="comment">'The first line\n\</span></span><br><span class="line">A second line\n\ </span><br><span class="line"><span class="keyword">Then</span> a third line<span class="comment">'</span></span><br><span class="line"></span><br><span class="line">var concatenated = </span><br><span class="line"><span class="comment">'The first line\n' ` </span></span><br><span class="line"><span class="comment">'A second line\n' ` </span></span><br><span class="line"><span class="comment">'Then a third line'</span></span><br><span class="line"></span><br><span class="line">var joined = [ </span><br><span class="line">  <span class="comment">'The first line',</span></span><br><span class="line">  <span class="comment">'A second line', </span></span><br><span class="line">  <span class="comment">'Then a third line'</span></span><br><span class="line">].<span class="keyword">join</span>(<span class="comment">'\n')</span></span><br></pre></td></tr></table></figure>
<p>在ES6中，可以使用反引号来表示。模板字符串默认支持多行字符串。如下可以看出，代码中不再需要借助<code>\n</code>、连接符和数组。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var multiline = </span><br><span class="line">`The <span class="keyword">first</span> <span class="built_in">line</span></span><br><span class="line">A <span class="keyword">second</span> <span class="built_in">line</span> </span><br><span class="line">Then <span class="keyword">a</span> <span class="keyword">third</span> <span class="built_in">line</span>`</span><br></pre></td></tr></table></figure>
<p>多行字符串非常实用。比如，当需要在一堆HTML中插入多个变量时。如果需要在模板中展示一个列表，可以直接遍历这个列表，将对应的内容添加到相应的标签内。如下所示，这么做使得在模板中声明子组件变得非常容易。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">varbook=&#123;</span><br><span class="line">  title: <span class="string">'Modular ES6'</span>,</span><br><span class="line">  excerp<span class="variable">t:</span> <span class="string">'Here goes some properly sanitized HTML'</span>, </span><br><span class="line">  <span class="keyword">tag</span><span class="variable">s:</span> [<span class="string">'es6'</span>, <span class="string">'template-literals'</span>, <span class="string">'es6-in-depth'</span>]</span><br><span class="line">&#125;</span><br><span class="line">var html = `<span class="symbol">&lt;article&gt;</span> </span><br><span class="line">  <span class="symbol">&lt;header&gt;</span></span><br><span class="line">    <span class="symbol">&lt;h1&gt;</span>$&#123; book.title &#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  <span class="symbol">&lt;section&gt;</span>$&#123; book.excerpt &#125;&lt;/section&gt;</span><br><span class="line">  <span class="symbol">&lt;footer&gt;</span></span><br><span class="line">    <span class="symbol">&lt;ul&gt;</span></span><br><span class="line">      $&#123;</span><br><span class="line">        book.<span class="keyword">tags</span></span><br><span class="line">          .<span class="keyword">map</span>(<span class="keyword">tag</span> =&gt; `<span class="symbol">&lt;li&gt;</span>$&#123; <span class="keyword">tag</span> &#125;&lt;/li&gt;`)</span><br><span class="line">          .<span class="keyword">join</span>(<span class="string">'\n      '</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/article&gt;`</span><br></pre></td></tr></table></figure>
<p>上述代码会生出树下所示的HTML结构。可以看到空格被保留下来了[注释 3]，并且通过<code>join</code>方法中的一连串空格，保证了<code>&lt;li&gt;</code>标签能够正确缩进。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Modular ES6<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span>Here goes some properly sanitized HTML<span class="tag">&lt;/<span class="name">section</span>&gt;</span> <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>es6<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>template-literals<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>es6-in-depth<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>多行模板字符串在缩进方面存在问题。下例中，函数内包含一个模板字符串，模板字符串内的代码都有着同样缩进。我们可能会期待最终的结果是没有缩进的，但是最后字符串的前面会保留有四个空格的缩进。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">getParagraph</span>() &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="type">`</span></span><br><span class="line">    Dear Rod,</span><br><span class="line">    This <span class="keyword">is</span> a template literal string that<span class="symbol">'s</span> indented</span><br><span class="line">    four spaces. However, you may have expected <span class="keyword">for</span> it</span><br><span class="line">    to be <span class="keyword">not</span> indented <span class="keyword">at</span> <span class="keyword">all</span>.</span><br><span class="line"></span><br><span class="line">    Nico</span><br><span class="line">  `</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过下面这样的通用函数来将结果字符串中每一行的缩进移除，虽然这么做并不明智。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function unindent(<span class="built_in">text</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">text</span></span><br><span class="line">    .<span class="built_in">split</span>(<span class="string">'\n'</span>)</span><br><span class="line">    .<span class="built_in">map</span>(<span class="built_in">line</span> =&gt; <span class="built_in">line</span>.slice(<span class="number">4</span>))</span><br><span class="line">    .<span class="built_in">join</span>(<span class="string">'\n'</span>)</span><br><span class="line">    .<span class="built_in">trim</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些时候，最好是在将插值表达式的结果插入模板之前就进行预处理。对于这些更进一步的使用场景，可能需要用到另一种模板字符串，即<em>标签模板</em>。</p>
<h3><span id="253-标签模板">2.5.3 标签模板</span></h3><p>通常情况下，JavaScript中<code>\</code>具有特殊的含义，代表转义符。比如，<code>\n</code>表示换行，<code>\uoof1</code>表示<code>ñ</code>等。通过<code>String.raw</code>标签模板可以使得转义字符不进行转义。下面代码展示了如何使用<code>String.raw</code>，其中<code>\n</code>并没有被解释成换行。</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="literal">text</span> = <span class="built_in">String</span>.raw`<span class="string">"\n"</span> <span class="keyword">is</span> taken literally. </span><br><span class="line">It<span class="symbol">'ll</span> be escaped instead <span class="keyword">of</span> interpreted.` </span><br><span class="line">console.log(<span class="literal">text</span>)</span><br><span class="line">// <span class="string">"\n"</span> <span class="keyword">is</span> taken literally.</span><br><span class="line">// It<span class="symbol">'ll</span> be escaped instead <span class="keyword">of</span> interpreted.</span><br></pre></td></tr></table></figure>
<p>模板字符串的前缀<code>String.raw</code>是一个标签模板，用于解析模板字符串。标签模板接受一个数组参数和其他参数，数组中包含模板的每一个静态部分，其他参数对应每个表达式的计算结果。</p>
<p>思考一下以下代码中的标签模板。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag<span class="string">`Hello, <span class="subst">$&#123; name &#125;</span>. I am <span class="subst">$&#123; emotion &#125;</span> to meet you!`</span></span><br></pre></td></tr></table></figure>
<p>实际上，标签模板最终会被解释为如下所示的函数调用。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tag</span>(</span><br><span class="line">  [<span class="string">'Hello, '</span>, <span class="string">'. I am '</span>, <span class="string">' to meet you!'</span>],</span><br><span class="line">  <span class="string">'Maurice'</span>,</span><br><span class="line">  <span class="string">'thrilled'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>依次取出模板中的每个部分，并和相邻的表达式拼凑在一起，直到最终拼凑完模板中的所有部分，则为结果字符串。如果不知道默认模板字符串<code>tag</code>内部是如何实现的，参数列表理解起来比较困难。所以我们先学习一下<code>tag</code>的内部实现。</p>
<p>下面的代码是默认标签<code>tag</code>的一种可能实现方式。它的功能与不指定其他标签模板进行模板字符串处理时功能相同。它会将<code>parts</code>数组归纳为一个值，这个值以模板的第一部分开头，依次连接<code>values</code>中的值和模板中的内容，最终的值就是模板字符串的计算结果。通过rest参数语法来获取<code>...value</code>，能够更容易获取到模板字符串中每个表达式的计算结果。并且我们使用了带有隐式<code>return</code>语句的箭头函数，这样函数语句看起来更加简单。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(parts, <span class="rest_arg">...values</span>)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> parts.reduce(</span><br><span class="line">    (all, part, index) =&gt; all + values[index - <span class="number">1</span>] + part</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过以下代码来试运行上述的<code>tag</code>模板。可以看到，运行结果和不适用<code>tag</code>时相同，这是因为上述代码正是对默认模板行为的实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Maurice'</span></span><br><span class="line"><span class="keyword">var</span> emotion = <span class="string">'thrilled'</span></span><br><span class="line"><span class="keyword">var</span> text = tag<span class="string">`Hello, <span class="subst">$&#123; name &#125;</span>. I am <span class="subst">$&#123; emotion &#125;</span> to meet you!`</span> </span><br><span class="line"><span class="built_in">console</span>.log(text)</span><br><span class="line"><span class="comment">// &lt;- 'Hello Maurice, I am thrilled to meet you!'</span></span><br></pre></td></tr></table></figure>
<p>标签模板还有很多其他用法。比如，可以用来将用户输入变为大写，这样能够使得字符串看起来更加讽刺。下面的代码就实现了这一功能。相比与前面的<code>tag</code>，只是做了一些简单的修改，从而使得任意插入的字符串都转为大写形式。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upper</span><span class="params">(parts, <span class="rest_arg">...values</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parts.reduce((all, part, index) =&gt;</span><br><span class="line">    all + values[index - <span class="number">1</span>].toUpperCase() + part</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Maurice'</span></span><br><span class="line"><span class="keyword">var</span> emotion = <span class="string">'thrilled'</span></span><br><span class="line">upper`Hello, $&#123; name &#125;. I am $&#123; emotion &#125; to meet you!` </span><br><span class="line"><span class="comment">// &lt;- 'Hello MAURICE, I am THRILLED to meet you!'</span></span><br></pre></td></tr></table></figure>
<p>标签模板还有一个更加有用的用法，即可以通过标签模板来保证模板中插入的表达式的安全性。假设有一个模板，其中的所有表达式都是用户输入的内容，我们可以通过一个虚构的<code>sanitize</code>库来移除HTML标签和类似的危害，从而阻止用户在我们的网站中诸如恶意的HTML，防止跨域脚本攻击(XSS)。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sanitized</span><span class="params">(parts, <span class="rest_arg">...values</span>)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> parts.reduce((all, part, index) =&gt;</span><br><span class="line">    all + sanitize(values[index - <span class="number">1</span>]) + part</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> comment = <span class="string">'Evil comment&lt;iframe src="http://evil.corp"&gt; &lt;/iframe&gt;'</span></span><br><span class="line"><span class="keyword">var</span> html = sanitized`&lt;div&gt;$&#123; comment &#125;&lt;/div&gt;` </span><br><span class="line">console.log(html)</span><br><span class="line"><span class="comment">// &lt;- '&lt;div&gt;Evil comment&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure>
<p>看，恶意的<code>&lt;ifram&gt;</code>差点就得逞了。接下来，我们继续学习ES6的语法改变——<code>let</code>和<code>const</code>声明。</p>
<h2><span id="26-let和const声明">2.6 let和const声明</span></h2><p><code>let</code>声明是ES6中最广为人知的特性之一。它和<code>var</code>声明功能相似，但是它有着不同的作用域规则。</p>
<p>关于作用域，JavaScript有着一套非常复杂的规则集，以致于能弄疯很多初次尝试弄懂JavaScript变量工作原理的程序员。最终，当你知道了<em>变量提升</em>后，才开始对JavaScript有一点点感觉。<em>变量提升</em>是指不管变量声明在代码的哪个位置，它都会被提升到所在作用域的顶部。参看以下示例代码：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isItTwo</span><span class="params">(value)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (value === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> two = <span class="literal">true</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> two </span><br><span class="line">&#125;</span><br><span class="line">isItTwo(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// &lt;- true </span></span><br><span class="line">isItTwo(<span class="string">'two'</span>) </span><br><span class="line"><span class="comment">// &lt;- undefined</span></span><br></pre></td></tr></table></figure>
<p>尽管<code>two</code>是在if代码分支语句中声明的，但是可以在分支语句外访问到，所以上面的代码能够正常工作。这一行为是因为<code>var</code>声明会绑定到所在封闭作用域，如函数作用域或者顶级作用域。结合变量的提升，这就意味着前面缩写的代码将会被解释成如下所示的代码。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isItTwo</span><span class="params">(value)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> two</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="number">2</span>) &#123; </span><br><span class="line">    two = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> two </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管我们喜欢与否，与使用块级作用域的变量相比，变量提升更加让人困惑。块级作用域通过花括号来声明，而不是函数。</p>
<h3><span id="261-块级作用域和let声明">2.6.1 块级作用域和let声明</span></h3><p>如果我们想要一个更深的作用域，通过块级作用域，我们可以在现有分支代码语句(如<code>if</code>、<code>for</code>或<code>while</code>)的基础上，嵌套任意新的<code>{}</code>块即可，而不需要声明新的函数。或许你还不知道，只要我们愿意，JavaScript允许创建任意数量的块。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123; var deep = <span class="string">'This is available from outer scope.'</span>; &#125;&#125;&#125;&#125;&#125; </span><br><span class="line">console.log(deep)</span><br><span class="line">// &lt;- <span class="string">'This is available from outer scope.'</span></span><br></pre></td></tr></table></figure>
<p>如果使用<code>var</code>进行变量的声明，基于词法作用域，在<code>deep</code>变量声明所在块的外部仍然可以访问到该变量，并不会得到任何错误。但有时候这种情况能够抛出异常会更好，尤其是满足一下几个条件之一时：</p>
<ul>
<li>访问内部变量会破坏代码的封装性</li>
<li>内部变量和外部变量没有任何关联</li>
<li>同级的兄弟块中也可能使用相同的变量名</li>
<li>某个父级块中已经使用了所要用的变量名，但是仍在内部使用该变量。</li>
</ul>
<p><code>let</code>声明是<code>var</code>声明的一个替代方案。它遵循块级作用域规则而不是默认的词法作用域规则。使用<code>var</code>时，只能通过嵌套函数来创建更深的作用域。但是使用<code>let</code>仅通过新增一对花括号即可创建更深的作用域。这就意味着通过<code>{}</code>块就可以创建一个新的作用域，而不需要创建一个新的函数。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> topmost = &#123;&#125; </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> inner = &#123;&#125; </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> innermost = &#123;&#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在此处尝试访问innermost，会抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在此处尝试访问inner，会抛出异常</span></span><br><span class="line"><span class="comment">// 在此处尝试访问innermost，会抛出异常</span></span><br></pre></td></tr></table></figure>
<p><code>let</code>声明有一个非常有用的用法，如果在<code>for</code>循环中使用<code>let</code>，则变量的作用域会封闭在循环体内。下例就展示了这一用法。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123; </span><br><span class="line">  console.<span class="built_in">log</span>(i)</span><br><span class="line">  <span class="comment">// &lt;- 0</span></span><br><span class="line">  <span class="comment">// &lt;- 1</span></span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(i)</span><br><span class="line"><span class="comment">// &lt;- i is not defined</span></span><br></pre></td></tr></table></figure>
<p>在循环内声明的<code>let</code>变量会被封闭在每一次的循环内部，哪怕在函数体异步函数调用中使用这些变量也能够像预期一样工作，这一点和使用<code>var</code>声明的变量恰恰相反。我们一起看一下具体的例子。</p>
<p>首先，我们看一个关于<code>var</code>作用域工作原理的典型示例。<code>i</code>变量会绑定到<code>printNumbers</code>函数作用域，在循环添加每个timeout回调时，它的值会一直增加到<code>10</code>。等到每隔100毫秒执行每个回调函数时，<code>i</code>的值就是10，所以每次都会输出10。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printNumbers</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">for</span>(vari=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">100</span>) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printNumbers()</span><br></pre></td></tr></table></figure>
<p>相反地，如果使用<code>let</code>声明，会将变量绑定到块级作用域。虽然每次循环仍然会递增变量的值，但是每一次循环中都会创建一个新的绑定。也就是说每次添加timeout回调时，每个回调函数都会持有一个绑定保存当前变量<code>i</code>的引用，所以最终会输出期望中的结果：<code>0</code>到<code>9</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printNumbers</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">100</span>)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">printNumbers()</span><br></pre></td></tr></table></figure>
<p><code>let</code>还涉及“暂时性死区”这一概念。</p>
<h3><span id="262-暂时性死区">2.6.2 暂时性死区</span></h3><p>毫无疑问：下面这样的代码片段，必然会抛出异常。从作用域的开始，到<code>let</code>声明的执行之前，访问<code>let</code>声明的变量会报错。这就是所谓的暂时性死区(TDZ，Temporal Dead Zone)。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">name</span>)</span><br><span class="line">  <span class="comment">// &lt;- ReferenceError: name is not defined </span></span><br><span class="line">  let <span class="built_in">name</span> = <span class="string">'Stephen Hawking'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在<code>let name</code>声明执行之前访问该变量，程序会抛出异常。在<code>name</code>变量定义之前，声明一个函数，在函数内引用<code>name</code>变量时没问题的，只要不在暂时性死区内执行函数即可。在<code>let name</code>声明之前，都是<code>name</code>的暂时性死区。下面的代码并不会报错，因为<code>return name</code>并没有在<code>name</code>的暂时性死区内执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readName</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'Stephen Hawking'</span> </span><br><span class="line"><span class="built_in">console</span>.log(readName())</span><br><span class="line"><span class="comment">// &lt;- 'Stephen Hawking'</span></span><br></pre></td></tr></table></figure>
<p>相反，下面的代码会报错，因为在<code>name</code>离开暂时性死区之前就访问了<code>name</code>变量。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">readName</span>() &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="type">name</span></span><br><span class="line">&#125;</span><br><span class="line">console.log(readName())</span><br><span class="line">// ReferenceError: name <span class="keyword">is</span> <span class="keyword">not</span> defined </span><br><span class="line">let name = <span class="symbol">'Stephen</span> Hawking'</span><br></pre></td></tr></table></figure>
<p>注意，即使在声明的时候没有对<code>name</code>进行赋值，上面的示例行为并不会发生改变。下面的代码同样会抛出异常，同样因为在暂时性死区内访问了<code>name</code>变量。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">readName</span>() &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="type">name</span></span><br><span class="line">&#125;</span><br><span class="line">console.log(readName())</span><br><span class="line">// ReferenceError: name <span class="keyword">is</span> <span class="keyword">not</span> defined let name</span><br></pre></td></tr></table></figure>
<p>下面的代码能够正常工作，是因为它在离开了暂时性死区后才访问<code>name</code>变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readName</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name <span class="built_in">console</span>.log(readName()) </span><br><span class="line"><span class="comment">// &lt;- undefined</span></span><br></pre></td></tr></table></figure>
<p>只有一个特别的地方需要记住，即在函数声明中访问暂时性死区中的变量时没问题的，只要访问暂时性死区中变量的语句在<code>let</code>声明语句之后。</p>
<p>TDZ的主要目的是为了更容易地捕获错误，防止在用户代码声明变量前就访问变量，从而避免一些不可预期的行为。在ES6之前，由于变量的提升和不良的编码习惯，这一情况是非常常见的。在ES6中能够很简单地避免该问题。要记住提升仍然适用于<code>let</code>，即变量在作用域的开始就会创建，但是会产生暂时性死区，这些变量在声明语句没有执行前无法访问，在离开暂时性死区之后才能够访问。</p>
<p>我们已经学习了暂时性死区，是时候学习<code>const</code>声明了。它与<code>let</code>相似，但是也有很多不同。</p>
<h3><span id="263-const声明">2.6.3 Const声明</span></h3><p><code>const</code>声明和<code>let</code>相似，都只在块级作用域内有效，也存在暂时性死区。实际上，暂时性死区就是为了<code>const</code>而实现的，之后为了保持统一，也应用在了<code>let</code>上。<code>const</code>之所以需要暂时性死区，是因为如果没有暂时性死区，则可以在<code>const</code>声明执行之前给提升的<code>const</code>变量赋值，这样执行声明语句时就会报错。暂时性死区就是为了保证只在<code>const</code>声明时进行赋值而实现的，可以避免使用<code>let</code>时的一些潜在问题，并且使得其他依赖于暂时性死区的特性实现起来更加容易。</p>
<p>下例展示了<code>const</code>和<code>let</code>一样只在块级作用域内有效。</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built-in">pi</span> = <span class="number">3.1415</span> </span><br><span class="line">&#123;</span><br><span class="line">  const <span class="built-in">pi</span> = <span class="number">6</span> </span><br><span class="line">  console.<span class="built-in">log</span>(<span class="built-in">pi</span>) </span><br><span class="line">  <span class="comment">// &lt;- 6</span></span><br><span class="line">&#125; </span><br><span class="line">console.<span class="built-in">log</span>(<span class="built-in">pi</span>) </span><br><span class="line"><span class="comment">// &lt;- 3.1415</span></span><br></pre></td></tr></table></figure>
<p>前面提到<code>let</code>和<code>const</code>有很多不同之处。第一个不同之处就是使用<code>const</code>声明的变量必须在声明时就进行初始化，如下例所示：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e <span class="comment">// SyntaxError, missing initializer</span></span><br></pre></td></tr></table></figure>
<p>除了在声明时初始化外，使用<code>const</code>声明的变量无法重复赋值，即<code>const</code>初始化之后，无法再改变它的值。在严格模式下，改变<code>const</code>变量的值会报错。非严格模式下，不会报错，改变不生效，如下面的代码所示。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const people = [<span class="string">'Tesla'</span>, <span class="string">'Musk'</span>] </span><br><span class="line">people = []</span><br><span class="line">console.log(people)</span><br><span class="line">// &lt;- [<span class="string">'Tesla'</span>, <span class="string">'Musk'</span>]</span><br></pre></td></tr></table></figure>
<p>需要注意的是，创建一个<code>const</code>变量并不意味值所赋的值不可改变。这是一个常见的混淆点，所以强烈建议仔细阅读以下警告信息。</p>
<blockquote>
<h2><span id="使用const声明的变量并不是不可变的">使用<code>const</code>声明的变量并不是不可变的</span></h2><p>使用<code>const</code>声明只是意味着所声明的变量会一直持有对同一个对象和初始值的引用，所以保持不变的只是这个引用。引用保持不变，但是引用所指向值并不是不可变的。
从下例可以看出，尽管<code>people</code>的引用不能被改变，但是数组本身确实可以修改。如果数组时不可变的，下面的结果则是不可能的。
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [<span class="string">'Tesla'</span>, <span class="string">'Musk'</span>] </span><br><span class="line">people.push(<span class="string">'Berners-Lee'</span>) </span><br><span class="line">console.<span class="built_in">log</span>(people)</span><br><span class="line">// &lt;- [<span class="string">'Tesla'</span>, <span class="string">'Musk'</span>, <span class="string">'Berners-Lee'</span>]</span><br></pre></td></tr></table></figure></p>
<p><code>const</code>声明只会禁止变量绑定到一个新的引用。也可以从另一方面来说明。下面的代码中，我们使用<code>const</code>创建了一个<code>people</code>变量，然后将这个变量赋值给了一个普通的用<code>var</code>声明的<code>humans</code>变量。我们可以给<code>humans</code>重新赋值其他引用，是因为它并不是使用<code>const</code>声明的。但是我们不能将其他引用赋给<code>people</code>，因为它是通过<code>const</code>声明的。
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [<span class="string">'Tesla'</span>, <span class="string">'Musk'</span>] </span><br><span class="line"><span class="keyword">var</span> humans = people</span><br><span class="line">humans = <span class="string">'evil'</span> </span><br><span class="line"><span class="built_in">console</span>.log(humans)</span><br><span class="line"><span class="comment">// &lt;- 'evil'</span></span><br></pre></td></tr></table></figure></p>
<p>如果想要确保值不变，可以使用<code>Object.freeze</code>函数。使用<code>Object.freeze</code>可以禁止对传入的对象进行扩展，如下例所示：
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> frozen = <span class="built_in">Object</span>.freeze( </span><br><span class="line">  [<span class="string">'Ice'</span>, <span class="string">'Icicle'</span>, <span class="string">'Ice cube'</span>]</span><br><span class="line">)</span><br><span class="line">frozen.push(<span class="string">'Water'</span>)</span><br><span class="line"><span class="comment">// Uncaught TypeError: Can't add property 3 </span></span><br><span class="line"><span class="comment">// object is not extensible</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>现在我们一起讨论下<code>const</code>和<code>let</code>的优势吧。</p>
<h3><span id="264-const和let的优势">2.6.4 const和let的优势</span></h3><p>永远不要为了使用新特性而使用新特性。ES6特性应该合理应用在能够真正提升代码可读性和可维护性的地方。很多情况下，<code>let</code>声明能够简化一部分代码逻辑，比如当我们需要在函数的顶部进行<code>var</code>声明，从而保证变量的提升不会产生意想不到的结果。使用<code>let</code>就可以不用在整个函数的顶部进行声明，可以在块级作用域的顶部声明，可以减少思维从作用域顶部开始延续的范围。</p>
<p>使用<code>const</code>声明能够有效地避免一些事故。下面的代码展示一个可能会发生错误的场景：当我们将<code>items</code>的引用传递给<code>checklist</code>函数，这个函数会返回一个<code>todo</code>API用于操作传入的<code>items</code>引用。当<code>items</code>变量被改变，引用指向其他数组时，情况就完全不一样了——<code>todo</code>API仍然会从操作<code>items</code>之前引用的值，而<code>items</code>引用了其他的值。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">items</span> = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>] </span><br><span class="line">var todo = checklist(<span class="built_in">items</span>) </span><br><span class="line">todo.check() </span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">items</span>)</span><br><span class="line">// &lt;- [<span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="built_in">items</span> = [<span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line">todo.check()</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">items</span>)</span><br><span class="line">// &lt;- [<span class="string">'d'</span>, <span class="string">'e'</span>], 如果使用const声明<span class="built_in">items</span>，结果将会是[<span class="string">'c'</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checklist</span><span class="params">(items)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    check: () =&gt; <span class="built_in">items</span>.shift()</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种问题是很难调试的，可能需要花不短的时间，才能查出引用被改变而导致的问题。如果<code>const</code>声明能够防止这一情景，因为使用<code>const</code>会在运行时报错（严格模式下），从而能够在问题发生时定位到问题所在。</p>
<p>使用<code>const</code>声明还有一个相似的好处就是能够显示地定义不可重复赋值的变量。<code>const</code>表明变量引用的绑定是只读的，这样我们在阅读代码时就不用关心这些常亮了。</p>
<p>如果我们默认使用<code>const</code>声明，使用<code>let</code>声明需要重复赋值的变量，所有的变量都会遵循相同的作用域规则，会使得代码更加易于理解。为什么会提议默认使用<code>const</code>声明方式呢，是因为只需要使用它就能够达成以下几点目标：禁止重新赋值，遵循块级作用域，并且在变量声明语句执行之前不能访问变量。<code>let</code>语句虽然允许重新赋值，但是它的行为和<code>const</code>类似，所以如果需要一个可以重新赋值的变量可以选择使用<code>let</code>声明。</p>
<p>另一方面，<code>var</code>声明方式更加复杂，如由于函数作用域规则，在分支语句中使用较为困难；并且<code>var</code>允许重新赋值，且可以在变量声明语句执行访问变量。由于<code>var</code>做的事情并不如<code>const</code>和<code>let</code>多，所以<code>var</code>不优先级使用，在现代JavaScript代码库中并不常见。</p>
<p>通过本章，我们学习了默认使用<code>const</code>，在需要重新赋值时使用<code>let</code>。第九章我们将会学习更多关于这一选择的原因。</p>
<blockquote>
<p>[注释 1] 和polyfill一样，<a href="https://ponyfoo.com/articles/polyfills-or-ponyfills" target="_blank" rel="noopener">ponyfill</a>是对于在每一个JavaScript运行环境中都不可用的功能的用户实现。polyfill主要是试图修补运行环境，从而使其看起来内部支持某一特性，而ponyfill是将运行环境中缺失的功能实现成为一个独立的模块，并且不会污染运行环境。这样做的好处是不会超出第三方库对于运行环境的期望，因为它们可能并不知道我们的polyfill。</p>
<p>[注释 2] <a href="https://mjavascript.com/out/label" target="_blank" rel="noopener">Label</a>用于定义指令。可以用在<code>goto</code>语句中，用来指明需要跳转的指；也可以用在<code>break</code>语句中，表示所要跳出的序列；还有<code>continue</code>语句中，表示想要执行的序列。</p>
<p>[注释 3] 在使用多行模板字符串时，空格并不会被自动保留。不过多数情况下，我们只需要提供足够多的缩进就能使其保留空格。所以缩进时需要注意，避免导致在代码块嵌套时产生不正确的缩进。</p>
</blockquote>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://verymuch.com/2017/11/01/第二章-ES6-基础/" data-id="cjb76j5hm000jxqs647ijtoxd" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://verymuch.com/2017/11/01/第二章-ES6-基础/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="http://verymuch.com/2017/11/01/第二章-ES6-基础/">评论</a>
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2017/11/01/Javascript-RegExp正则表达式/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    Javascript - RegExp正则表达式
                
            </div>
        </a>
    
    
        <a href="/2017/10/23/第一章-ECMAScript-和-JavaScript-的未来/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">第一章 ECMAScript 和 JavaScript 的未来</div>
        </a>
    
</nav>


    
</article>


    
    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>

</section>
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/12/14/Data-URL简介与使用/" class="thumbnail">
    
    
        <span style="background-image:url(/images/data-url.jpeg)" alt="Data URL简介与使用" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2017/12/14/Data-URL简介与使用/" class="title">Data URL简介与使用</a></p>
                            <p class="item-date"><time datetime="2017-12-14T00:34:41.000Z" itemprop="datePublished">2017-12-14</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/12/12/escape、encodeURI和encodeURIComponent的区别与使用/" class="thumbnail">
    
    
        <span style="background-image:url(/images/encode.jpg)" alt="escape、encodeURI和encodeURIComponent的区别与使用" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2017/12/12/escape、encodeURI和encodeURIComponent的区别与使用/" class="title">escape、encodeURI和encodeURIComponent的区别与使用</a></p>
                            <p class="item-date"><time datetime="2017-12-12T14:51:18.000Z" itemprop="datePublished">2017-12-12</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/11/01/Javascript-RegExp正则表达式/" class="thumbnail">
    
    
        <span style="background-image:url(/images/js.jpeg)" alt="Javascript - RegExp正则表达式" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2017/11/01/Javascript-RegExp正则表达式/" class="title">Javascript - RegExp正则表达式</a></p>
                            <p class="item-date"><time datetime="2017-11-01T14:28:23.000Z" itemprop="datePublished">2017-11-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/11/01/第二章-ES6-基础/" class="thumbnail">
    
    
        <span style="background-image:url(/images/practical-modern-javascript.gif)" alt="第二章 ES6 基础" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2017/11/01/第二章-ES6-基础/" class="title">第二章 ES6 基础</a></p>
                            <p class="item-date"><time datetime="2017-11-01T08:53:14.000Z" itemprop="datePublished">2017-11-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/10/23/第一章-ECMAScript-和-JavaScript-的未来/" class="thumbnail">
    
    
        <span style="background-image:url(/images/practical-modern-javascript.gif)" alt="第一章 ECMAScript 和 JavaScript 的未来" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2017/10/23/第一章-ECMAScript-和-JavaScript-的未来/" class="title">第一章 ECMAScript 和 JavaScript 的未来</a></p>
                            <p class="item-date"><time datetime="2017-10-23T10:54:46.000Z" itemprop="datePublished">2017-10-23</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/EXERCISE-SPACE/">EXERCISE_SPACE</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GROWING-SPACE/">GROWING_SPACE</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/他人经验总结/">他人经验总结</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作效率/">工作效率</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/有感/">有感</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/沉淀/">沉淀</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/翻译/">翻译</a><span class="tag-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/他人经验总结/" style="font-size: 10px;">他人经验总结</a> <a href="/tags/工作效率/" style="font-size: 10px;">工作效率</a> <a href="/tags/有感/" style="font-size: 10px;">有感</a> <a href="/tags/沉淀/" style="font-size: 20px;">沉淀</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2017 verymuch<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_config = function () {
        
            this.page.url = 'http://verymuch.com/2017/11/01/第二章-ES6-基础/';
        
        this.page.identifier = '第二章-ES6-基础';
    };
    (function() { 
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'hexo-theme-icarus' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>



    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>