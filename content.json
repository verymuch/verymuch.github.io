{"meta":{"title":"歪马行空","subtitle":"做一只默默奋斗的程序猿~！","description":null,"author":"verymuch","url":"http://verymuch.com"},"pages":[{"title":"Tags","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"tags/index.html","permalink":"http://verymuch.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"about/index.html","permalink":"http://verymuch.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://verymuch.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-09T10:11:56.208Z","updated":"2018-02-09T10:11:56.000Z","comments":true,"path":"css/custom.css","permalink":"http://verymuch.com/css/custom.css","excerpt":"","text":"@import './custom-toc.css'; .text-highlight { color: red; } .text-hint { color: #999; } button { padding: 5px 10px; background: #38b7ea; color: #fff; border: none; border-radius: 2px; cursor: pointer; } /* 示例区域 */ .demo-area { border: 1px solid #f8f8f8; padding: 10px; } .demo-area textarea { display: block; margin-top: 5px; width: 100%; height: 120px; } .demo-area canvas { width: 200px; height: 100px; } /* 重置样式 */ .article-entry td { padding: 0; }"},{"title":"","date":"2018-02-10T02:50:50.189Z","updated":"2018-02-10T02:50:50.000Z","comments":true,"path":"js/generate-toc.js","permalink":"http://verymuch.com/js/generate-toc.js","excerpt":"","text":"$(window).ready(() => { // 生成目录容器 const $article = $(\".article\"); const $tocContainer = $(\"\").addClass(\"custom-toc-container\"); const $img = $(\"\").attr({ src: \"https://p0.ssl.qhimg.com/t01b4b55a270cdc08a6.png\" }); $img.appendTo($tocContainer); $tocContainer.appendTo($article); // 根据文章内容，为二级标题生成目录 const headers = $(\"h2,h3\", $article); const headersArr = [...headers]; const $toc = $(\"\").addClass(\"custom-toc\"); headersArr.forEach(header => { const headerText = $(header).text(); const hash = $(\"span\", header).attr(\"id\"); const className = header.tagName === \"H2\" ? \"custom-toc--h2\" : \"custom-toc--h3\"; const $newLink = $(\"\") .attr(\"href\", `#${hash}`) .html($(header).text()); const $newLi = $(\"\").addClass(className); $newLink.appendTo($newLi); $newLi.appendTo($toc); }); $toc.appendTo($tocContainer); });"},{"title":"","date":"2018-02-10T02:46:30.313Z","updated":"2018-02-10T02:46:30.000Z","comments":true,"path":"css/custom-toc.css","permalink":"http://verymuch.com/css/custom-toc.css","excerpt":"","text":".article { position: relative; } .custom-toc-container { position: absolute; top: 5px; right: 5px; width: 36px; height: 36px; border-radius: 50%; background: #f6f8f9; z-index: 2; cursor: pointer; border: 15px solid white; } .custom-toc-container:hover { background: #edf4ef; } /* .custom-toc-container:before { position: absolute; display: block; width: 10px; height: 10px; background: white; content: \"\"; top: 20px; left: -12px; z-index: 3; transform: translate(0, -50%) rotate(45deg); box-shadow: 0.5px -0.5px 1px 0 rgba(0, 0, 0, 0.12), 0.5px -0.5px 1.5px 0 rgba(0, 0, 0, 0.04); } */ .custom-toc-container img { width: 18px; height: 18px; line-height: 36px; display: block; margin: 10px auto; } .custom-toc-container:hover .custom-toc { display: block; } .custom-toc { display: none; position: absolute; max-height: 400px; overflow-y: scroll; top: 0; right: 40px; background: white; padding: 15px 20px 15px 15px; border-radius: 3px; line-height: 2; box-shadow: 0px 2px 2px 0px rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); border: 1px solid #eee; } .custom-toc li { cursor: pointer; min-width: 160px; max-width: 600px; white-space: nowrap; } .custom-toc .custom-toc--h3 { padding: 0 0 0 20px; } .custom-toc li a { transition: all 0.3s ease; color: #333; } .custom-toc li:hover a { color: #38b7ea; } .custom-toc--h2 { font-size: 13px; } .custom-toc--h3 { font-size: 12px; }"}],"posts":[{"title":"css性能优化的7个技巧","slug":"css性能优化的9个技巧","date":"2018-07-22T15:49:10.000Z","updated":"2018-07-22T17:38:23.346Z","comments":true,"path":"2018/07/22/css性能优化的9个技巧/","link":"","permalink":"http://verymuch.com/2018/07/22/css性能优化的9个技巧/","excerpt":"","text":"CSS性能优化的9个技巧我们都知道网站的性能很重要，CSS作为页面渲染和展现内容的重要环节，其性能相关的优化也是不容忽视的。关于性能优化我们经常是在项目完成才去考虑，经常被推迟到项目的末期，这样就导致优化的范围缩小，往往最终只是进行一下文件压缩和缓存策略的调整，但这样做并不高效。本文将从CSS的编写到使用依次介绍CSS性能优化的9个技巧，借此帮助大家对CSS性能优化形成一个整体认识，从而能够在项目的整个过程中穿插进行性能优化。 在正式开始之前，需要大家对于浏览器的渲染机制有一定的了解，尚不明确的小伙伴可以点击查看以下链接。 1. 有选择地使用选择器由于CSS选择的匹配是从右向左进行的，所以不同种类的选择器具有不同的性能。相比于#app-content-h3，显然使用body .content h3时，浏览器生成渲染树（render-tree）时所花费的时间更多。不过现代浏览器在这一方面做了很多优化，所以这一区别并不明显。此外不同选择器的性能在不同浏览器中的表现并不统一，在编写CSS的时候无法兼顾每种浏览器。鉴于以上原因，在使用选择器时，我们只需要了解或记住以下几点内容即可，其他的可以全凭喜好。 保持简单，不要使用嵌套过多过复杂的选择器 通配符和属性选择器效率最低，不要过多使用 不要使用类选择器和ID选择器修饰元素标签，这样多此一举，反而会降低效率。 不要为了追求速度而放弃可读性与可维护性 为什么是从右向左匹配？CSS的选择器中更多的是不匹配的，所以在考虑性能问题时，就是要考虑如何让选择器不匹配时的效率更高。那么如果为了这一目的，在匹配时多耗费一些性能也是值得的。 2. 减少使用昂贵的属性浏览器绘制屏幕时，需要浏览器进行操作或计算的属性都需要花费更大的代价。当页面发生重绘时，它们会降低浏览器的性能。所以在编写CSS的过程中，我们应该尽量减少昂贵属性的使用。当然，并不是不鼓励大家使用，而是让大家建立这样一个概念，在有两种方案可以选择的时候，可以选择没有昂贵属性的那一种，这样能够在不断的积累中，提高网站的性能。 CSS中较为昂贵的属性包括以下几种： box-shadow border-radius transparency transform filter :nth-child position: fixed; 3. 优化重排与重绘3.1 减少重排重排会导致浏览器重新计算整个文档，重新构建渲染树。这一过程会降低我们的渲染速度。如下所示，有很多操作会触发重排，我们应该避免频繁进行一下操作。你还可以通过CSS Trigger查询哪些属性会触发重排与重绘。 改变font-size和font-family 改变元素的内外编剧 通过JS改变CSS类 通过JS获取DOM元素的位置相关属性（如width/height/left等） CSS伪类激活 滚动滚动条或者改变窗口大小 需要注意的是，某些CSS属性具有更好的重排性能。如使用Flex时，比使用inline-block和float时重排更快。 3.2 避免不必要的重绘当现有元素的外观发生改变时，会触发重绘。在网站的使用过程中，是无法避免和减少重绘的。浏览器对此做了优化，它会将多次的重排、重绘操作合并为一次执行。不过我们仍然需要避免不必要的重绘，如页面滚动时触发的hover事件，我们可以在滚动的时候禁用hover事件，这样页面在滚动时会更加流畅。 4. 动画性能现在我们编写的CSS中有着越来越多动画相关的代码，我们已经习惯于使用动画来提升用户体验。 5. 文件压缩前面已经讨论了在CSS编写时，我们可以注意的提升性能的技巧，下面我们讨论下如何减小文件的大小。 文件压缩是性能优化时最容易想到，也最容易实现的方法，并且这一方案效果显著。文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现地尤为明显。相信大家都早已习惯对CSS进行压缩，现代的构建工具，如webpack、gulp/grunt、rollup等也都支持CSS压缩功能。压缩后的文件能够明显减小，大大降低了浏览器的加载时间。 css nano 6. 去除无用CSS虽然文件压缩能够降低文件大小。但CSS文件通知只会进行空格去除的压缩操作，这样就限制了CSS文件的压缩比例，固定的文件在去除完空格后就没有了优化的空间。那么这时我们应该怎么办呢？ 如果压缩后的文件仍然超出了预期的大小，那么此时我们就应该考虑是不是代码中存在太多无用的CSS。一般情况下，会存在这两种无用的CSS代码：一种是不同元素或者其他情况下的重复代码，一种是整个页面内没有生效的CSS代码。对于前者，在编写的代码时候，我们应该尽可能地提取公共类，减少这种重复。对于后者，在不同开发者进行代码维护的过程中，总会产生不再使用的CSS的代码。这个时候如果手动来删除这些代码，显然是不明智的。我们可以借助Uncss库来进行。Uncss可以用来移除样式表中的无用CSS，并且支持多文件和JavaScript注入的CSS。 去除了无用CSS后的代码，不仅能够使浏览器下载更少的代码，也能使浏览器解析更少的样式。这对性能来说都是很大的提升。 7. 不要使用@import前面已经说完了编写CSS和减小文件相关的性能优化技巧，下面我们接着讨论CSS使用时有哪些优化技巧。 首先需要强调的是，不要使用@import引入CSS。使用@import引入CSS会影响浏览器的并行下载，并且多个@import会导致下载顺序紊乱。所以不要使用这一方法，使用link标签就行了。 8. critical css确保CSS快速下载的一种方法是内联。内联意味着直接将外部CSS资源插入到HTML文档中。这种技术最适合于较小的资源，但使用它会有显著的不同。 当使用外部CSS文件时，必须在HTML文档下载完成后再分别下载它们。而内联CSS减少了浏览器在开始页面呈现之前所需下载的数据量。可以说内联是一举两得的方法。但是这种方式并不适合用于内联大的CSS文件。我们应当只将渲染首屏（above the fold）内容所需的样式内联到html即可。因为初始拥塞窗口存在限制（通常是 14.6kB 压缩后大小），如果所需的数据量超出了限制，系统就需要在服务器和浏览器之间进行更多次的往返，从而不能更快地渲染页面。 Github上有一个项目Critical CSS，可以帮助我们将属于首屏的样式提取出来，可以通过gulp/grunt来使用。 9. 异步加载cssCSS会阻塞渲染，在CSSOM构建完毕之前，浏览器将不会渲染任何已处理的内容。所以我们需要解除CSS对渲染的阻塞，通常我们可以利用媒体类型和查询来解除渲染阻塞。除此之外，在将首屏关键css内联之后，我们可以异步加载整个剩余的CSS文件。 参考文章 Efficiently Rendering CSS How to write CSS for a great performance web application CSS performance revisited: selectors, bloat and expensive styles Avoiding Unnecessary Paints Five CSS Performance Tools to Speed up Your Website How and Why You Should Inline Your Critical CSS Render blocking css Prefer Async Script Loading","categories":[],"tags":[]},{"title":"第三章 类、Symbol、对象和装饰器","slug":"第三章-类、Symbol、对象和装饰器","date":"2018-05-30T06:24:57.000Z","updated":"2018-06-15T02:02:28.974Z","comments":true,"path":"2018/05/30/第三章-类、Symbol、对象和装饰器/","link":"","permalink":"http://verymuch.com/2018/05/30/第三章-类、Symbol、对象和装饰器/","excerpt":"","text":"到本章之前，我们已经学完了ES6语法方面的基本改进。现在可以将目标放在其他新增内容上了，如类和Symbol。类参考了传统基于类的编程范式，是一种表达原型链继承的新语法格式。Symbol和字符串、布尔值、数值一样，是一种新的Javascript原始值类型。类和Symbol能用来定义协议，本章我们将进行深入了解。了解类和Symbol之后，我们会简单讨论一下ES6中Object新增的内置静态方法。 3.1 类JavaScript是一门基于原型的语言，类很大程度上可以认为是原型继承的一种语法糖。类与原型继承之间的最主要区别是前者可以继承其他类，这样我们就能够继承内置的Array对象，而在ES6之前想要这么做是很复杂的。 class关键字就像一种魔法。它使得Javascript对于习惯于其他范式的编程者们更具吸引力，这些编程者对于原型链可能并不完全熟悉，而class更易于理解。 3.1.1 类的基本原理想要学习一个新的语言特性，我们可以先找到语言中现有的此类概念，然后具体研究下新的特性是如何改进之前的使用场景的，这样做一直都是一个很好的学习方法。接下来，我们先看一个简单的基于原型的JavaScript构造函数，然后和ES6中的类语法进行比较。 下面的这段代码展示了如何定义构造函数Fruit并在原型上添加两个方法。构造函数中有三个属性：name、表示水果卡路里量的calories，以及水果的块数pieces，默认为1。原型上存在两个方法：.chop和.bite。.chop方法会将水果多切出一块。而传入.bite方法的person会吃掉一块水果，并且其satiety饱食度会增加相应的值，值为剩余卡路里量除以剩余的水果块数。 [P58 代码1] 上述代码较为简单，从中我们能够看出：有一个构造函数，接受两个参数，有两个方法，和一些属性。下面这段代码展示了如何如何创建一个Fruit和person，并且将水果切成四份，然后让人吃掉其中三份。 [P58 代码2，P59 代码1] 下述代码展示了使用class语法的方法，从中可以看出，constructor函数显示声明在Fruit类，且方法使用了对象字面量方法定义语法。对比该方法和前面的基于原型的方法能够发现：定义方法时，省去了很多将引用显示指向Fruit.prototype的模板代码。实际上，将整个声明都写在class语句块内部还能够帮助读者理解整块代码的作用，能够更清晰地表达声明的类的意图。最后，将constructor显示声明为Fruit的一个成员方法使得class语法比基于原型的类语法更容易理解。 [P59 代码2] 有个较大的细节可能你还没有注意到——Fruit类中的方法声明之间没有逗号分隔。其实，这并不是因为文字编辑的疏忽而产生的错误，而是class语法中的一部分。这一差别能够使我们避免误解对象和类之间存在某些关联，实际上他们之间没有关联。并且这一区别也会使得类语法更适合做进一步的改动，如公有和私有类字段。 基于类的方法和前面缩写的基于原型的代码是等价的：创建Fruit的方法一点也没变；Fruit的API方法也没有任何改变。上述我们实例化一个苹果，将其切成更小的4块，然后吃掉3块的代码在使用class语法定义的Fruit构造函数中依然有效。 值得注意的是，和函数定义不同，类声明不会提升到所在作用域的顶部。所以在类声明到达并执行之前，无法进行实例化以及其他存取方式。 [P60 代码1] 与函数声明和函数表达式像是，除了前面所说的类声明语法，还可以通过表达式的方式声明类。在类表达式中可以省略类的名称，代码如下所示。 [P60 代码2] 类表达式能够很方便地通过函数返回，从而可以使用最小的代价建立一个类的工厂函数。如下例，我们可以通过箭头函数动态创建JakePerson类，箭头函数接受一个name参数，然后通过super()传入父类Person的构造函数中。 [P60 代码3] 后续我们会继续深入类的继承，现在先让我们更细致地研究下属性和方法。 3.1.2 类的属性和方法需要指出的是，在class声明中，constructor方法的声明是可选的。下述代码是一个完整有效的类声明及与其对应的同名空构造函数。 [P61 代码1] 如下，传入new Log()的参数都会接受并作为Log中constructor方法的参数，可以使用这些参数初始化类的实例。 [P61 代码2] 下例的类中展示了如何在每个实例的构造过程中创建并初始化一个名为count的属性。get next方法表明Counter类的实例会有一个next属性，访问该属性属性时返回调用该方法的结果。 [P61 代码3] 这时，在下例中可以这样使用Counter类。每次访问.next属性时，count的值会自动加1。尽管很有用，但是这种做法通常更适合使用方法实现，而不是使用神奇的get属性存取器。并且我们要当心不要滥用属性存取器，使用一个滥用存取器的的对象会变得很混乱。 [P61 代码4，P62 代码1] 不过，当与setter方法一起使用时，存取器能够在对象和底层的数据存取之间搭建一条很有趣的桥梁。思考一下下例，通过传入存储的key值，我们可以从localStorage中存取JSON数据。 [P62 代码2] 接下来我们可以使用下例中的方式来使用LocalStorage类。任何赋值给ls.data的值都会转换为JSON对象字符串的形式，然后存入localStorage中。并且当属性值被读取的时候，通过同一个key值可以获取之前存储的内容，然后将其解析成JSON对象后返回。 [P62 代码3] 除了getters和setters外，还可以定义常规的实例方法，前面创建Fruit类的时候我们已经这么做了。下述代码中，创建了能够吃前面声明过的Fruit实例的Person类。然后实例化了一个fruit和person，并且让person吃了fruit。最终person的饱食度等于40，因为它吃光了整个水果。 [P62 代码4，P63 代码1] 有时候需要在类层添加静态方法，而不是在实例层添加成员方法。在ES6之前可以这样实现：实例方法显示添加在原型链上，而静态方法直接添加在构造函数上。 [P63 代码2] 类语法可以通过static关键字定义类似Person.isPerson的静态方法，使用方法和定义getter和setter时的get、set前缀类似。 下例定义了MathHelper类，该类有一个名为sum的方法，该方法通过Array#reduce方法计算所有传入的数值参数的总和。 [P63 代码3] 最后，值得一提的是，我们也可以定义静态属性存取器，如static get、static set。这一功能迟早有用，尤其是在维护类的全局配置状态时或者在单例模式下使用类时。当然，这种时候你可能更倾向于使用普通对象，而不是创建一个不会实例化或者只实例化一次的类。毕竟，这就是JavaScript，一个高度动态的语言。 3.1.3 类的继承我们可以使用普通的JavaScript方法实现Fruit类的继承，但是看了下述代码后你会发现：声明子类时，为了将参数传入父类来保证正确初始化子类，引入了较为深奥的知识点，如Parent.call(this)；并且将父类原型的一个实例设为了子类的原型。关于原型继承在网上可以找到很多信息，此处我们不再详细讨论原型继承的细节。 [P64 代码1] 鉴于上面需要大家记住的“短命知识”（译者注：此处应该是指上述所说的call方法，提到这个深奥的知识点后，虽然需要大家记住，但是后面就不用了）和Object.create只在ES5之后可用，JavaScript开发者们过去习惯于借助库来解决原型继承问题。如Node.js中的util.inherits方法，就因为支持度原因比Object.create更受喜爱。 [P64 代码2] 除了具有name属性和已经赋值的calories属性，以及额外的slice方法外，Banana构造函数的使用方法和Fruit没有什么不同。其中，slice方法能够快速将香蕉实例切为12块。下述代码中展示了吃了一块之后的Banana的实际状态。 [P64 代码2，P65 代码1] 类统一了原型继承，但是到现在为止还存在很大的争议，因为很多库正在尝试使用更简单的方式来处理JavaScript中的原型继承。 Fruit类很适合继承。下述代码中我们创建了继承自Fruit类的Banana类。此时，这种语法能够清晰表达我们的意图，并且我们不用担心难以完全理解达到所需结果的原型继承。如果想要将参数转而传入给底层的Fruit构造函数时，可以使用super。super关键字也可以在父类中使用（如super.chop），并且限制只能在constructor中使用。 [P65 代码2] 尽管class关键字是静态的，但在声明类时仍然可以利用JavaScript的灵活和功能属性。任何返回构造函数的表达式都可以被继承。比如，我们可以创建一个构造函数工厂函数，然后用其作为基类。 如下代码，定义了createJuicyFruit函数，该函数通过super调用将水果的name和calories转发到Fruit类中。然后，要做的就是创建Plum继承自中间类JuicyFruit类。 [P65 代码3，P66 代码1] 接下来，我们继续学习Symbol。虽然不是一种迭代或者流控制机制，但是学习Symbol对理解迭代机制至关重要，迭代机制将在后面的章节详细讨论。 3.2 SymbolSymbol是ES6中新增的原始值类型，是第七种数据类型。和字符串、数值一样，Symbol是一种独一无二的数据类型。但与字符串、数值不同的是，Symbol不具备字面量表示形式，诸如字符串中的&#39;text&#39;、数值中的1。Symbol的主要目的是用来实现协议。例如，迭代协议使用Symbol定义对象应该如何被迭代，这部分内容会在第四章的第二小节中学到。 Symbol有三种类型，每一种都使用不同的方式来访问。这三种类型分别是：本地Symbol，通过内置Symbol包装对象创建和通过存储引用和反射来访问；全局Symbol，通过另一种API创建，并且跨代码域共享；内置Symbol，用于定义内部语言行为。 我们将会依次学习这三种类型，并在学习的过程中探索可能的使用方式。先从本地Symbol开始。 3.2.1 本地SymbolSymbol可以通过Symbol包装对象创建。下述代码中，我们创建了first Symbol值。 [P66 代码2] 对于Number和String我们可以通过new关键字来调用，但是当new和Symbol一起使用时会抛出TypeError异常。这样能够避免类似new Number(3) !== Number(3)的误解和混淆行为。从以下代码片段可以看出new和Symbol一起使用时所抛出的异常信息。 [P67 代码1] 为了更方便调试，我们可以在创建Symbol的时候使用描述。 [P67 代码2] 与数值或者字符串一样，Symbol值是不可变的。然而，与另两种数据类型不同，Symbol的值是独一无二的。如下述代码所示，描述并不会影响Symnbol值的唯一性。使用相同描述创建的Symbol值仍然是唯一的，互不相等的。 [P67 代码3] Symbol的typeof结果为symbol，是ES6中新增的结果。下述代码展示了Symbol新增的typeof值字符串。 [P67 代码4] Symbol可以用作对象的属性key值。如下所示，我们可以使用可计算属性，从而避免使用额外的语句来将名为weapon的Symbol值设为character对象的key值。此外，为了能够访问对应的Symbol属性，我们也需要保存用于创建所述属性的Symbol值的引用。 [P67 代码5] 常规的从对象中读取key值的方法都是没法获取到Symbol类型的key的。从下面代码可以看出，for..in、Object.keys、Object.getOwnPropertyNames均美不能获取到Symbol属性。 [P68 代码1] 这一表现的好处就是ES6之前写的、没有Symbol的代码，也不会突然意外地开始出现Symbol。同样地，如下所示，Symbol属性也不会出现在对象的JSON字符串化的结果中。 [P68 代码2] 虽然如此，Symbol并不是隐藏属性的一种安全机制。尽管在使用反射和序列化方法时不会出现Symbol属性，但Symbol可以通过专有的方法获取到，如下述代码片段所示。换句话说，Symbol虽然是不可枚举的，但是隐藏在了醒目的地方。通过Object.getOwnPropertySymbols可以获取给定对象的所有Symbol key。 [P68 代码3] 现在我们知道了Symbol的原理了，那么我们该如何使用它呢？ 3.2.2 Symbol的实际用法Symbol可以在某些库中用来将对象映射到DOM元素。如一个需要关联日历的API对象到DOM元素的库。ES6之前，并没有很好的方式来将DOM元素映射到对象。我们需要在DOM元素上添加一个属性指向API，但是这么做污染了DOM元素的常规属性，并不是一种好的方式。我们需要及其小心，避免所使用的属性值也被其他库所使用，甚至于更糟，所用属性在将来被语言本身所使用。？？？？并且这样需要使用一个数组查找表，其中包含每个DOM/API对条目。？？？？然而在持续长时间运行的应用中，数组查询表会变得越来越大，查询的速度也会越来越慢。 而Symbol就不会存在这个问题。使用Symbol作为属性不用担心与将来的语言特性冲突，因为Symbol值是唯一的。下述代码展示了如何使用Symbol将DOM元素映射到日历API对象中。 [P69 代码1] ES6中内置的WeekMap可以将对象映射到其他对象，且不需要借助数组或者在所有对应对象上添加额外的属性。和数组查询表不同，WeakMap查询的时间复杂度是常量O(1)。我们将在第五章学习WeakMap以及其他一系列ES6内置对象。 使用Symbol定义协议前面我们说过Symbol可以用来定义协议。协议是一种定义行为的通信契约或约定。更具体点来说，库中可以使用Symbol，从而遵循库约定的对象也能够使用这个Symbol。 思考如下代码，我们使用toJSON方法来决定对象通过JSON.stringify序列化后的结果。从结果能够看出，character对象字符串化的结果是toJSON方法返回的对象序列化后的结果。 [P69 代码2，P70 代码1] 相反，如下所示，如果toJSON不是一个函数，那么原始的character对象会被序列化，包括toJSON属性。之所以会存在这样的不一致性，是因为依赖常规属性来定义行为。 [P70 代码2] 如果使用Symbol来实现toJSON则会更好，因为这样就不会和其他对象key值产生冲突。由于Symbol是唯一的，不会被序列化，且除了显示调用Object.getOwnPropertySymbols不会暴露，那么在定义JSON.stringify和对象如何初始化之间的约定时，使用Symbol不失为一种更好的选择。下述代码即为一种可选方案，使用Symbol来定义stringify函数的序列化行为。 [P70 代码3] 使用Symbol值来定义json行为，需要在对象字面量中使用可计算属性名。这样还能保证该行为不会和其他用户定义的属性冲突，或者在无法预见的将来与语言特性冲突。此外，Symbol值json必须在stringify函数中能够被访问，这样才能自定义行为。如下所示，通过这行代码能够很容易地将Symbol值json暴露给stringify函数，也将stringify与改变其行为的Symbol值联系在了一起。 [P71 代码1] 这样暴露了stringify函数后，也就暴露了Symbol值stringify.as，这样用户只需要简单修改对象，使用自定义的Symbol，来微调stringify行为。 ？？？？与给stringify函数中传入可选参数截然不同，使用Symbol定义行为有以下几个优点。首先，给函数添加可选参数会影响其公共API，而修改函数的内部实现，从而支持Symbol，并不会影响公共API。如果每个options对象都有不同的属性会降低这一影响，但是每调用一次函数就要传入一个options对象，并不方便。 另一个使用Symbol定义行为的好处是：我们无需更改除Symbol属性值值以外的任何东西，也无需更改实现该行为的内部代码实现机制，就能够对对象行为进行修改和自定义。并且使用Symbol作为属性不必担心与语言的新特性冲突。 除了本地Symbol，还有一些全局注册的Symbol值，这些值在整个代码域内都能访问到。让我们一起看下具体有哪些吧。 3.2.3 全局注册的Symbol值代码域是指JavaScript的执行上下文，如应用所在页面、页面中的&lt;iframe&gt;、通过eval执行的脚本以及各类worker–如web workder, service worker和shared worker[注释 1]。这些执行上下文都有自己所独有的全局对象。如，定义在页面中全局对象window上的全局变量，在ServiceWorker中时不可用的。相反地，全局注册的Symbol在所有这些代码作用域中时共享的。 有以下两种方法来获取运行环境下全局注册的Symbol：Symbol.for和Symbol.keyFor 使用Symbol.for(key)获取Symbol.for(key)可以用来查找运行环境下全局注册的Symbol key值。如果全局注册下存在所传入key的Symbol，则返回该Symbol。如果不存在，则用传入的key新建一个，并在在全局注册。也就是说Symbol.for(key)是幂等的：使用给定的key查找Symbol，如果没有则创建一个并返回。 以下代码中，第一个Symbol.for调用创建了一个标识为&#39;example&#39;的Symbol，并将其加入到了全局注册中，然后返回。第二个调用返回了同一个Symbol值，因为该key值已经在注册表中了，值为第一个调用所返回的Symbol值。 [P72 代码1] 全局注册的Symbol会通过key保持对Symbol值的引用。需要注意的是，当创建全局注册的Symbol时，所传入的key也会被用作description。试想一下，这些Symbol是全局可用的，如果我们想要减少潜在的命名冲突，就需要给Symbol的Key添加前缀，从而用于标识库和组件。 使用Symbol.keyFor(symbol)获取Symbol KeySymbol.keyFor(symbol)能够返回一个Symbol类型值symbol在添加到全局注册时所关联的key。下例展示了这一用法： [P72 代码2] 注意，如果symbol值没有全局注册，则该方法返回undefined。 [P72 代码3] 还需要记住一点，使用本地Symbol，即使描述相同，也不会匹配全局注册中的Symbol值。是因为本地Symbol值并不是全局注册的一部分，参考以下代码: [P73 代码1] 到目前为止，已经学习了处理全局注册相关的API，现在我们来看一下一些注意事项吧。 最佳实践与最佳实践全局注册意味着Symbol值在整个作用域内都可以访问到。全局注册在任何代码作用域内返回的都是同一个对象的引用。如下例，Symbol.for API在页面和&lt;iframe&gt;中返回的是同一个Symbol值。 [P73 代码2] 使用全局可用的Symbol需要做好权衡。一方面，全局Symbol使得类库能够方便地暴露其中的Symbol值，另一方面类库也可能会使用本地Symbol在其API上暴露Symbol值。显然，如果Symbol需要在任意两个不同的代码作用域中共享，如ServiceWorker和Web页面，这时Symbol注册很有用。同时，使用全局注册API，我们可以不必存储Symbol值的引用，因为同一个给定的key值会返回相同的Symbol值。需要注意的是，这些Symbol值在整个运行环境均可用，如果类似each或contains的自定义Symbol名，可以会导致意想不到的后果。 此外，还有另外一种Symbol值：内置 well-known Symbol值。 3.2.4 Well-Known Symbol前面我们已经学习了如何用Symbol函数和Symbol.for创建Symbol。接下来我们学习第三种也是最后一种Symbol：well-known Symbol。这些Symbol值是语言自带的，而不是由开发者自己创建，它们提供了内部语言行为的钩子，允许我们扩展或定制语言的某些在ES6之前无法操作的内部逻辑。 Well-known symbol能够在不破坏现有代码的情况下，对语言进行扩展的。Symbol.toPrimitive是一个很好的例子，它能够赋值一个函数，使用该函数决定对象如何转换成原始值。函数接受一个hint参数，指定所有转换的初始类型，值可以为&#39;string&#39;、&#39;number&#39;或者&#39;default&#39;。 [P74 代码1] 还有一个例子是Symbol.match。如果将一个正则表达式的Symbol.match属性设为false，则当该正则传入.startsWith、.endsWith或者.includes时，会被当做字符串字面量。上述三个方法是ES6中新增的字符串方法。首先，.startsWith用与判断字符串是否以另一个字符串开头。其次，.endsWith表明字符串是否以另一个字符串结尾。最后，如果字符串包含另一个字符串，.includes方法返回true。如下代码，展示了如何使用Symbol.match比较字符串和正则正则表达式的字符串表示。 [P75 代码1] 如果正则表达式没有通过symbol修改，则.startsWith会抛出异常，因为该方法期望接受一个字符串参数，而不是正则表达式。 跨作用域但不是全局注册Well-know Symbol 在作用域共享。如下，当前窗口中的Symbol.iterator和&lt;iframe&gt;窗口中的引用相同。 [P75 代码2] 但需要注意的是，虽然well-known Symbol在代码作用域内共享，但它们并没有在全局注册。如下，当我们使用Symbol.iterator作为key在注册表中查询时，得到的值为undefined。这表明该Symbol值并不在全局注册中。 [P75 代码3] Symbol.iterator是well-known Symbol中最有用的之一，通过在任意对象上使用该Symbol定义一个函数，可以在不同的语言结构上使用，用来迭代序列。我们将在下一章深入学习Symbol.iterator，与迭代和迭代协议一起广泛使用它。 3.3 对象的内置改进在第二章中，我们已经学习了对象字面量的语法增强部分，还有一些内置的Object静态方法没有提到。现在让我们来学一下这些方法。 除了我们上面提到的Object.getOwnPropertySymbols，还有Object.assign、Object.is和Object.setPrototypeOf。 3.3.1 使用Object.assign扩展对象给一个配置对象设置默认值时再常见不过的事情了。通常，库和设计良好的组件接口都有合理的缺省值，从而满足最频繁的使用场景。 如一个MarkDown的类库，将MarkDown转为HTML只需要提供一个input参数。单纯地解析MarkDown是最常用的使用场景，所以类库不要求使用者提供其他任何选项。不过，类库可以支持一些不同的选项，用于调整解析行为。如允许&lt;script&gt;或&lt;iframe&gt;标签的选项，在代码块中高亮CSS关键字的选项。 试想一下，我们需要提供如下这些默认值。 [P76 代码1] 一种方式是通过解构，将defaults对象设为options参数的默认值。这种情况下，当用户想要设置某一个选项时，必须提供每一个选项。 [P76 代码2] 所以默认值必须以某种方式和用户提供的配置进行合并。如下例所示，Object.assign能够进行这一合并操作。第一个参数为一个空对象{}，第二个参数default会被复制到这个空对象中，然后再复制options，最终返回改变后的空对象。这样config对象中就存在所有默认值以及用户提供的配置了。 [P77 代码1] 理解Object.assign的目的Object.assign方式会改变它的第一个参数。参数格式是(target, ...sources)。每个源对象都会应用到目标对象上，每个源对象依次应用，源对象中的属性依次应用。 考虑一下如下场景，如果不想Object.assign中传递一个空对象最为第一个参数，而是直接传入defaults和options。这样将会改变defaults对象的内容，由于Object.assign会改变第一个对象，这一过程会导致defaults中的部分默认值丢失，并额外增加一些错误的默认值。如下，函数md首次调用得到的结果和上例中的结果相同，但在这一过程中它会改变defaults，从而会影响后续的调用。 [P77 代码2] 鉴于此，最好每次调用Object.assign时都传入一个全新的对象作为第一个参数。 对于任意有默认值的属性，如果用户提供了新的值，则以用户提供的为准。Object.assign的工作原理如下。首先，获取传入的第一个参数，我们可以称其为target；然后，获取其他参数，可以称其为sources，遍历sources的所有key。对于sources中的每一个源对象，其中所有的属性值都会被遍历，然后赋值给target对象。最后，最后一个参数，在下例中是options对象，会重写之前已赋值的值。代码如下所示： [P77 代码3 - P78 代码1] 在Object.assgin添加进语言之前，这一个功能在民间JavaScript中有很多相似的实现方式，名字诸如assgin或extend等。Object.assign方法统一了这些可选方案。 需要注意的是，Object.assign只会遍历自身可枚举属性，包括字符串和symbol属性。 [P78 代码2] 然而Object.assign并不能满足每种需求。很多民间实现方法能够支持深度赋值，但是Object.assign并不会递归对象。值为对象的属性会被直接赋给target，而不是递归赋值对象中的每一个属性。 如下例所示，你可以期望f属性会被添加到target.a上，同时a.c和a.d原封不动，但是Object.assign后，a.c和a.d会丢失掉。 [P78 代码3] 同样地，数组也不会被特别对待，也不会递归遍历复制。如下例所示，如果你期待Object.assign能够进行递归，那么结果就会出乎你的意料了，你所期待的d并不会出现在结果数组的第三个位置上。 [P78 代码4] 在书写本书时，有一个处于第三阶段的ECMAScript提案[注释 2]，该提案实现了在对象中进行展开，与在数组中展开可遍历对象相似。在一个对象中展开另一个对象与Object.assign函数调用效果等价。 如下代码展示了一些在对象中展开另一对象与Object.assign对比的使用情况。可以看出，使用对象展开更加简洁，在情况允许时，可以优先选择该方式。 [P79 代码1] 与对象扩展对应，还有一个包含对象rest属性的提案，与对象中的rest模式相似。我们可以在对象解构中使用对象rest。 如下例，使用对象rest能得到一个对象，对象中包含所有在参数列表中没有显示指明名称的属性。注意，与数组rest模式相同，对象rest只能在解构的最后一个位置。 [P79 代码2] 在变量声明语句中解构对象时，也可以使用相似的方式。下例中，每个在结构中没有显示解构的属性都会被放到meta对象中。 [P79 代码3 P80 代码1] 我们将在第九章深入学习对象的rest与展开。 3.3.2 使用Object.is进行对象比较Object.is方法与严格相等比较运算符===有些不同。大部分情况下，Object.is(a, b)与a === b是等价的。但是有两种情况会不同：即NaN、-0和+0。该算法在ECMAScript规范中被称为SameValue。 当NaN和NaN比较时，严格相等运算符返回false，因为NaN不等于它自身。然而，Object.is方法则返回true。 [P80 代码2] 相似地，当-0与+0进行比较式，===运算符得到的结果是true，而Object.is返回false。 [P80 代码3] 这些差别看起来不大，但是当需要处理NaN时，总是很麻烦。因为NaN有一些独特的行为，如typeof NaN的结果是&#39;number&#39;，自身不等于自身。 3.3.3 Object.setPrototypeOf字如其意，Object.setPrototypeOf的功能就是名字所表达的意思：用于设置一个对象的原型引用到另一个对象。相比于使用遗留的特性__proto来设置原型，更推荐使用Object.setPrototypeOf。 在ES6之前，ES5引入了Object.create。如下所示，使用该方法能够创建一个新的对象，新对象以传入的原型参数为原型。 [P81 代码1] 不过，Object.create只适用于创建新的对象。而使用Object.setPrototypeOf可以改改变已有对象的原型。如下所示： [P81 代码2] 但是需要注意，相比于Object.create，使用Object.setPrototypeOf有很多性能问题，所以当决定在整个代码库中使用Object.setPrototypeOf 性能问题 使用Object.setPrototypeOf修改对象的原型是一个很耗费性能的操作。之前需要仔细考虑之后再做决定。以下是Mozilla开发者网络文档中对此事的看法: 由于现代JavaScript引擎优化属性访问的特性，在任何浏览器和JavaScript引擎中，修改对象的原型都是一个很慢的操作。对于改变继承的影响是很微妙与深远的，不仅仅是obj.__proto = ...这一语句的时间消耗，还会影响访问原型被改变的对象的所有代码。如果你比较在意性能，那你最好避免给对象设置原型。相反，可以使用Object.create创建一个基于期望原型的新对象。 – Mozilla开发者网络 3.4 装饰器和大多数编程语言一样，装饰器绝对不是一个新的概念。在现代编程语言中，这种模式相当普遍：C#中有attributes，Java中叫annotations，Python中时decorators，其他语言也都存在这一模式。在TC39工作中，有一个关于装饰器的提案[注释 3]，现在处于第二阶段。 3.4.1 初识JavaScript装饰器JavaScript装饰器语法与Python中的装饰器很相似。JavaScript装饰器可以用于类以及任何静态定义的属性，如果对象字面量声明或类声明中的属性，哪怕它们是get/set存取器或者static属性也没问题。 该提案通过@定义decorator装饰器，后跟一些列点连接的标识符和一个可选参数列表。下面是一些语法示例： @decorators.frozen是一个合法装饰器 @decorators.frozen(true)是一个合法装饰器 @decorators().frozen()存在语法错误 @decorators[&#39;frozen&#39;]存在语法错误 类声明和类成员可以添加0到多个装饰器。 [P82 代码1] 装饰器是通过函数实现的。成员装饰器函数具有成员描述符并返回成员描述符。成员描述符与属性描述符相似，但是形态不同。如下代码，即为装饰器提案中所定义的成员描述符接口。可选参数finisher方法接受一个类构造函数，允许我们执行与属性被修饰的类相关的操作。 [P83 代码1] 如下例，我们定义了一个readonly成员装饰器函数，用来将被装饰的成员状态变成不可写。借助对象rest与对象扩展操作，我们将属性描述符修改成不可变状态，而其余成员描述符保持不变。 [P83 代码2] 类装饰器函数接受如下三个参数：ctor参数，该参数指向被装饰的类构造函数；heritage参数，如果被修饰的类继承了其他类，则包含该父类；merbers数组，修饰类的成员装饰器列表。 如下代码所示，通过在被装饰类的每一个成员描述符上复用上述readonly成员装饰器，可以实现一个类级别的装饰器readonlyMembers。 [P83 代码3] 3.4.2 堆叠装饰器及不变性警告在不变性的问题上，我们可能会试图从装饰器中返回一个新的属性描述符，而不修改原始描述符。虽然出发点是好的，但可能会产生意想不到的效果，因为同一个类或类成员可以装饰多次。 如果代码中的每个装饰器都没有考虑所接受的descriptor参数，直接返回一个全新的descriptor，那么，事实上，它们将失去新描述符返回之前的所有修饰。 我们应该仔细重视所提供的descriptor。创建返回一个基于所给descriptor原始参数的descriptor。 3.4.3 使用实例：C#中的Attributes很久以前，我第一次接触C#是在Ultima Online服务器仿真器[注释 5]中，是使用开源C#代码——RunUO编写的。RunUO是我曾经使用过的最好的代码库，它使用C#实现的。 它们将服务器软件分发为可执行文件和一系列的.cs文件。这些runuo可执行文件会在运行时编译，并动态混合到应用程序中。这样我们就不再需要Visual Studio IDE(也不需要msbuild)，也不需要任何编程知识来编辑这些.cs文件中的“脚本”。以上这些使得RunUO为新手开发者提供了一个完美的学习环境。 RunUO高度依赖于反射。RunUO的开发者为了使用户能实现定制，投入了很大的精力。这些用户不需要研究编程，只对改变游戏中的一些谢姐感兴趣，如，龙的火焰能够造成多大的伤害以及它喷射火球的频率。良好的开发者体验是RunUO设计哲学中很重要的一部分。通过复制一个怪物文件，使其继承Dragon类，重写几个属性来改变它的色调、伤害输出等，就可以创建一个新种类的龙。 与能够便捷创建新的怪物一样，非玩家角色（游戏中俚语是NPC），他们也依赖反射为游戏管理员提供功能。管理员可以在游戏内运行命令，点击一个物品或怪物来查看或改变属性，而不需要离开游戏。 [P85 图1 从Ultima Online客户端在游戏内改变RunUO的属性] 不过，并不是类中的每一个属性都可以在游戏内进行操作。有些属性仅限于内部使用，或者不支持在运行时编辑。RunUO有一个CommandPropertyAttribute装饰器[注释 6]，用于定义属性是否可以在游戏内编辑，同时要求制定读操作与写操作所需的访问级别。这一装饰器在RunUO的代码库中得到了广泛的使用[注释 7]。 PlayerMobile类用来控制玩家角色如何工作，非常适合查看这些属性。PlayerMobile有很多属性在游戏内对于管理员和审核人都是可访问的[注释 8]。下面是一些getter和setter属性，但只有第一个具有CommandProperty属性，这就使得该属性在游戏中对游戏主是可访问的。 [P86 代码1] c#属性和JavaScript之间一个有趣的区别是，c#中的反射允许我们使用MemberInfo#getCustomAttributes从对象中提取所有自定义属性。在显示允许管理员查看或修改游戏对象的属性的对话框时，RunUO就是利用该方法提取关于游戏中应该可以访问的每个属性的信息。 3.4.4 在JavaScript中标记属性在JavaScript中，没有从属性上获取自定义特性的方法，至少在现有的提案草案中没有。也就是说，JavaScript是一种高度动态的语言，创建这种“标签”并不麻烦。用“command property”来装饰Dog并不会和RunUO与c#有什么不同。由于JavaScript装饰器没有反射[注释 9]，我们需要用一个运行时Symbol值来保存给定类的命令属性数组。 [P86 代码2] 与C#相比，commandProperty函数需要稍微复杂一点。 [P87 代码1] Dog类中可以存在任意多必要的命令属性，并且每个命令属性都会列举在一个Symbol属性中。想要查找给定类的命令属性，通过以下函数即可获取。该函数通过Symbol属性获取命令属性列表，并提供了默认值[]。该函数会返回原始列表的副本，以防止用户意外地对其进行更改。 [P87 代码2] 这样我们就可以遍历已知的安全命令属性，并在运行时，通过一个简单的UI呈现一种修改这些属性的方法。装饰器是实现将属性标记为特定用例的特殊属性这一协议最干净的一种方式，它偶尔依赖于某种启发式来进行中断或者使用某种限制性的命名约定，而不用保存能够被修改的属性长列表。 在下一章中，我们将介绍ES6中的更多特性，如何使用Promise和生成器进行流程控制，以及如何迭代JavaScript对象。 注1 Worker是在浏览器中执行后台任务的一种方式。启动程序通过message，即使在不同的执行上下文，也能够所和初始化的worker进行通信。 注2 从GitHub（https://github.com/tc39/proposal-promise-finally）中能够查看该草案。 注3 从GitHUb（https://mjavascript.com/out/decorators）中能够查看该草案。 注4 通过[]访问属性是不允许的，因为这样编译器会难以消除语法歧义。 注5 Ultima Online是一款几十年前的基于终极宇宙的虚拟角色扮演类游戏。 注6 RunUO的git仓库（https://mjavascript.com/out/runuo-attributes）中有`CommandPropertyAttribute`的定义。 注7 CommandPropertyAttribute在整个代码库中广泛使用，仅在RunUO核心中就标记了200多个属性。 注8 在PlayerMobile.cs类（https://mjavascript.com/out/runuo-playermobile）中找到许多`CommandProperty`属性的用法示例。 注9 现代JavaScript还没有考虑实现JavaScript装饰器的反射功能，因为这样需要引擎在内存中存储更多的元数据。不过，我们可以使用Symbol和列表来完成使用原生反射的需求。","categories":[],"tags":[]},{"title":"如何清除行内元素之间的HTML空白","slug":"如何清除行内元素之间的HTML空白","date":"2018-05-23T10:00:48.000Z","updated":"2018-05-24T08:53:28.797Z","comments":true,"path":"2018/05/23/如何清除行内元素之间的HTML空白/","link":"","permalink":"http://verymuch.com/2018/05/23/如何清除行内元素之间的HTML空白/","excerpt":".Resolve { width: 90%; border: 1px solid #dd4b39; color: white; } .Resolve span { display:inline-block; width: 50%; } .Resolve span:first-child { height: 40px; background: #37b8ea; } .Resolve span:last-child { height: 30px; background: #5cb767; } /* 解决方案2 */ .Resolve2 { font-size: 0; } .Resolve2 span { font-size: 14px; } /* 解决方案3 */ .Resolve3 span:last-child { margin-left: -0.333333em; } /* 解决方案4 */ .Resolve4 { letter-spacing: -0.333333em; } .Resolve4 span { letter-spacing: 0; } 前言相信大家应该都遇到过下面这个问题：“HTML源码中行内元素之间的空白显示在了屏幕上”。可能大家都有自己的小技巧来消除这些意料之外的空白。但是方法有很多，有时候不能满足于一种解法，毕竟不同的方法是有优劣的。就像我之前一直用的方法，今天总结了之后才发现还有更好的方法。废话不多说，接下来我给大家总结一下消除行内元素HTML源码空白的小技巧。 下文中以一个div中的两个span标签为例。我们将两个div内的两个span设为display:inline-block;width:50%;，会发现两个span元素并没有在同一行，这就是源码中的空白导致的。 示例代码如下： 左侧行内元素 右侧行内元素","text":".Resolve { width: 90%; border: 1px solid #dd4b39; color: white; } .Resolve span { display:inline-block; width: 50%; } .Resolve span:first-child { height: 40px; background: #37b8ea; } .Resolve span:last-child { height: 30px; background: #5cb767; } /* 解决方案2 */ .Resolve2 { font-size: 0; } .Resolve2 span { font-size: 14px; } /* 解决方案3 */ .Resolve3 span:last-child { margin-left: -0.333333em; } /* 解决方案4 */ .Resolve4 { letter-spacing: -0.333333em; } .Resolve4 span { letter-spacing: 0; } 前言相信大家应该都遇到过下面这个问题：“HTML源码中行内元素之间的空白显示在了屏幕上”。可能大家都有自己的小技巧来消除这些意料之外的空白。但是方法有很多，有时候不能满足于一种解法，毕竟不同的方法是有优劣的。就像我之前一直用的方法，今天总结了之后才发现还有更好的方法。废话不多说，接下来我给大家总结一下消除行内元素HTML源码空白的小技巧。 下文中以一个div中的两个span标签为例。我们将两个div内的两个span设为display:inline-block;width:50%;，会发现两个span元素并没有在同一行，这就是源码中的空白导致的。 示例代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 1234567891011121314151617.Resolve &#123; width: 90%; border: 1px solid #dd4b39; color: white;&#125;.Resolve span &#123; display:inline-block; width: 50%;&#125;.Resolve span:first-child &#123; height: 40px; background: #37b8ea;&#125;.Resolve span:last-child &#123; height: 30px; background: #5cb767;&#125; 解决方案1：源码中直接就写成一行相信大家看到这个解决方案的时候，会想这不是废话嘛。有时候我们就是为了代码的美观，才将两个span标签分两行显示的，写在一行根本就没解决问题好不好？ 不过，我觉得这并不是废话，之所以将其列为一种解决方案，是防止有的人不知道是什么原因导致的空白的显示。知道了这个原因，如果两个行内元素的横向宽度(此处指代码宽度)不大，写在一行也算是最快最直接的解决方法。 示例代码如下： 左侧行内元素右侧行内元素 HTML： 123&lt;div class=\"Resolve Resolve1\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt;&lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; 解决方案2：font-size: 0; （笔者一直使用的方法）问题中span标签之间的空白是因为换行符/Tab制表符/空格等产生的间隔，并且据笔者测试，得出这个距离是字体大小的1/3倍（请先记住这个值）。那么既然空格和字体大小font-size相关。那么也可以通过字体大小来消除这个空隙。 在父级元素上设置font-size: 0;，然后再在内部的span设置需要的字体大小即可。 示例代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve2\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 123456.Resolve2 &#123; font-size: 0;&#125;.Resolve2 span &#123; font-size: 14px;&#125; 这种情况在内部的行内元素字体大小比较统一时，处理起来较为方便，但如果包含的行内元素中存在多种字体大小，需要一一指定，较为繁琐。不过往往这种时候内部的多种字体大小也是单独指定。可以根据具体场景决定是否使用该方案。 解决方案3：margin-left设为负值如果行内元素为块级行内元素，则可以使用margin属性来抵消空白。在【解决方案2】中有提到行内元素之间的距离是字体大小的1/3倍。所以我们只需要将第二个span元素的margin-left设置为-0.333333em即可。 示例代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve3\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 123.Resolve3 span:last-child &#123; margin-left: -0.333333em;&#125; 不过从上面可以看出，最右边还会存在一点点的白边误差。这是由于margin-left的计算精度导致的。 解决方案4：letter-spacing消除文字间距离同方案2、方案3，我们还可以通过letter-spacing改变行内元素之间空隙的大小，将letter-spacing设为-0.333333em即可。但是与font-size一样，改变letter-spacing时会改变内部子元素的间隙，需要手动矫正。 示例代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve4\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 123456.Resolve4 &#123; letter-spacing: -0.333333em;&#125;.Resolve4 span &#123; letter-spacing: 0;&#125; 解决方案5：HTML注释（推荐使用）除了调整css样式之外，我们可以使用html注释来抵消空格，这种情况下不用额外进行css处理。此外笔者觉得还有一个好处，可以加上文字注释，告知为什么会加入注释。 推荐使用该方式，能够有效保持代码整齐，并且不用额外添加css样式。 示例代码如下： 左侧行内元素右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve5\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt;&lt;!-- 消除行内元素换行导致的空白--&gt;&lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; 总结以上就是解决行内元素间HTML空白的5种方案，虽然这些方案都不是很理想，但是有时候在特定的情况下，我们往往需要其中之一作为解决方案。","categories":[],"tags":[{"name":"CSS小技巧","slug":"CSS小技巧","permalink":"http://verymuch.com/tags/CSS小技巧/"}]},{"title":"如何建立数据库索引","slug":"如何建立数据库索引","date":"2018-05-15T10:14:58.000Z","updated":"2018-05-24T08:47:54.270Z","comments":true,"path":"2018/05/15/如何建立数据库索引/","link":"","permalink":"http://verymuch.com/2018/05/15/如何建立数据库索引/","excerpt":"1. 简介建立索引的目标是为了使数据库应用程序可以更快地查找数据。 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。 创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。 虽然索引能够大大提升查询速录，但过多的使用索引将会造成滥用。因为索引也会有它的缺点：索引会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。","text":"1. 简介建立索引的目标是为了使数据库应用程序可以更快地查找数据。 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。 创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。 虽然索引能够大大提升查询速录，但过多的使用索引将会造成滥用。因为索引也会有它的缺点：索引会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。 2. 索引的种类 普通索引：最近本的索引，没有任何限制 唯一索引：索引列的值必须唯一，但允许空值。如果为组合索引，则列值的组合必须唯一 主键：主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL） 全文索引：用于在一篇文章中，检索文本信息的。全文索引可以在VARCHAR或者TEXT类型的列上创建。 3. 索引的创建 使用SQL CREATE INDEX语法可以创建索引。 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定length。其余类型不能指定length。 column_name规定需要索引的列，允许使用重复的值 注意：同一组字段的唯一索引，包括同一组字段普通索引的功能，无需重复创建。 1234567891011// 普通索引 - 单列索引CREATE INDEX index_name ON table_name (column_name(length))// 普通索引 - 组合索引CREATE INDEX index_name ON table_name (column_name1(length),column_name1(length))// 唯一索引 - 单列索引CREATE UNIQUE INDEX indexName ON mytable(column_name(length)) // 唯一索引 - 单列索引CREATE UNIQUE INDEX index_name ON table_name (column_name1(length),column_name1(length)) 使用修改表结构ALTER语句添加索引 1234567891011121314151617// 普通索引 - 单列索引ALTER TABLE table_name ADD INDEX index_name(column_name)// 普通索引 - 组合索引ALTER TABLE table_name ADD INDEX index_name(column_name1,column_name2)// 唯一索引 - 单列索引ALTER TABLE table_name ADD UNIQUE index_name(column_name)// 唯一索引 - 组合索引ALTER TABLE table_name ADD UNIQUE index_name(column_name1,column_name2)// 主键ALTER TABLE table_name ADD PRIMARY KEY (column_name)// 全文索引ALTER TABLE table_name ADD FULLTEXT index_name(column_list) 创建表的时候直接指定 12345678910111213// 普通索引 - 单列/组合索引CREATE TABLE table_name( ID INT NOT NULL, ... INDEX index_name (index_name(length),...) );// 唯一索引 - 单列/组合索引CREATE TABLE table_name( ID INT NOT NULL, ... UNIQUE index_name (index_name(length),...) ); 4. 索引的删除 DROP语句可以用于删除普通索引和唯一索引 1DROP INDEX index_name ON table_name; ALTER 语句删除 1234ALTER TABLE table_name DROP INDEX index_name;// 删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。ALTER TABLE table_name DROP PRIMARY KEY; 5. 显示索引信息1SHOW INDEX FROM table_name; 6. 查看查询语句使用的INDEX在SELECT语句之前加上DESC能够显示查询语句最终使用的索引。 1DESC SELECT ... 参考链接 MySQL 索引 MySQL索引原理及慢查询优化 MySQL索引背后的数据结构及算法原理","categories":[],"tags":[]},{"title":"机器学习资料","slug":"机器学习资料","date":"2018-05-11T07:42:04.000Z","updated":"2018-05-24T08:56:33.697Z","comments":true,"path":"2018/05/11/机器学习资料/","link":"","permalink":"http://verymuch.com/2018/05/11/机器学习资料/","excerpt":"","text":"收藏了一些机器学习相关资料，分享一下。自己也只看过很小一部分，仍在学习中…. Google最近出的机器学习速成课程 https://developers.google.cn/machine-learning/crash-course/ml-intro 斯坦福大学公开课 ：机器学习课程 Andrew Ng吴恩达 http://open.163.com/special/opencourse/machinelearning.html 我爱机器学习博客 https://www.52ml.net/ 晓雷机器学习笔记 https://zhuanlan.zhihu.com/xiaoleimlnote lilicao博客 http://www.cnblogs.com/lillylin/ 猫狗大战知乎专栏 https://zhuanlan.zhihu.com/alpha-smart-dog 计算机视觉，机器学习相关领域源代码大集合 https://zhuanlan.zhihu.com/p/26691794 物体检测大集合 https://handong1587.github.io/deep_learning/2015/10/09/object-detection.html#r-cnn 机器学习笔记 https://feisky.xyz/machine-learning/","categories":[],"tags":[]},{"title":"npm unmet dependency 解决方案","slug":"npm-unmet-dependency-解决方案","date":"2018-05-11T03:49:44.000Z","updated":"2018-05-11T06:12:47.552Z","comments":true,"path":"2018/05/11/npm-unmet-dependency-解决方案/","link":"","permalink":"http://verymuch.com/2018/05/11/npm-unmet-dependency-解决方案/","excerpt":"","text":"1. 引言之前使用框架，一直需要编译后发布，代码库中因此就有了一大堆编译后的文件，每次更新服务端的代码都会导致眼花缭乱。最近就升级了下服务器上的node版本，然后在服务端进行编译，这样就不用维护编译后的代码了。 然鹅，好事多磨，升级好，新上线的代码中包含的新依赖，总是无法成功。通过npm ls package_name查看看到了UNMET DEPENDENCY错误。 2. 解决方案 清缓存(该方式验证有效) 123rm -rf node_modules/ # 删除已安装的模块npm cache clean --force # 清除 npm 内部缓存npm install # 重新安装 升级npm版本 123rm -rf node_modules/ # 删除已安装的模块sudo npm update -g npm # 更新 npmnpm install # 重新安装 参考链接 why-does-npm-install-say-i-have-unmet-dependencies npm 安装出现 UNMET DEPENDENCY 的解决方案","categories":[],"tags":[{"name":"沉淀","slug":"沉淀","permalink":"http://verymuch.com/tags/沉淀/"}]},{"title":"如何在Array.forEach中实现break","slug":"如何在Array-forEach中实现break","date":"2018-02-09T01:39:23.000Z","updated":"2018-05-24T09:14:40.489Z","comments":true,"path":"2018/02/09/如何在Array-forEach中实现break/","link":"","permalink":"http://verymuch.com/2018/02/09/如何在Array-forEach中实现break/","excerpt":"使用for in遍历对象时，会遍历原型链上的可枚举实行，而这些往往会导致一些意想不到的问题。 鉴于上面这个原因，我们团队在之前的几个项目里，通过eslint禁止在代码中使用for in。虽然在大部分情况，我们都能按照约定不使用for in，但是偶尔仍会需要在forEach中中断循环的情况。 有需求就有解决方案。 遇到这个问题时，笔者最简单的思路就是，在forEach外层设置标志位为false，然后在需要break时，将标志位置为true，循环内判断true则直接返回。这样做虽然能够减少循环内部的逻辑处理，但是还是会空跑整个循环，造成资源浪费。 既然自己想的方法是最简单的，并且存在弊端，那么就搜搜其他大神的有哪些思路吧。于是乎就有了以下的总结：","text":"使用for in遍历对象时，会遍历原型链上的可枚举实行，而这些往往会导致一些意想不到的问题。 鉴于上面这个原因，我们团队在之前的几个项目里，通过eslint禁止在代码中使用for in。虽然在大部分情况，我们都能按照约定不使用for in，但是偶尔仍会需要在forEach中中断循环的情况。 有需求就有解决方案。 遇到这个问题时，笔者最简单的思路就是，在forEach外层设置标志位为false，然后在需要break时，将标志位置为true，循环内判断true则直接返回。这样做虽然能够减少循环内部的逻辑处理，但是还是会空跑整个循环，造成资源浪费。 既然自己想的方法是最简单的，并且存在弊端，那么就搜搜其他大神的有哪些思路吧。于是乎就有了以下的总结： 当需要在for in中使用break时，可以采用以下几种方案： 1. throw法抛出一个错误，但是需要注意的是要抛出一个可以与别的错误区别开的错误，这样不会干扰别的代码抛出的错误 12345678910var BreakException = &#123;&#125;;try &#123; [1, 2, 3].forEach(function(v) &#123; console.log(v); //只输出1,2 if (v === 2) throw BreakException; &#125;);&#125; catch (e) &#123; if (e !== BreakException) throw e;&#125; 此法有点丑陋，加了不少代码 2. 空跑循环在外层加一个标识，如果此标识为true，接下来的循环空跑，如下： （空跑循环，也就是笔者自己想到的思路，不过笔者还是Low一点的。） 12345678910111213var breakFlag = false;[1, 2, 3].forEach(function(v) &#123; if (breakFlag === true) &#123; return false; &#125; if (v === 2) &#123; breakFlag = true &#125; console.log(v) //只输出1,2&#125;) 这个方法在外层加了一个变量，为了不污染外层的环境，我们可以使用forEach的第二个参数context，把标识放在这里（高就高在了这里）。 12345678910[1, 2, 3].forEach(function(v) &#123; if (this.breakFlag === true) &#123; return false; &#125; if (v === 2) &#123; this.breakFlag = true &#125; console.log(v) //只输出1,2&#125;, &#123;&#125;); 注意，forEach的第二个参数context，只有在使用非箭头函数时有效，如果是箭头函数，无法改变context的指向。 1234567891011[1, 2, 3].forEach((v) =&gt; &#123; if (this.breakFlag === true) &#123; return false; &#125; if (v === 2) &#123; console.log(this) // 运行会发现，结果并不是&#123;test: 'test'&#125; this.breakFlag = true &#125; console.log(v) //只输出1,2&#125;, &#123;test: 'test'&#125;); 当然，上述这种方法不可避免的导致了不必要的运行,有点浪费cpu的感觉 3. 神奇改数组大法下面出场的这位选手，稍微有点技术含量，笔者还是问了大佬才知道的，一定是我太过愚钝了。 1234567var array = [1, 2, 3, 4, 5];array.forEach(function(item, index) &#123; if (item === 2) &#123; array = array.concat(array.splice(index, array.length - index)); &#125; console.log(item); //只输出1,2&#125;); 这种方法相当于在item === 2的时候，改变了原数组引用的值，但是将array指向了一个新的引用，值保持不变。 4. 最应该使用的every前面啰嗦了这么多，真正的主角登场，*最推荐的方式是在需要break的场景下，使用every或者some every: 碰到return false的时候，循环中止 some: 碰到return ture的时候，循环中止 两者的代码分别如下： 123456789var a = [1, 2, 3, 4, 5]a.every(function(item, index, arry) &#123; console.log(item); //返回1,2 if (item === 2) &#123; return false &#125; else &#123; return true &#125;&#125;) 123456789var a = [1, 2, 3, 4, 5]a.some(function(item, index, arry) &#123; console.log(item); //返回1,2 if (item === 2) &#123; return true &#125; else &#123; return false &#125;&#125;) 5. 参考内容 http://jser.me/2014/04/02/%E5%A6%82%E4%BD%95%E5%9C%A8Array.forEach%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%87%8Cbreak.html","categories":[],"tags":[{"name":"沉淀","slug":"沉淀","permalink":"http://verymuch.com/tags/沉淀/"}]},{"title":"Node路径解析浅析","slug":"Node路径解析浅析","date":"2018-01-10T09:08:05.000Z","updated":"2018-02-10T02:51:38.139Z","comments":true,"path":"2018/01/10/Node路径解析浅析/","link":"","permalink":"http://verymuch.com/2018/01/10/Node路径解析浅析/","excerpt":"1. 疑惑这两天看了下之前项目里的webpack配置，想将之前的alias命名统一起来，遂在alias命名前统一使用_开头，这样在项目中看到这样的引用一眼就能知道是通过别名查找的。如下图所示，css目录在fesrc目录下，webpack配置所在目录与fesrc平级，在配置中如果使用相对路径，应该使用_css: path.resolve(&#39;../fesrc/css&#39;)，但是试一下就会发现这么做webpack无法找到指定目录。相反如下图用法，使用_css: path.resolve(&#39;./fesrc/css&#39;)则能够找到。因此，我猜想可能是相对于运行该文件的目录，就了解并总结了一下相关的内容。","text":"1. 疑惑这两天看了下之前项目里的webpack配置，想将之前的alias命名统一起来，遂在alias命名前统一使用_开头，这样在项目中看到这样的引用一眼就能知道是通过别名查找的。如下图所示，css目录在fesrc目录下，webpack配置所在目录与fesrc平级，在配置中如果使用相对路径，应该使用_css: path.resolve(&#39;../fesrc/css&#39;)，但是试一下就会发现这么做webpack无法找到指定目录。相反如下图用法，使用_css: path.resolve(&#39;./fesrc/css&#39;)则能够找到。因此，我猜想可能是相对于运行该文件的目录，就了解并总结了一下相关的内容。 2. 五类路径__dirname、__filename、process.cwd()、./、../Node中的文件路径大概有__dirname、__filename、process.cwd()、./或者../五类，前三个都是绝对路径，为了便于比较，我们将通过path.resolve(&#39;./&#39;)将./和../转换为绝对路径。 先看一个简单的例子。 假设有以下文件结构： 12345test-path├── js│ └── test.js└── lib └── common.js 在test.js下编写一下代码： 123456var path = require('path');console.log(__dirname);console.log(__filename);console.log(process.cwd());console.log(path.resolve('./')); 在js目录下运行node test.js会输出以下内容： 1234/Users/verymuch/devspace/test-path/js/Users/verymuch/devspace/test-path/js/test.js/Users/verymuch/devspace/test-path/js/Users/verymuch/devspace/test-path/js 而在test-path目录下，执行node js/test.js会输出以下内容： 1234/Users/verymuch/devspace/test-path/js/Users/verymuch/devspace/test-path/js/test.js/Users/verymuch/devspace/test-path/Users/verymuch/devspace/test-path 由上述内容，我们可以先做出以下假设： __dirname: 总是返回被执行的js所在文件夹的绝对路径 __filename: 总是返回被执行的js的绝对路径 process.cwd(): 总是返回运行node命令时所在的文件夹的绝对路径 ./: 似乎与process.cwd()一样。 值得注意的是，在require(&#39;../lib/common&#39;)里使用相对路径似乎并没有问题，参考下例，将’js/test.js’ 里的代码改成： 123456789var fs = require('fs');var common = require('../lib/common');console.log('require is OK!');fs.readFile('../lib/common.js', function (err, data) &#123; if (err) return console.log(err); console.log(data.toString());&#125;); 在js目录下运行node test.js，会发现并没有问题。但是在test-path目录下运行node js/test.js，就会报错，运行结果如下： 123456require is OK!&#123; Error: ENOENT: no such file or directory, open '../lib/common.js' errno: -2, code: 'ENOENT', syscall: 'open', path: '../lib/common.js' &#125; 按照上面暂定的理论，在test-path下运行时，../lib/common.js会被转成/Users/verymuch/devspace/lib/common.js，显然，这个路径是不存在的，但是从运行结果可以看出require(&#39;../lib/common&#39;)并没有问题，只是readFile报错了。 因此关于./正确的结论是： 在require()中使用是跟__dirname的效果相同，相对于文件所在目录，不会因为启动脚本的目录不一样而改变 在其他情况下跟process.cwd()效果相同，相对于启动脚本所在目录。 3. 总结鉴于相对路径(./, ../)的特殊，建议只在require()中使用相对路径的写法，其他地方一律使用绝对路径，如下： 1234// 当前目录下path.resolve(__dirname, './lib/common.js');// 相邻目录下path.resolve(__dirname, '../lib/common.js'); 4. 参考链接 浅析 NodeJs 的几种文件路径","categories":[],"tags":[{"name":"沉淀","slug":"沉淀","permalink":"http://verymuch.com/tags/沉淀/"}]},{"title":"CSS Mixin","slug":"CSS-Mixin","date":"2018-01-03T07:43:49.000Z","updated":"2018-02-09T12:24:09.421Z","comments":true,"path":"2018/01/03/CSS-Mixin/","link":"","permalink":"http://verymuch.com/2018/01/03/CSS-Mixin/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第2章 ES6基础(总结与扩展)","slug":"第2章-ES6基础-总结与扩展","date":"2017-12-30T14:01:04.000Z","updated":"2018-02-09T12:24:14.000Z","comments":true,"path":"2017/12/30/第2章-ES6基础-总结与扩展/","link":"","permalink":"http://verymuch.com/2017/12/30/第2章-ES6基础-总结与扩展/","excerpt":"2.3 解构赋值解构赋值是ES6中最灵活最有表现力的特性之一。同时，它也最为简单。它可以将对象的属性值绑定到任意多的变量上。解构赋值可以用于对象、数组以及函数参数列表中。","text":"2.3 解构赋值解构赋值是ES6中最灵活最有表现力的特性之一。同时，它也最为简单。它可以将对象的属性值绑定到任意多的变量上。解构赋值可以用于对象、数组以及函数参数列表中。 2.3.1 对象的解构通过对象的解构赋值，能够更加语义化地抽取对象的属性声明为变量，避免重复输入属性名。如下将character.pseudonym赋值给pseudonym变量。 123456789101112131415var character = &#123; name: 'Bruce', pseudonym: 'Batman', metadata: &#123; age: 34, gender: 'male' &#125;, batarang: ['gas pellet', 'bat-mobile control', 'bat-cuffs']&#125;// ES5写法var pseudonym = character.pseudonym// ES6写法var &#123; pseudonym &#125; = character 通过var声明时，使用逗号隔开能一次声明多个变量。同样地，在解构赋值的花括号中也可以通过逗号分隔声明多个变量。 1var &#123; pseudonym, name &#125; = character 此外，我们可以在同一个var语句中同时使用常规的变量声明和解构赋值。 1var &#123; pseudonym &#125; = character, two = 2 如果想要提取pseudonym属性，并将其声明为alias变量，我们可以使用下面这种解构语法，可以称之为别名语法。除了alias之外，我们可以使用任何其他合法的变量名。 123var &#123; pseudonym: alias &#125; = character console.log(alias)// &lt;- 'Batman' 别名语法看起来并不比ES5的写法alias = character.pseudonym简单。不过如果解构赋值支持深度解构的话，就另当别论了。如下面代码所示： 1var &#123; metadata: &#123; gender &#125; &#125; = character 在类似上面这种情况，当我们需要解构一个嵌套较深的属性值时，使用别名能够更清晰地传递属性名。试想一下，一个叫gender的属性名，并不能如characterGender一样清晰表达所指的内容。 1var &#123; metadata: &#123; gender: characterGender &#125; &#125; = character 在ES5中，访问一个不存在的属性时，会返回undefined。 1234console.log(character.boots) // &lt;- undefined console.log(character['boots']) // &lt;- undefined 在解构赋值中也同样如此。当进行解构赋值的属性不存在时，同样会得到undefined。 123var &#123; boots &#125; = character console.log(boots)// &lt;- undefined 当解构声明中访问的是一个嵌套属性，并且嵌套属性的父对象是null或undefined时，会抛出异常，就像在其他情况下访问null或undefined的属性会报错一样。 1234var &#123; boots: &#123; size &#125; &#125; = character // &lt;- Exceptionvar &#123; missing &#125; = null// &lt;- Exception 在解构赋值中，可以为这些值为undefined的属性解构提供默认值。默认值可以使任何类型的值：如数值、字符串、函数、对象或者对其他变量的引用等。 123var &#123; boots = &#123; size: 10 &#125; &#125;=characterconsole.log(boots)// &lt;- &#123; size: 10 &#125; 默认值在嵌套属性的解构中也可以使用。 123var &#123; metadata: &#123; enemy = 'Satan' &#125; &#125; = character console.log(enemy)// &lt;- 'Satan' 当和别名结合使用时，应如下所示，将别名放在前面，默认值放在后面： 1var &#123; boots: footwear = &#123; size: 10 &#125; &#125; = character 在解构的模式部分可以使用可计算属性名语法。不过，这种情况下，必须提供一个别名作为变量名。这是因为可计算属性名中允许任意表达式，所以编译器无法推断出变量的名称。下例中，即为使用了别名和可计算属性从character对象中提取出了boots属性。 123var &#123; ['boo' + 'ts']: characterBoots &#125; = character console.log(characterBoots)// &lt;- undefined 这一写法并没有什么优势，因为characterBoots = character[type]比{ [type]: characterBoots } = character简单很多。也就是说，可计算属性名声明对象字面量的属性名时很有用，但是在解构赋值中却恰恰相反。 2.3.2 数组的解构数组的解构语法和对象解构相似。下例中，展示了如何将coordinates数组解构成x和y两个变量。数组解构不再是使用花括号，而是使用了方括号。使用解构我们能够在不显示引用索引情况下清晰地为数组中的值命名，即不需要使用类似x = coordi nates[0]这样的代码。 1234var coordinates = [12, -7] var [x, y] = coordinates console.log(x)// &lt;- 12 使用数组解构时，我们可以跳过不感兴趣或者不需要引用的值。 1234var names = ['James', 'L.', 'Howlett'] var [ firstName, , lastName ] = names console.log(lastName)// &lt;- 'Howlett' 和对象解构相似，数组解构也可以设定默认值。 1234var names = ['James', 'L.']var [ firstName = 'John', , lastName = 'Doe' ] = names console.log(lastName)// &lt;- 'Doe' 在ES5中，当我们需要交换两个变量的值时，通常需要借助第三个临时变量。如下所示。 12345var left=5var right = 7 var aux = left left = right right = aux 解构使我们可以不用声明aux变量，而是专注于原本的意图。这也是解构能够使我们的表达更加清晰有效率的一种使用场景。 123var left=5var right = 7[left, right] = [right, left] 数组也可以嵌套解构。如： 12var coordinates = [[12, -7]] var [[x, y]] = coordinates 2.3.3 函数参数的默认值ES6中，函数的参数也能够指定默认值。 123function powerOf(base, exponent = 2) &#123; return Math.pow(base, exponent)&#125; 箭头函数的参数也可以指定默认值。当为箭头函数的参数指定默认值时，哪怕只有一个参数，也要用圆括号将箭头函数的参数列表包裹起来。 1var double = (input = 0) =&gt; input * 2 在JavaScript中，向函数传递一个包含多个属性的options对象参数的情况是再常见不过的了。如果使用函数的时候没有传递options，我们可以为其设定一个默认值。具体代码如下所示。 12345678var defaultOptions = &#123; brand: 'Volkswagen', make: 1999 &#125; function carFactory(options = defaultOptions) &#123; console.log(options.brand) console.log(options.make)&#125;carFactory()// &lt;- 'Volkswagen' // &lt;- 1999 这一方法存在一个问题，如果carFactory的使用者传入了一个options对象，则所有的默认值都会失效。 123carFactory(&#123; make: 2000 &#125;) // &lt;- undefined// &lt;- 2000 结合使用函数参数的默认值和解构赋值，能够解决这一问题。 2.3.4 函数参数的解构与只提供一个默认值相比，更好的方法是对整个options进行解构，并在解构模式中，为每个属性都指定默认值。这个方法使我们不通过options对象就能引用options中的每个选项，但我们也因此不能直接引用options，在某些情况下可能会产生问题。 1234567function carFactory(&#123; brand = 'Volkswagen', make = 1999 &#125;) &#123; console.log(brand) console.log(make)&#125;carFactory(&#123; make: 2000 &#125;) // &lt;- 'Volkswagen'// &lt;- 2000 然而，这种情况下，如果使用者没有传入options对象，默认值会再一次缺失。也就是说，如果没有传入options对象参数，carFactory就会报错。如下所示，可以为options添加一个空对象作为默认值，即可避免这一问题。然后这个空对象就会被解构模式中设定了默认值的属性一一填充。 12345678910function carFactory(&#123; brand = 'Volkswagen', make = 1999&#125; = &#123;&#125;) &#123; console.log(brand) console.log(make)&#125;carFactory()// &lt;- 'Volkswagen' // &lt;- 1999 2.3.5 解构的用法 更加灵活地处理对象或者数组返回值 为函数设置默认值 2.4 剩余参数和扩展运算符在ES6之前，处理任意数量的函数参数必须借助arguments来处理。arguments不是一个数组，但是具有length属性。通常，我们会使用Array#slice.call方法来将arguments对象转换为真正的数组。具体代码如下。 123456function join() &#123; var list = Array.prototype.slice.call(arguments) return list.join(', ')&#125;join('first', 'second', 'third') // &lt;- 'first, second, third' ES6中引入了剩余参数，能够更好地方式解决这一问题。 2.4.1 剩余参数在函数的最后一个参数前添加三个点，可以将该参数转变为一个特殊的“剩余参数”。当剩余参数是函数中的唯一一个参数时，它会获取到所有传入函数的参数。这和上述使用.slice处理的结果是一样的，但不需要依赖于arguments，在参数列表中指定即可。 12345function join(...list) &#123; return list.join(', ')&#125;join('first', 'second', 'third') // &lt;- 'first, second, third' 剩余参数之前的参数不会被包含在list参数中。 12345function join(separator, ...list) &#123; return list.join(separator)&#125;join('; ', 'first', 'second', 'third') // &lt;- 'first; second; third' 注意，如果是箭头函数中包含剩余参数，哪怕只有一个参数，也必须放置在圆括号内。否则，会抛出SyntaxError异常。由下例可以看出，结合箭头函数和剩余参数能够写出更简洁的函数式表达式。 1234var sumAll = (...numbers) =&gt; numbers.reduce( (total, next) =&gt; total + next)console.log(sumAll(1, 2, 5)) // &lt;- 8 2.4.2 扩展运算符扩展运算符可以将可遍历对象转换为数组。扩展运算符能够方便地在数组或者函数调用中展开表达式。下例则在数组字面量中使用...arguments对函数的参数进行了转换。 12345function cast() &#123; return [...arguments]&#125;cast('a', 'b', 'c') // &lt;- ['a', 'b', 'c'] 使用扩展运算符可以将一个字符串分割成数组，数组中元素为组成字符串的每个字符。 12[...'show me']// &lt;- ['s', 'h', 'o', 'w', ' ', 'm', 'e'] 扩展运算符的左右还可以添加其他内容，结果正如所期待的那样。 1234567function cast() &#123; return ['left', ...arguments, 'right']&#125;cast('a', 'b', 'c')// &lt;- ['left', 'a', 'b', 'c', 'right']扩展运算符非常适合用来拼接多个数组。如下例所示，可以在数组字面量中展开任意数组，其中的元素会添加到相应位置。 var all = [1, …[2, 3], 4, …[5], 6, 7] console.log(all) // &lt;- [1, 2, 3, 4, 5, 6, 7] 值得一提的是，扩展运算符不仅能用于数组和arguments中，还可以用于任何可遍历对象中。可遍历是ES6中新引入的一种机制，它允许我们将对象转换成可被遍历的内容，我们将在第4章深入讨论这一部分的内容。 在ES6之前，当某个函数调用的参数是个动态的参数列表时，我们通常会使用.aplly方法。这么做并不优雅，.apply会改变this的指向，而此时，我们并不希望this指向自身。 1fn.apply(null, ['a', 'b', 'c']) 除了在数组中使用扩展运算符之外，我们还可以在函数调用中使用扩展运算符。如下例所示，我们可以使用扩展运算符向multiply函数传递任意数值作为参数。 123456function multiply(left, right) &#123; return left * right&#125;var result = multiply(...[2, 3]) console.log(result)// &lt;- 6 如同上文在数组字面量中一样，在函数调用中扩展参数可以和常规参数一起使用，必要时，可以使用任意多的扩展参数。下例中，调用了print方法，并传入了一对常规参数和一对在参数列表中扩展开的数组。注意，使用剩余参数list能够取到所有传入的参数。扩展运算符和剩余参数可以在不增加代码的前提下，更清晰地展示代码意图。 12345function print(...list) &#123; console.log(list)&#125;print(1, ...[2, 3], 4, ...[5]) // &lt;- [1, 2, 3, 4, 5] .apply方法还有一个不足，当使用new关键字实例化对象时，会非常冗长。下例中使用new和.apply创建了Date对象。先不管在JavaScript中日期中的月份是从0开始的，即11指12月。除此之外，想一想，为了实例化一个对象，我们向语言做了多少妥协。 12new (Date.bind.apply(Date, [null, 2015, 11, 31])) // &lt;- Thu Dec 31 2015 如下所示，扩展运算符能够避免这些问题，我们只需要关注最重要的内容。下例的new实例中，在Date函数使用了...来扩展动态的参数列表。 12new Date(...[2015, 11, 31]) // &lt;- Thu Dec 31 2015 下表总结了上述所讨论的扩展运算符的使用场景。 使用场景 ES5 ES6 数组的连接 [1, 2].concat(more) [1, 2, …more] 将一个数组放入列表中 list.push.apply(list, items) list.push(…items) 解构 a = list[0], other = list.slice(1) [a, …other] = list new关键字和apply方法 new (Date.bind.apply(Date, [null,2015,31,8])) new Date(… [2015,31,8]) 2.5 模板字符串和JavaScript中的常规字符串相比，模板字符串有很大改进。如模板字符串不是使用单引号或者双引号进行声明，而是使用反引号”`”。 1var text = `This is my first template literal` 由于模板字符串使用反引号作为定界符，在使用模板字符串声明字符串时就不需要再转义其中的&#39;和&quot;。具体示例如下： 1var text = `I'm \"amazed\" at these opportunities!` 最值得一提的是，模板字符串中可以插入JavaScript表达式。 2.5.1 字符串插值使用模板字符串，可以在模板中插入任意的JavaScript表达式。当执行到模板字符串表达式时，计算表达式，并将结果返回。下例中，在模板字符串内插入了一个name变量。 `` var name = &#39;Shannon&#39; var text =Hello, ${ name }!` console.log(text) // &lt;","categories":[],"tags":[{"name":"沉淀","slug":"沉淀","permalink":"http://verymuch.com/tags/沉淀/"}]},{"title":"Data URL简介与使用","slug":"Data-URL简介与使用","date":"2017-12-14T00:34:41.000Z","updated":"2018-02-09T12:24:17.000Z","comments":true,"path":"2017/12/14/Data-URL简介与使用/","link":"","permalink":"http://verymuch.com/2017/12/14/Data-URL简介与使用/","excerpt":"1. 简介Data URL，是以data:模式为前缀的URL，允许内容的创建者将较小的文件嵌入到文档中。与常规的URL使用场合类似（下面会具体介绍可以将Data URL用在哪些地方）。 Data URL由data:前缀、MIME类型（表明数据类型）、base64标志位（如果是文本，则可选）以及数据本身四部分组成。 语法格式如下： 1data:[&lt;mediatype&gt;][;base64],data mediatype是一个MIME（Multipurpose Internet Mail Extension）类型字符串，如image/jpeg表示一个JPEG图片文件。如果省略，默认值为text/plain;charset=US-ASCII。","text":"1. 简介Data URL，是以data:模式为前缀的URL，允许内容的创建者将较小的文件嵌入到文档中。与常规的URL使用场合类似（下面会具体介绍可以将Data URL用在哪些地方）。 Data URL由data:前缀、MIME类型（表明数据类型）、base64标志位（如果是文本，则可选）以及数据本身四部分组成。 语法格式如下： 1data:[&lt;mediatype&gt;][;base64],data mediatype是一个MIME（Multipurpose Internet Mail Extension）类型字符串，如image/jpeg表示一个JPEG图片文件。如果省略，默认值为text/plain;charset=US-ASCII。 2. Data URL的优缺点 Data URL的优势 和传统的外部资源引用，Data URL有着以下优势： 当访问外部资源很麻烦或受限时，可以将外部资源转为Data URL引用(这个比较鸡肋) 当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时，这是需要返回一个可用的URL（场景较少） 当图片的体积太小，占用一个HTTP会话不是很值得时（雪碧图可以出场了） Data URL的缺点 虽然Data URL允许使用者将文件嵌入到文档中，这在某些场景下较为合适，但是Data URL也有一些缺点： 体积更大：Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3 不会缓存：Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。 3. 如何获取base64编码 Linux/Mac OS X下可以使用uuencode命令 1uuencode -m &lt;源文件&gt; &lt;转码后标识&gt; 如执行uuencode -m hello-base64 hello，会得到如下结果： 123begin-base64 644 helloaGVsbG8gYmFzZTY0 // 此处为base64编码，对应文本内容为 'hello base64'==== 使用原生Web API编码/解码 Javascript中有两个函数负责编码和解码base64字符串，分别是atob和btoa。 atob(): 负责解码已经使用base64编码了的字符串。 btoa(): 将二进制字符串转为base64编码的ASCII字符串。 两者都只针对Data URL中的data进行处理。 12btoa('hello base64') // \"aGVsbG8gYmFzZTY0\"atob('aGVsbG8gYmFzZTY0') // \"hello base64\" Canvas的toDataURL方法 Canvas提供了toDataURL方法，用于获取canvas绘制内容，将其转为base64格式。 如下所示，文本框中的内容即为canvas中绘制内容的base64格式。 var canvas = document.getElementById('testCanvas'); if (canvas.getContext) { var ctx = canvas.getContext('2d'); // 设置字体 ctx.font = \"Bold 20px Arial\"; // 设置对齐方式 ctx.textAlign = \"left\"; // 设置填充颜色 ctx.fillStyle = \"#000\"; // 设置字体内容，以及在画布上的位置 ctx.fillText(\"hello base64\", 10, 30); // 绘制空心字 ctx.strokeText(\"hello base64\", 10, 80); // 获取 Data URL document.getElementById('testCanvas-content').value = canvas.toDataURL(); } Html: 12&lt;canvas id=\"testCanvas\" width=\"200\" height=\"100\"&gt;&lt;/canvas&gt;&lt;textarea id=\"testCanvas-content\"&gt;&lt;/textarea&gt; JS: 12345678910111213141516var canvas = document.getElementById('testCanvas');if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); // 设置字体 ctx.font = \"Bold 20px Arial\"; // 设置对齐方式 ctx.textAlign = \"left\"; // 设置填充颜色 ctx.fillStyle = \"#000\"; // 设置字体内容，以及在画布上的位置 ctx.fillText(\"hello base64\", 10, 30); // 绘制空心字 ctx.strokeText(\"hello base64\", 10, 80); // 获取 Data URL document.getElementById('testCanvas-content').value = canvas.toDataURL();&#125; 使用FileReader API的readAsDataURL方法 FileReader API提供的readAsDataURL方法能够返回一个基于base64编码的Data URL。 如下所示，选择文件后返回Data URL。 var reader = new FileReader() reader.onload = function(e) { var textarea = document.getElementById('testReadAsDataURL-content'); textarea.value = reader.result } document.getElementById('testReadAsDataURL').onchange = function(e) { var file = e.target.files[0] reader.readAsDataURL(file) } Html: 1234&lt;div class=\"demo-area\"&gt; &lt;input type=\"file\" id=\"testReadAsDataURL\"&gt; &lt;textarea id=\"testReadAsDataURL-content\"&gt;&lt;/textarea&gt;&lt;/div&gt; JS: 123456789var reader = new FileReader()reader.onload = function(e) &#123; var textarea = document.getElementById('testReadAsDataURL-content'); textarea.value = reader.result&#125;document.getElementById('testReadAsDataURL').onchange = function(e) &#123; var file = e.target.files[0] reader.readAsDataURL(file)&#125; 4. Data URL能用在何处呢？最开始已经说了Data URL，是以data:模式为前缀的URL，使用场合与常规URL相同，即常规URL能够使用的场合，Data URL也可以使用。如：浏览器地址栏、link中引入css文件、script中引入js文件、img src中引入图片、video中引入视频、iframe中引入网页、css background url引入背景。 在浏览器地址栏中使用Data URL 在浏览器地址栏中使用Data URL，打开上述canvas中绘制的内容 注意：chrome 从56开始将Data URL标记为“不安全”，从60开始屏蔽从页面打开的 Data URI 网址，可以右键新标签打开。详情 document.getElementById('setDataURLInHref').href = document.getElementById('testCanvas-content').value Html: 1&lt;a href=\"base64内容\" target=\"_blank\" id=\"setDataURLInHref\"&gt;&lt;/a&gt; 在script/img/video/iframe等标签的src属性内使用Data URL 以在script中使用Data URL为例： 点击加入script标签 var scriptDataURL = `data:text/javascript;base64,YWxlcnQoJ+WcqHNjcmlwdOS4reS9v+eUqERhdGEgVVJMJykK` // 对应文本为：alert('在script中使用Data URL') $('#setDataURLInScriptBtn').click(function() { $('').attr('src', scriptDataURL).appendTo($('body')) }) JS: 12345var scriptDataURL = `data:text/javascript;base64,YWxlcnQoJ+WcqHNjcmlwdOS4reS9v+eUqERhdGEgVVJMJykK`// 对应文本为：alert('在script中使用Data URL')$('#setDataURLInScriptBtn').click(function() &#123; $('&lt;script&gt;').attr('src', scriptDataURL).appendTo($('body'))&#125;) 在&lt;link&gt;标签的href中使用Data URL 点击将文字的颜色设为红色 var linkDataURL = `data:text/css;base64,I3NldERhdGFVUkxJbkxpbmtCdG57Y29sb3I6IHJlZDt9Cg==` // 对应内容为：setDataURLInLinkBtn{color: red;} $('#setDataURLInLinkBtn').click(function() { $('').attr('href', linkDataURL).appendTo($('head')) }) JS: 12345var linkDataURL = `data:text/css;base64,I3NldERhdGFVUkxJbkxpbmtCdG57Y29sb3I6IHJlZDt9Cg==`// 对应内容为：setDataURLInLinkBtn&#123;color: red;&#125;$('#setDataURLInLinkBtn').click(function() &#123; $('&lt;link rel=\"stylesheet\" type =\"text/css\"&gt;').attr('href', linkDataURL).appendTo($('head'))&#125;) 在css样式background的url中使用Data URL const bgDataURL = $('#testCanvas-content')[0].value $('#setDataURLInBG').css('background-image', `url(${bgDataURL})`) JS: 12const bgDataURL = $('#testCanvas-content')[0].value$('#setDataURLInBG').css('background-image', `url($&#123;bgDataURL&#125;)`) 5. 参考链接 MDN Data URLs","categories":[],"tags":[{"name":"沉淀","slug":"沉淀","permalink":"http://verymuch.com/tags/沉淀/"}]},{"title":"escape、encodeURI和encodeURIComponent的区别与使用","slug":"escape、encodeURI和encodeURIComponent的区别与使用","date":"2017-12-12T14:51:18.000Z","updated":"2018-02-09T12:24:31.905Z","comments":true,"path":"2017/12/12/escape、encodeURI和encodeURIComponent的区别与使用/","link":"","permalink":"http://verymuch.com/2017/12/12/escape、encodeURI和encodeURIComponent的区别与使用/","excerpt":"1. escapeescape是对字符串(string)进行编码(而另外两种是对URL)，作用是让它们在所有电脑上可读。编码之后的效果是%XX或者%uXXXX这种形式。其 ASCII字母、数字、@*/+，这几个字符不会被编码，其余的都会。 注意，当需要对URL编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于URL。 在实际工作中使用较少，可以先了解功能，待有需求时再使用。 2. encodeURI 和 encodeURIComponent对URL编码是常见的事，所以这两个方法应该是实际中要特别注意的。 它们都是编码URL，唯一区别就是编码的字符范围： encodeURI方法不会对下列字符编码ASCII字母、数字、~!@#$&amp;*()=:/,;?+&#39; encodeURIComponent方法不会对下列字符编码ASCII字母、数字、~!*()&#39; 由此可见encodeURIComponent比encodeURI编码范围更大。如，encodeURIComponent会把http://编码 http%3A%2F%2F而encodeURI却不会。","text":"1. escapeescape是对字符串(string)进行编码(而另外两种是对URL)，作用是让它们在所有电脑上可读。编码之后的效果是%XX或者%uXXXX这种形式。其 ASCII字母、数字、@*/+，这几个字符不会被编码，其余的都会。 注意，当需要对URL编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于URL。 在实际工作中使用较少，可以先了解功能，待有需求时再使用。 2. encodeURI 和 encodeURIComponent对URL编码是常见的事，所以这两个方法应该是实际中要特别注意的。 它们都是编码URL，唯一区别就是编码的字符范围： encodeURI方法不会对下列字符编码ASCII字母、数字、~!@#$&amp;*()=:/,;?+&#39; encodeURIComponent方法不会对下列字符编码ASCII字母、数字、~!*()&#39; 由此可见encodeURIComponent比encodeURI编码范围更大。如，encodeURIComponent会把http://编码 http%3A%2F%2F而encodeURI却不会。 3. 总结：适用场合三个方法的区别从上面已经能够看出，但是说实话，估计具体哪些字符会被编码没人能记得住，所以化简为繁，只要记住三种方法的使用场合就行了。 如果只是编码字符串，不和URL有半毛钱关系，那么用escape。 如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。 比如encodeURI(&quot;http://www.cnblogs.com/season-huang/some other thing&quot;); 编码后会变为&quot;http://www.cnblogs.com/season-huang/some%20other%20thing&quot;; 其中，空格被编码成了%20。但是如果你用了encodeURIComponent，那么结果变为 &quot;http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2Fsome%20other%20thing&quot; 看到了区别吗，连/都被编码了，整个URL已经没法用了。 当你需要编码URL中的参数（如rdurl）的时候，那么encodeURIComponent是最好方法。 12345var param = \"http://www.cnblogs.com/season-huang/\"; //param为参数param = encodeURIComponent(param);var url = \"http://www.cnblogs.com?next=\" + param;console.log(url) // \"http://www.cnblogs.com?next=http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2F\" 从上例可以看出，参数中的/被编码了，如果用encodeURI肯定要出问题，因为后面的/是需要编码的。","categories":[],"tags":[{"name":"沉淀","slug":"沉淀","permalink":"http://verymuch.com/tags/沉淀/"}]},{"title":"Javascript - RegExp正则表达式","slug":"Javascript-RegExp正则表达式","date":"2017-11-01T14:28:23.000Z","updated":"2018-02-09T12:24:41.000Z","comments":true,"path":"2017/11/01/Javascript-RegExp正则表达式/","link":"","permalink":"http://verymuch.com/2017/11/01/Javascript-RegExp正则表达式/","excerpt":"1. 概述正则表达式（Regular Expression）是一种表达文本模式（即字符串结构）的方法，用来按照“给定模式”匹配文本。 JavaScript的正则表达式体系是参照 Perl 5 建立的。 2. 如何新建 使用字面量，以斜杠表示开始和结束。(编译时新建) -&gt; 书写方便直观，常用 1var regex = /verymuch/; 使用 RegExp 构造函数。(运行时新建) 1var regex = new RegExp('verymuch'); RegExp 构造函数还可以接受第二个参数，表示修饰符，i/g/m。 注意，上述两种方式都会建立一个内容为verymuch的正则表达式对象，它们的主要区别是第一种方法在编译时新建，第二种方法在运行时新建。","text":"1. 概述正则表达式（Regular Expression）是一种表达文本模式（即字符串结构）的方法，用来按照“给定模式”匹配文本。 JavaScript的正则表达式体系是参照 Perl 5 建立的。 2. 如何新建 使用字面量，以斜杠表示开始和结束。(编译时新建) -&gt; 书写方便直观，常用 1var regex = /verymuch/; 使用 RegExp 构造函数。(运行时新建) 1var regex = new RegExp('verymuch'); RegExp 构造函数还可以接受第二个参数，表示修饰符，i/g/m。 注意，上述两种方式都会建立一个内容为verymuch的正则表达式对象，它们的主要区别是第一种方法在编译时新建，第二种方法在运行时新建。 3. 正则表达式对象的属性和方法3.1 正则表达式对象的属性 修饰符类属性：返回一个布尔值，表示对应的修饰符是否设置 ignoreCase：返回一个布尔值，表示是否设置了i修饰符，该属性只读。 global：返回一个布尔值，表示是否设置了g修饰符，该属性只读。 multiline：返回一个布尔值，表示是否设置了m修饰符，该属性只读。 12345var regex = /verymuch/igm;regex.ignoreCase // trueregex.global // trueregex.multiline // true 与修饰符无关的属性 lastIndex: 返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。 source: 返回正则表达式的字符串形式，不包括斜杠，该属性只读。 1234var regex = /verymuch/igm;regex.lastIndex // 0regex.source // \"verymuch\" 3.2 正则表达式对象的方法3.2.1 test()该方法表示当前模式是否匹配参数字符串，返回值为布尔值。 常规用法 1/cat/.test('cats and dogs') // true 正则表达式带有g修饰符，每次test方法都从上次结束的位置开始向后匹配。 1234567891011var r = /x/g;var s = '_x_x';r.lastIndex // 0r.test(s) // truer.lastIndex // 2r.test(s) // truer.lastIndex // 4r.test(s) // false 带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置。 12345var r = /x/g;var s = '_x_x';r.lastIndex = 4;r.test(s) // false 注意：lastIndex属性只对同一个正则表达式有效。下面这么写是错的，因为每次匹配条件都是一个新的正则，lastIndex都是0。 12var count = 0;while (/a/g.test('babaa')) count++; 特例用法：如果正则模式是一个空字符串，则匹配所有字符串。 3.2.2 exec()exec方法可以返回匹配结果。匹配成功，则返回一个数组，成员是每一个匹配成功的子字符串；不成功则返回null。 常规用法 123456var s = '_x_x';var r1 = /x/;var r2 = /y/;r1.exec(s) // [\"x\"]r2.exec(s) // null exec方法返回的数组还包括以下两个属性： input：整个原字符串。 index：整个模式匹配成功的开始位置（从0开始计数） 123var s = 'verymuch';var r = /m/g;r.exec(s); // [\"m\", index: 4, input: \"verymuch\"] 包含组匹配 如果正则表达式包括圆括号(即包含“组匹配”)，则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。 1234var s = '_x_x';var r = /_(x)/;r.exec(s) // [\"_x\", \"x\"] 带有g修饰符 如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。 123456789101112131415161718192021var r = /a(b+)a/g;var a1 = r.exec('_abbba_aba_');a1 // ['abbba', 'bbb']a1.index // 1r.lastIndex // 6var a2 = r.exec('_abbba_aba_');a2 // ['aba', 'b']a2.index // 7r.lastIndex // 10var a3 = r.exec('_abbba_aba_');a3 // nulla3.index // TypeError: Cannot read property 'index' of nullr.lastIndex // 0var a4 = r.exec('_abbba_aba_');a4 // ['abbba', 'bbb']a4.index // 1r.lastIndex // 6 前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，正则对象的lastIndex属性重置为0，意味着第四次匹配将从头开始。 手动设置lastIndex的值，会从指定位置开始匹配，只有在g修饰符存在下，才有效。 12345678910111213/* 无g修饰符，lastIndex设置无效 */var r1 = /a/;r1.lastIndex = 7; // 无效var match = r1.exec('xaxa');match.index // 1r1.lastIndex // 7/* 有g修饰符，lastIndex设置有效 */var r2 = /a/g;r2.lastIndex = 2;var match = r2.exec('xaxa');match.index // 3r2.lastIndex // 4 特例用法：如果正则对象是一个空字符串，则exec方法会匹配成功，但返回的也是空字符串。 1234567891011var r1 = new RegExp('');var a1 = r1.exec('abc');a1 // ['']a1.index // 0r1.lastIndex // 0var r2 = new RegExp('()');var a2 = r2.exec('abc');a2 // ['', '']a2.index // 0r2.lastIndex // 0 4. 字符串对象的方法字符串对象的方法中，有四种与正则对象有关。 match()：返回一个数组，成员是所有匹配的子字符串。 search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。 replace()：按照给定的正则表达式进行替换，返回替换后的字符串，原字符串不变。 split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。 4.1 String.prototype.match() 常规用法 与正则对象的exec方法类似，成功返回数组，且包含index和input属性；不成功返回null。 123456var s = 'verymuch';var r1 = /v/;var r2 = /z/;s.match(r1) // [\"v\", index: 0, input: \"verymuch\"]s.match(r2) // null 带有g修饰符时，与exec不同，会一次性返回所有匹配成功的结果。 12345var s = 'verymuchve';var r = /v(e)/g;s.match(r) // [\"ve\", \"ve\"]r.exec(s) // [\"ve\", \"e\", index: 0, input: \"verymuchve\"] 特别注意：设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。 1234var s = 'verymuchve';var r = /v(e)/g;r.lastIndex = 15; // 无效s.match(r) // [\"ve\", \"ve\"] 4.2 String.prototype.search()字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置，如未匹配，则返回-1。 1'verymuch'.search(/v/); // 0 该方法会忽略g修饰符，并且和match类似，设置lastIndex无效，永远从第一个字符开始匹配。 123var r = /v(e)/g;r.lastIndex = 15; // 无效'verymuch'.search(r) // 0 4.3 String.prototype.replace()4.3.1 用法对象字符串的replace方法可以替换匹配的值。接收两个参数，第一个是搜索模式，第二个是替换内容：str.replace(search, replacement)。 不加g修饰符，则只替换第一个匹配成功的值；加了g修饰符，则替换所有匹配成功的值。 123'aaa'.replace('a', 'b') // \"baa\"'aaa'.replace(/a/, 'b') // \"baa\"'aaa'.replace(/a/g, 'b') // \"bbb\"，替换了所有的匹配值 replace方法的第二个参数中可以使用$符号，用来指代所替换的内容。 $&amp; 指代匹配的子字符串。 $` 指代匹配结果前面的文本。 $’ 指代匹配结果后面的文本。 $n 指代匹配成功的第n组内容，n是从1开始的自然数。 $$ 指代美元符号$。 123'hello world'.replace(/(\\w+)\\s(\\w+)/, '$2 $1'); // \"world hello\"'abc'.replace('b', '[$`-$&amp;-$\\']'); // \"a[a-b-c]c\" replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。 1234'3 and 5'.replace(/[0-9]+/g, function(match)&#123; return 2 * match;&#125;)// \"6 and 10\" 作为replace方法第二个参数的替换函数，可以接受多个参数。第一个参数是匹配到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。 4.3.2 使用场景 用于消除字符串首尾两端的空格。 1234var str = ' #id div.class ';str.replace(/^\\s+|\\s+$/g, '')// \"#id div.class\" 网页模板字符串替换 1234567891011121314var prices = &#123;'pr_1': '$1.99','pr_2': '$9.99','pr_3': '$5.00'&#125;;var template = '/* ... */'; // 这里可以放网页模块字符串template.replace( /(&lt;span id=\")(.*?)(\"&gt;)(&lt;\\/span&gt;)/g, function(match, $1, $2, $3, $4)&#123; return $1 + $2 + $3 + prices[$2] + $4; &#125;); 4.4 String.prototype.split()字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。 语法为：str.split(separator, [limit])。第一个参数为分割规则，第二个参数为返回数组的最大成员数，该参数可缺省。 123456789101112131415// 非正则分隔'a, b,c, d'.split(',')// [ 'a', ' b', 'c', ' d' ]// 正则分隔，去除多余的空格'a, b,c, d'.split(/, */)// [ 'a', 'b', 'c', 'd' ]// 指定返回数组的最大成员'a, b,c, d'.split(/, */, 2)[ 'a', 'b' ]// 特殊示例，第二次以0个`a`分割'aaa**a*'.split(/a*/)// [\"\", \"*\", \"*\", \"*\"] 如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。若不想返回括号中的内容，则可以使用非捕获括号（见下文）。 12'aaa*a*'.split(/(a*)/)// [ '', 'aaa', '*', 'a', '*' ] 5. 匹配规则5.1 字面量字符和元字符大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”（literal characters）。 除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。 点字符(.) 点字符（.）匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符（只能一个字符）。 位置字符 ^ 表示字符串的开始位置 $ 表示字符串的结束位置 123456789// test必须出现在开始位置/^test/.test('test123') // true// test必须出现在结束位置/test$/.test('new test') // true// 从开始位置到结束位置只有test/^test$/.test('test') // true/^test$/.test('test test') // false 选择符(|) 竖线符号（|）在正则表达式中表示“或关系”（OR），即very|much表示匹配very或much。并且多个选择符可以联合使用。 1234/11|22/.test('911') // true// 匹配fred、barney、betty之中的一个/fred|barney|betty/ 选择符会包括它前后的多个字符，比如/ab|cd/指的是匹配ab或者cd，而不是指匹配b或者c。如果想修改这个行为，可以使用圆括号。 1/a( |\\t)b/.test('a\\tb') // true 其他元字符：还包括\\\\、\\*、+、?、()、[]、{}等，将在下文解释。 5.2 转义符正则表达式中那些有特殊含义的字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配加号，就要写成+。 123/1+1/.test('1+1'); // false/1\\+1/.test('1+1'); // true 正则模式中，需要用斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\\\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。 123(new RegExp('1\\+1')).test('1+1'); // false(new RegExp('1\\\\+1')).test('1+1'); // true 上面代码中，RegExp作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。 5.3 特殊字符正则表达式对一些不能打印的特殊字符，提供了表达方法。 \\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。 [\\b] 匹配退格键(U+0008)，不要与\\b混淆。 \\n 匹配换行键。 \\r 匹配回车键。 \\t 匹配制表符tab（U+0009）。 \\v 匹配垂直制表符（U+000B）。 \\f 匹配换页符（U+000C）。 \\0 匹配null字符（U+0000）。 \\xhh 匹配一个以两位十六进制数（\\x00-\\xFF）表示的字符。 \\uhhhh 匹配一个以四位十六进制数（\\u0000-\\uFFFF）表示的unicode字符。 5.4 字符类字符类（Class）有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[very]表示匹配v,e、r、y之中的任意一个。 12/[m]/.test('very') // false/[m]/.test('much') // true 在字符类中有两个字符有特殊含义 脱字符(^) 如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，匹配其他任意字符。比[^very]表示匹配v,e、r、y之外的任意一个。 12/[^m]/.test('very') // true/[^m]/.test('much') // false 如果方括号内没有其他字符，只有[^]，则匹配一切字符，其中包括换行符，而点号(.)是不包括换行符。 12/./.test('\\n'); // false/^/.test('\\n'); // true 注意，脱字符只有在字符类的第一个位置才有特殊含义，其他位置为字面含义 连字符(-) 某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。 1[1-31] // 只代表1到3，不代表1到31 注意，字符类的连字符必须在头尾两个字符中间，才有特殊含义，否则就是字面含义。比如，[-9]就表示匹配连字符和9，而不是匹配0到9。 连字符还可以用来指定Unicode字符的范围。 123var str = \"\\u0130\\u0131\\u0132\";/[\\u0128-\\uFFFF]/.test(str)// true 另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。 5.5 预定义模式预定义模式是指常见模式的简写方式。 \\d 匹配0-9之间的任一数字，相当于[0-9]。 \\D 匹配所有0-9以外的字符，相当于[^0-9]。 \\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。 \\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。 \\s 匹配空格（包括制表符、空格符、断行符等），相等于[\\t\\r\\n\\v\\f]。 \\S 匹配非空格的字符，相当于[^\\t\\r\\n\\v\\f]。 \\b 匹配词的边界。 \\B 匹配非词边界，即在词的内部。 1234567891011// \\s的例子/\\s\\w*/.exec('hello world') // [\" world\"]// \\b的例子/\\bworld/.test('hello world') // true/\\bworld/.test('hello-world') // true/\\bworld/.test('helloworld') // false// \\B的例子/\\Bworld/.test('hello-world') // false/\\Bworld/.test('helloworld') // true 通常，正则表达式遇到换行符（\\n）就会停止匹配。 12345// [\\S\\s]可以匹配所有字符var html = \"&lt;b&gt;Hello&lt;/b&gt;\\n&lt;i&gt;world!&lt;/i&gt;\";/[\\S\\s]*/.exec(html)[0]// \"&lt;b&gt;Hello&lt;/b&gt;\\n&lt;i&gt;world!&lt;/i&gt;\" 5.6 重复类模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。 12/lo&#123;2&#125;k/.test('look') // true/lo&#123;2,5&#125;k/.test('looook') // true 5.7 量词符用来设定某个模式出现的次数 ? 问号表示某个模式出现0次或1次，等同于{0, 1}。 * 星号表示某个模式出现0次或多次，等同于{0,}。 + 加号表示某个模式出现1次或多次，等同于{1,}。 1234567891011121314// t出现0次或1次/t?est/.test('test') // true/t?est/.test('est') // true// t出现1次或多次/t+est/.test('test\") // true/t+est/.test('ttest') // true/t+est/.test('est') // false// t出现0次或多次/t*est/.test('test') // true/t*est/.test('ttest') // true/t*est/.test('tttest') // true/t*est/.test('est') // true 5.8 贪婪模式上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。 12var s = 'aaa';s.match(/a+/) // [\"aaa\"] 上述代码中，默认是贪婪模式，会一直匹配到不出现a为止，所以匹配结果为3个a。 在量词符后加一个问号，可以将贪婪模式改为非贪婪模式。非贪婪模式，一旦条件满足，就不在往下匹配。 12var s = 'aaa';s.match(/a+?/) // [\"a\"] ??：匹配时采用非贪婪模式，则在满足匹配条件的情况下，不贪婪，不一定是匹配0次。 *?：匹配时采用非贪婪模式，则在满足匹配条件的情况下，不贪婪，不一定是匹配0次。 +?：匹配时采用非贪婪模式，则在满足匹配条件的情况下，不贪婪，不一定是匹配1次。 5.9 修饰符修饰符(modifier)表示模式的附加规则，放在正则模式的尾部。 g修饰符 g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换，前面介绍的内容能够看出。 i修饰符 默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。 m修饰符 m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\\n）。 1234/world$/.test('hello world\\n') // false/world$/m.test('hello world\\n') // true 匹配行尾/^b/m.test('a\\nb') // true 匹配行首 5.10 组匹配正则表达式的括号表示分组匹配。 捕获组 在正则表达式内部，可以用\\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。 12/(.)b(.)\\1b\\2/.test(\"abcabc\")// true 上面的代码中，\\1表示第一个括号匹配的内容（即“a”），\\2表示第二个括号匹配的内容（即“c”） 括号还可以嵌套。 1/y((..)\\2)\\1/.test('yabababab') // true 上面代码中，\\1指向外层括号，\\2指向内层括号。 组匹配非常有用，下面是一个匹配网页标签的例子。 123var tagName = /&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\\/\\1&gt;/;tagName.exec(\"&lt;b&gt;bold&lt;/b&gt;\")[1] 上面代码中，圆括号匹配尖括号之中的标签，而\\1就表示对应的闭合标签。 将上面的代码略作修改，就可以捕获带有属性的标签。 1234567891011121314var html = '&lt;b class=\"hello\"&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;';var tag = /&lt;(\\w+)([^&gt;]*)&gt;(.*?)&lt;\\/\\1&gt;/g;var match = tag.exec(html);match[1] // \"b\"match[2] // \"class=\"hello\"\"match[3] // \"Hello\"match = tag.exec(html);match[1] // \"i\"match[2] // \"\"match[3] // \"world\" 注意，中间的非贪婪匹配了hello，在满足匹配条件的情况下不贪婪。 非捕获组 (?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。 非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成/(foo){1, 2}/，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为/(?:foo){1, 2}/，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容，也不能用\\n引用括号匹配的内容 12345var m = 'abc'.match(/(?:.)b(.)/);m // [\"abc\", \"c\"] 非捕获括号的内容在结果中没有var n = 'aba'.match(/(?:.)b\\1/);n // null 先行断言 x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\\d+(?=%)/。 “先行断言”中，括号里的部分是不会返回的。 12var m = 'abc'.match(/b(?=c)/);m // [\"b\"] 先行否定断言 x(?!y)称为先行否定断言（Nagative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着的不是百分号的数字，可以写成/\\d+(?!%)/。 12/\\d+(?!\\.)/.exec('3.14')// [\"14\"] 上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是14。","categories":[],"tags":[{"name":"沉淀","slug":"沉淀","permalink":"http://verymuch.com/tags/沉淀/"}]},{"title":"第2章 ES6基础","slug":"第2章-ES6基础","date":"2017-11-01T08:53:14.000Z","updated":"2018-02-09T12:24:36.000Z","comments":true,"path":"2017/11/01/第2章-ES6基础/","link":"","permalink":"http://verymuch.com/2017/11/01/第2章-ES6基础/","excerpt":"ES6中引入了大量的非破坏性语法变更，我们将在本章逐一讨论。大部分变更都是语法糖，使用更多更复杂的ES5代码也能够实现。还有一部分不仅仅是语法糖，如let和const这两种完全不同的变量声明方式，在本章最后会对其进行介绍。 ES6中，对象字面量语法有了一些调整，我们从这部分开始说起。","text":"ES6中引入了大量的非破坏性语法变更，我们将在本章逐一讨论。大部分变更都是语法糖，使用更多更复杂的ES5代码也能够实现。还有一部分不仅仅是语法糖，如let和const这两种完全不同的变量声明方式，在本章最后会对其进行介绍。 ES6中，对象字面量语法有了一些调整，我们从这部分开始说起。 2.1 对象字面量对象字面量是指使用{}简写语法进行对象声明的形式，具体语法格式如下： [P19 代码1] ES6中对象字面量语法有一些小的改进：属性值简写、可计算属性名和方法定义。下面来学习一下这些内容及其用法。 2.1.1 属性值简写有时我们会声明这样一个对象，该对象有一个或多个属性的属性名和所引用的变量名相同。比如，有一个listeners数组，要将其赋给对象字面量中名为listeners的属性，必须重复输入该名称。以下代码中的对象字面量中就包含下两个名称与值重复的属性： [P20 代码1] 在ES6中，借助新的属性值简写语法就可以省略属性值和分号，属性值简写会进行隐性赋值，如下例所示： [P20 代码2] 随着对于本书第二章的学习，我们会发现属性值简写在不影响代码含义的情况下，能有效减少重复代码。如以下代码，我重新实现了浏览器中的持久存储API localStorage的部分内容，可以将其看成是内存存储的填充实现[注释 1]。如果没有使用简写语法，storage对象看起来会更加冗长： [P20 代码3] ES6中有很多旨在减少所维护代码复杂性的特性，属性值简写只是其中之一。一旦习惯了这一新语法，你就会发现代码的可读性和开发者的生产效率都会得到提升。 2.1.2 可计算属性名有时，我们可能需要声明这样一个对象：属性名基于其他变量或者表达式。如下面的ES5代码所示，假设expertise作为一个函数参数提供，我们事先并不知道它的值： [P21 代码1] 在ES6中，对象字面量不再只能使用静态名称来声明。可以使用可计算属性名，用方括号将表达式包裹起来，即可作为属性名使用。当声明执行时，表达式才会被计算，并被当做属性名使用。下面的例子向我们展示了如何一步完成上例中person对象的声明，而不需要借助第二个声明来添加expertise属性。 [P21 代码2] 属性值简写和可计算属性名不能同时使用。属性值简写是在编译时执行的简单语法糖，可以避免重复，而可计算属性名是在运行时进行计算的。如果试图同时使用这两个特性时，系统会抛出一个语法错误的异常。多数情况下，这种组合使用会导致代码难以理解，所以最好不要同时使用这两个特性。 [P22 代码1] 12// this is a syntax error!// 语法错误 可计算属性名有一个常用的使用场景，如当我们想要将一个实体添加到一个对象映射中，并且想使用实体的id字段作为键值，就可以使用可计算属性名。直接在groceries对象字面量中进行内联声明，而不需要单独使用第三条声明语句将grocery添加到groceries映射中。 [P22 代码2] 还有一种使用场景：当一个函数接受一个参数，并将该参数用于构建返回值对象。如果使用ES5，则需要分配一个变量进行对象字面量的声明，添加一个属性，最后返回这个对象。下例展示了这一使用场景，创建一个信封，之后能够用于Ajax返回值，这些返回值遵循以下约定：有一个error属性，用于描述发生的错误；有一个success属性表示成功： [P22 代码3，P23 代码1] 使用可计算属性名能够更简明地实现上例中的函数，仅使用一条语句就能够实现： [P23 代码2] 方法定义通常，我们通过添加属性来为对象声明方法。以下代码中，创建了一个能够支持多种事件类型的小型事件发射器。emitter#on方法可以用来注册事件监听函数，emitter#emit方法可以用来触发事件。 [P23 代码3] 从ES6开始，在对象字面量中可以使用新的方法定义语法进行方法的声明，省略分号和function关键字，这样更加简洁。以下代码即为使用方法定义进行声明的emitter对象。 [P24 代码1] 箭头函数是ES6中的另一种函数声明方式，它有好几种形式。现在让我们来探究一下箭头函数到底是什么、它们是如何声明的以及它们的语法形式。 2.2 箭头函数在JavaScript中，我们通常使用类似下面的代码进行函数声明，包括函数名，参数列表和函数体。 [P24 代码2] 也可以创建一个匿名函数，省略函数的名称，并将其赋值给一个变量或者对象的属性，也可以直接进行调用。 [P24 代码3] 从ES6开始，我们可以使用箭头函数作为声明匿名函数另一种方式。值得一提的是，箭头函数有几种不同的写法。如下代码中的箭头函数和上面的匿名函数非常相似。唯一的不同就是缺少了function关键字，并且在参数列表的右侧多了个=&gt;箭头。 [P25 代码1] 尽管箭头函数看起来和常规的匿名函数很相似，但是本质上它们是完全不同的：箭头函数不能显示地命名，尽管现代运行环境会将箭头函数所赋予的变量名作为函数名；不能用作构造函数，也没有prototype属性，所以不能使用new关键字调用箭头函数；箭头函数被绑定到所在词法作用域中，这也是为什么它们不会改变this指向的原因。 接下来，让我们深入了解它们在语义上与传统函数的不同、声明箭头函数的多种方法以及实际用例。 2.2.1 词法作用域箭头函数不会创建新的作用域，在箭头函数的函数体内，this、arguments以及super均指向所在的父级作用域。如下示例，有一个timer计时器对象，对象上有一个seconds计数器属性和一个start方法，这个方法就是用我们前面所学习的方法定义语法创建的。然后我们开启这个计时器，等待几秒钟后，打印已经过去的秒数。 [P25 代码1] 如果我们不使用箭头函数，而是使用常规的匿名函数定义传入setInterval的函数的话，this将绑定到匿名函数的上下文上，而不是start方法的上下文上。这时，如果想实现上面的timer计时器，可以在start方法的开头加上类似var self = this的声明语句，然后在setInterval函数内部引用self即可。由此可见，使用箭头函数，能够避免为保持上下文引用而额外增加的复杂性，只需关注代码的功能即可。 同样地，ES6中箭头函数的作用域绑定也意味着使用.call、.apply、.bind等方法调用函数时也无法改变this的指向。这一限制通常是很有用的，因为这能够保证上下文不被修改。 现在再看一下下面这个例子。你认为console.log会输出出什么呢？ [P26 代码1] 答案是arguments指向匿名函数的上下文，因此传入匿名函数的参数会被输出。在本例中，这些参数是1, 2, 3。 如果将上例中的匿名函数换为箭头函数，结果又会是怎样的呢？ [P26 代码2] 这时，arguments对象指向puzzle函数的上下文，因为箭头函数并不会创建闭包。因此，输出结果为&#39;a&#39;, &#39;b&#39;, &#39;c&#39;。 前面有提到箭头函数有多种写法，但到目前为止，我们只使用了完整版的写法。其他几种写法是什么样的呢？ 2.2.2 箭头函数的写法让我们再一起回顾下目前所学的箭头函数语法： [P26 代码3] 如果箭头函数只有一个参数，则可以省略圆括号。当然，这不是必须的。当将箭头函数传递到其他方法中时，这么做很有用，因为这样能够减少圆括号的数量，使得代码更加可读。 [P27 代码1] 如前面的double方法一样，当使用箭头函数声明简单函数时，完整写法较为繁琐。可以使用value * 2表达式来代替整个函数体。当函数被调用时，表达式会被计算，结果则作为返回值返回。这时，return语句是隐式的，并且不需要使用花括号包裹函数体： [P27 代码2] 我们还可以同时省略括号和return语句，这样箭头函数会更加简洁： [P27 代码3] 隐式返回对象字面量当想要隐式返回对象字面量时，则需要使用圆括号将对象字面量包裹起来。否则，编译器会将花括号当成函数体的开始和结束标志。 [P27 代码4] 下例中，JavaScript就将花括号当成了箭头函数的函数体。此外，number会被当作一个label[注释 2]，然后有一个没有做任何事的value表达式。由于函数体没有返回任何内容，所以映射得到的值为undefined： [P27 代码5] 如果我们作为隐式返回的对象字面量具有多个属性，编译器无法识别第二个属性，则会抛出SyntaxError异常： [P28 代码1] 在对象字面量外添加圆括号可以解决该问题，这样编译器就不会再将其当做函数体，此时的对象声明即为我们想要隐式返回的对象字面量。 [P28 代码2] 现在已经理解了什么是箭头函数，接下来看一下箭头函数的优点以及正确的用法。 2.2.3 优点和使用场景一般来说，我们不应该盲目地使用ES6的特性。相反地，最好在使用每个特性前都仔细思考下使用了新特性后是否真的能提高代码的可读性和可维护性。严格来说，ES6特性并不总是比现有特性好，因此最好不要随意使用它们。 箭头函数在某些情况下并不适用。比如，当一个函数包含很多行代码时，这时候使用箭头函数对代码并不能起到改进作用。箭头函数更适合用于简短的实例中，比如当function关键字和语法模板占函数表达式的很大一部分时。 适当地为函数命名能使得人类理解起来更容易。箭头函数不能显示地命名，但是可以通过赋值给其他变量，隐式地命名。在下例中，我们将箭头函数赋值给了throwError变量。当调用函数式的过程中发生错误时，调用栈能够正确地定位到throwError： [P29 代码1] 当需要定义一个在任何情况下词法作用域都不改变的匿名函数时，使用箭头函数是很整适合的，并且在某些情况下，它还可以使代码更加整洁。此外，在大多数函数式编程的情况下，箭头函数是特别有用的，比如使用数组对象的.map、.filter或者.reduce等方法。具体示例如下图所示： [P29 代码2] 2.3 解构赋值解构赋值是ES6中最灵活最有表现力的特性之一。同时，它也最为简单。它可以将对象的属性值绑定到任意多的变量上。解构赋值可以用于对象、数组以及函数参数列表中。我们先从对象的解构开始逐一介绍。 2.3.1 对象的解构假设我们有一个程序，程序中有一些漫画书的角色，Bruce Wayne是这些角色中的一个，我们想要引用用于描述Bruce Wayne的对象中的属性。下面的代码就是用于描述蝙蝠侠的示例对象： [P29 代码3] 如果我们想要声明一个pseudonym变量，并引用character.pseudonym的值，我们可能会写出以下ES5代码。如果我们需要在多个地方引用pseudonym，我们更希望能够避免每次都输入character.pseudonym： [P30 代码1] 如果在赋值语句中使用解构赋值，语法会变得更加清晰。在下例中能够看出，使用解构赋值后，我们不需要重复两次输入pseudonym，并且仍能清晰地表达含义。下面的这段代码和上面用ES5编写的代码是等价的。 [P30 代码2] 通过var声明时，使用逗号隔开能一次声明多个变量。同样地，在解构赋值的花括号中也可以声明多个变量。 [P30 代码3] 此外，我们可以在同一个var语句中同时使用常规的变量声明和解构赋值。这种用法一开始看起来可能很奇怪，而且还要看我们所使用的JavaScript代码样式规范是否允许在单个语句中声明多个变量。不管如何，从这一点还是能够看出解构语法的灵活性。 [P30 代码4] 如果想要提取pseudonym属性，并将其声明为alias变量，我们可以使用下面这种解构语法，可以称之为别名语法。除了alias之外，我们可以使用任何其他合法的变量名。 [P30 代码5] 别名语法看起来并不比ES5的写法alias = character.pseudonym简单。不过如果解构赋值支持深度解构的话，就另当别论了。如下面代码所示： [P30 代码6] 在类似上面这种情况，当我们需要解构一个嵌套较深的属性值时，使用别名能够更清晰地传递属性名。试想一下，一个叫gender的属性名，并不能如characterGender一样清晰表达所指的内容。 [P31 代码1] 如上我们所看到的这种情况是很常见的，因为属性通常是基于其宿主对象命名的。character.metadata.gender的含义很清楚，而单独使用gender则可以表示很多内容，所以在结构赋值中使用类似characterGender的别名能够将上下文含义带入到变量中。 在ES5中，访问一个不存在的属性时，会返回undefined。 [P31 代码2] 在解构赋值中也同样如此。当进行解构赋值的属性不存在时，同样会得到undefined。 [P31 代码3] 当解构声明中访问的是一个嵌套属性，并且嵌套属性的父对象是null或undefined时，会抛出异常，就像在其他情况下访问null或undefined的属性会报错一样。 [P31 代码4] 由于解构赋值主要是语法糖，所以看一下下面的ES5等价代码，就能够清楚地知道上述代码为何会抛出异常了。 [P31 代码5] 在解构赋值中，可以为这些值为undefined的属性解构提供默认值。默认值可以使任何类型的值：如数值、字符串、函数、对象或者对其他变量的引用等。 [P32 代码1] 默认值在嵌套属性的解构中也可以使用。 [P32 代码2] 当和别名结合使用时，应如下所示，将别名放在前面，默认值放在后面： [P32 代码3] 在解构的模式部分可以使用可计算属性名语法。不过，这种情况下，必须提供一个别名作为变量名。这是因为可计算属性名中允许任意表达式，所以编译器无法推断出变量的名称。下例中，即为使用了别名和可计算属性从character对象中提取出了boots属性。 [P32 代码4] 这一写法并没有什么优势，因为characterBoots = character[type]比{ [type]: characterBoots } = character简单很多。也就是说，可计算属性名声明对象字面量的属性名时很有用，但是在解构赋值中却恰恰相反。 这些就是对象解构的相关内容。那么数组的解构又是怎么样的呢？ 2.3.2 数组的解构数组的解构语法和对象解构相似。下例中，展示了如何将coordinates数组解构成x和y两个变量。可以看到，我们不再是使用花括号，而是使用了方括号，这就表示我们使用的是数组解构，而不是对象解构。使用解构我们能够在不显示引用索引情况下清晰地为数组中的值命名，即不需要使用类似x = coordi nates[0]这样的代码。 [P33 代码1] 使用数组解构时，我们可以跳过不感兴趣或者不需要引用的值。 [P33 代码2] 和对象解构相似，数组解构也可以设定默认值。 [P33 代码3] 在ES5中，当我们需要交换两个变量的值时，通常需要借助第三个临时变量。如下所示。 [P33 代码4] 解构使我们可以不用声明aux变量，而是专注于原本的意图。这也是解构能够使我们的表达更加清晰有效率的一种使用场景。 [P33 代码5] 我们将要讨论最后一个关于解构的内容，即函数的参数。 2.3.3 函数参数的默认值ES6中，函数的参数也能够指定默认值。下面的这个例子中，就为exponent参数定义了一个最常用的默认值。 [P34 代码1] 箭头函数的参数也可以指定默认值。当为箭头函数的参数指定默认值时，哪怕只有一个参数，也要用圆括号将箭头函数的参数列表包裹起来。 [P34 代码2] 和一些其他编程语言不同，默认值不限制只能给函数的最后一个参数设置。可以为任何一个参数设置默认值。 [P34 代码3] 在JavaScript中，向函数传递一个包含多个属性的options对象参数的情况是再常见不过的了。如果使用函数的时候没有传递options，我们可以为其设定一个默认值。具体代码如下所示。 [P34 代码4] 这一方法存在一个问题，如果carFactory的使用者传入了一个options对象，则所有的默认值都会失效。 [P34 代码5] 结合使用函数参数的默认值和解构赋值，能够解决这一问题。 2.3.4 函数参数的解构与只提供一个默认值相比，更好的方法是对整个options进行解构，并在解构模式中，为每个属性都指定默认值。这个方法使我们不通过options对象就能引用options中的每个选项，但我们也因此不能直接引用options，在某些情况下可能会产生问题。 [P35 代码1] 然而，这种情况下，如果使用者没有传入options对象，默认值会再一次缺失。也就是说，如果没有传入options对象参数，carFactory就会报错。如下所示，可以为options添加一个空对象作为默认值，即可避免这一问题。然后这个空对象就会被解构模式中设定了默认值的属性一一填充。 [P35 代码2] 除了默认值以外，我们还可以在函数参数中使用解构来描述函数能够处理的对象结构。参考以下代码，假设有一个car对象，对象上包含多个属性。car对象中描述了它的拥有者、类型、品牌、制造时间以及拥有者购买时的偏好。 [P35 代码3 - P36 代码1] 如果在某个函数中只想提取对象中的某些属性作为参数，则可以通过解构来提前显示地引用这些属性。这样做的好处就是在看到函数声明时，我们就能知道函数中需要使用哪些属性。 当我们提前解构所需要的每个属性时，当输入不正确时，就很容易发现。下例向我们展示了如何在参数列表中指定我们所需的每一个属性，从而表明getCarProductiModel结构方法能够处理的参数对象结构。 [P36 代码2] 除了设置默认值和填充options对象外，解构还有很多其他的有用之处。下面让我们一起来看看。 2.3.5 解构的用法当一个函数返回一个对象或者数组时，解构使我们能够更简洁地处理返回值。 如下例所示，函数返回一个包含一些坐标的对象，而我们只对其中的x和y感兴趣。我们可以不用借助中间变量point，并且不会影响代码的可读性。 [P36 代码3] 默认值的使用会产生一定的重复。假设存在一个random函数，函数会生成一个值在min和max之间的随机整数，默认生成1和10之间的值。在类似Python和C#的强类型语言里，使用这样一种方式来作为命名参数的替代方案是一件特别有趣的事情。这种能够为选项参数定义默认值，并且允许使用者分别覆盖的模式使用起来是非常灵活的。 [P37 代码1] 解构也非常适合用于正则表达式中。解构使我们能够在不使用索引值的情况下命名匹配结果数组中的数据。下面就有这样一个例子：通过正则表达式解析一个简单的日期，并且使用解构将解析出来的值分别赋值给对用的日期组成部分，即年月日等。在本例子中，匹配结果数组的第一个元素是原始输入，所以我们直接丢弃即可。 [P37 代码2] 需要注意的是正则表达式未匹配的情况，这时匹配结果为null。所以如下例所示，最好在解构之前进行错误处理。 [P37 代码3] 接下来我们来关注一下扩展运算符和reset参数。 2.4 剩余参数和扩展运算符在ES6之前，处理任意数量的函数参数必须借助arguments来处理。arguments不是一个数组，但是具有length属性。通常，我们会使用Array#slice.call方法来将arguments对象转换为真正的数组。具体代码如下。 [P38 代码1] ES6中引入了剩余参数，能够更好地方式解决这一问题。 2.4.1 剩余参数在函数的最后一个参数前添加三个点，可以将该参数转变为一个特殊的“剩余参数”。当剩余参数是函数中的唯一一个参数时，它会获取到所有传入函数的参数。这和上述使用.slice处理的结果是一样的，但不需要依赖于arguments，在参数列表中指定即可。 [P38 代码2] 剩余参数之前的参数不会被包含在list参数中。 [P38 代码3] 注意，如果是箭头函数中包含剩余参数，哪怕只有一个参数，也必须放置在圆括号内。否则，会抛出SyntaxError异常。由下例可以看出，结合箭头函数和剩余参数能够写出更简洁的函数式表达式。 [P38 代码4] 可以看出，与上面的代码相比，使用ES5实现相同的函数明显要更加复杂。虽然上面的实现方式较为简洁，但是这样的sumAll函数会对没有使用过.reduce方法的使用者产生困扰，并且同时使用两个箭头函数也会带来一定的困扰。我们将在本书第二部分讨论如何对这种情况进行权衡。 [P39 代码1] 接下来将会学习扩展运算符。它也会用到...，但用法会稍有不同。 2.4.2 扩展运算符扩展运算符可以将可遍历对象转换为数组。扩展运算符能够方便地在数组或者函数调用中展开表达式。下例则在数组字面量中使用...arguments对函数参数进行了转换。 [P39 代码2] 使用扩展运算符可以将一个字符串分割成数组，数组中的元素为组成字符串的每个字符。 [P39 代码3] 扩展运算符的左右还可以添加其他内容，结果正如所期待的那样。 [P39 代码4] 扩展运算符非常适合用来拼接多个数组。如下例所示，可以在数组字面量中展开任意数组，其中的元素会添加到相应位置。 [P40 代码1] 值得一提的是，扩展运算符不仅能用于数组和arguments中，还可以用于任何可遍历对象中。可遍历是ES6中新引入的一种机制，它允许我们将对象转换成可被遍历的内容，我们将在第4章深入讨论这一部分的内容。 shift操作和扩展运算当我们想要从一个数组的开头处获取一个或者两个元素时，通常会使用.shift方法。下面的代码虽然实现了这一功能，但是却难以很快理解，因为代码中使用了两次.shift方法，而每次从数组的开头取到的是不同的值。在ES6之前有很多类似的情况，侧重点往往放在了如何让代码达到我们想要的目的。 [P40 代码2] ES6中，数组的解构和扩展运算符可以结合使用。下面的代码和前面的代码相似。我们仅用一句代码即可实现，并且比重复使用list.shift方法更具表达力。 [P40 代码3] 使用扩展运算符我们可以只关注所要实现的功能，而不用关心语言本身。ES6的很多新特性都能够提高代码的表达力并减少在语言限制上的时间话费。 在ES6之前，当某个函数调用的参数是个动态的参数列表时，我们通常会使用.aplly方法。这么做并不优雅，.apply会改变this的指向，而此时，我们并不希望this指向自身。 [P41 代码1] 除了在数组中使用扩展运算符之外，我们还可以在函数调用中使用扩展运算符。如下例所示，我们可以使用扩展运算符向multiply函数传递任意数值作为参数。 [P41 代码2] 如同上文在数组字面量中一样，在函数调用中扩展参数可以和常规参数一起使用，必要时，可以使用任意多的扩展参数。下例中，调用了print方法，并传入了一对常规参数和一对在参数列表中扩展开的数组。注意，使用剩余参数list能够取到所有传入的参数。扩展运算符和剩余参数可以在不增加代码的前提下，更清晰地展示代码意图。 [P41 代码3] .apply方法还有一个不足，当使用new关键字实例化对象时，会非常冗长。下例中使用new和.apply创建了Date对象。先不管在JavaScript中日期中的月份是从0开始的，即11指12月。除此之外，想一想，为了实例化一个对象，我们向语言做了多少妥协。 [P41 代码4] 如下所示，扩展运算符能够避免这些问题，我们只需要关注最重要的内容。下例的new实例中，在Date函数使用了...来扩展动态的参数列表。 [P41 代码5] 下表总结了上述所讨论的扩展运算符的使用场景。 使用场景 ES5 ES6 数组的连接 [1, 2].concat(more) [1, 2, …more] 将一个数组放入列表中 list.push.apply(list, items) list.push(…items) 解构 a = list[0], other = list.slice(1) [a, …other] = list new关键字和apply方法 new (Date.bind.apply(Date, [null,2015,31,8])) new Date(… [2015,31,8]) 2.5 模板字符串和JavaScript中的常规字符串相比，模板字符串有很大改进。如模板字符串不是使用单引号或者双引号进行声明，而是使用反引号”`”。 [P42 代码1] 由于模板字符串使用反引号作为定界符，在使用模板字符串声明字符串时就不需要再转义其中的&#39;和&quot;。具体示例如下： [P42 代码2] 最值得一提的是，模板字符串中可以插入JavaScript表达式。 2.5.1 字符串插值使用模板字符串，可以在模板中插入任意的JavaScript表达式。当执行到模板字符串表达式时，计算表达式，并将结果返回。下例中，在模板字符串内插入了一个name变量。 [P42 代码3] 前面已经说了，除了变量之外，还可以使用任意的JavaScript表达式。可以将模板字符串的表达式当做是模板执行之前定义的一个变量，执行结果是将各变量和其余字符串连接起来。这么做的好处就是代码更容易维护，不需要再手动将各字符串和表达式拼接起来。不过表达式中所使用的变量、所调用的函数等都必须在当前作用域内可用。 想要在模板字符串中插入怎样的内置表达式逻辑，都取决于自己的编码风格。下面的代码片段在模板字符串中实例化了一个Date对象 [P43 代码1] 同样也可以在模板字符串中插入数学运算。 [P43 代码2] 甚至可以嵌套模板字符串，因为它们也是合法的JavaScript表达式。 [P43 代码3] 模板字符串还有另一个好处，它支持多行字符串。 2.5.2 多行模板字符串在模板字符串之前，如果想要在JavaScript中表示一个多行字符串，必须借助转义符、字符串连接、数组，甚至是借助注释。以下代码总结了ES6之前多行字符串最常见的几种表示法。 [P43 代码4] 在ES6中，可以使用反引号来表示。模板字符串默认支持多行字符串。如下可以看出，代码中不再需要借助\\n、连接符和数组。 [P44 代码1] 在一系列HTML中插入多个变量时，多行字符串非常实用。如果需要在模板中展示一个列表，可以直接遍历这个列表，将对应的内容添加到相应的标签内。如下所示，这么做使得在模板中声明子组件变得非常容易。 [P44 代码2] 上述代码会生出如下所示的HTML结构。可以看到空格被保留下来了[注释 3]，并且通过join方法中的一连串空格，保证了&lt;li&gt;标签正确缩进。 [P45 代码1] 多行模板字符串在缩进方面存在问题。下例中，函数内包含一个模板字符串，模板字符串内的代码有着同样的缩进。期待的结果可能是没有缩进的，但是最后字符串的前面会保留有四个空格的缩进。 [P45 代码2] 可以通过下面的通用函数来将结果字符串中每一行的缩进移除，虽然这么做并不明智。 [P45 代码3] 有些时候，最好是在将插值表达式的结果插入模板之前进行预处理。对于这些更进一步的使用场景，就需要用到另一种模板字符串，即标签模板。 2.5.3 标签模板通常情况下，JavaScript中\\具有特殊的含义，代表转义符。比如，\\n表示换行，\\uoof1表示ñ等。通过String.raw标签模板可以使得转义字符不进行转义。下面代码展示了如何使用String.raw，其中\\n并没有被解释成换行。 [P46 代码1] 模板字符串的前缀String.raw是一个标签模板，用于解析模板字符串。标签模板接受一个数组参数和其他参数，数组中包含模板的每一个静态部分，其他参数对应每个表达式的计算结果。 思考一下以下代码中的标签模板。 [P46 代码2] 实际上，标签模板最终会被解释为如下所示的函数调用。 [P46 代码3] 依次取出模板中的每个部分，并和相邻的表达式拼凑在一起，直到最终拼凑完模板中的所有部分，则为结果字符串。如果不知道默认模板字符串tag内部是如何实现的，参数列表理解起来比较困难。所以我们先学习一下tag的内部实现。 以下代码是默认标签tag的一种可能实现方式。它的功能与不显式指定标签模板进行模板字符串处理时功能相同。它会将parts数组归纳为一个值，以模板的第一部分开头，依次连接values中的值和模板中的内容，最终的值就是模板字符串的计算结果。通过剩余参数语法来获取...values，更便捷地获取了到模板字符串中每个表达式的计算结果，并且还使用了隐式return的箭头函数，这样函数语句看起来更加简单。 [P47 代码1] 可以通过以下代码来试运行上述的tag模板。可以看到，运行结果和不适用tag时相同，这是因为上述代码正是对默认模板行为的实现。 [P47 代码2] 标签模板还有很多其他用法。比如，可以用来将用户输入变为大写。以下代码实现了这一功能。相比与前面的tag，只是做了一些简单的修改，从而使得任意插入的字符串都转为大写形式。 [P47 代码3] 标签模板还有一个更加有用的用法，即可以通过标签模板来保证模板中插入表达式的安全性。假设有一个模板，其中所有表达式都是用户输入的内容，可以虚构一个sanitize库来移除HTML标签和类似的危害，从而阻止用户在网站中注入恶意的HTML，防止跨域脚本攻击(XSS)。 [P47 代码4 - P48 代码1] 看，恶意的&lt;ifram&gt;差点就得逞了。接下来，我们继续学习ES6中的let和const声明。 2.6 let和const声明let声明是ES6中最广为人知的特性之一。它和var声明功能相似，但是它有着不同的作用域规则。 关于作用域，JavaScript有着一套非常复杂的规则集，以致于能弄疯很多初次尝试弄懂JavaScript变量工作原理的程序员。直到知道了变量提升后，才能够逐渐了解。变量提升是指不管变量声明在代码的哪个位置，都会提升到所在作用域的顶部。参考以下示例代码： [P48 代码2] 尽管two是在if代码分支语句中声明的，但它可以在分支语句外访问到，所以上面的代码能够正常工作。这一行为是因为var声明会绑定到所在封闭作用域，如函数作用域或者顶级作用域。结合变量的提升，前面的代码等同于如下所示代码。 [P48 代码3] 不管我们喜欢与否，与使用块级作用域的变量相比，变量提升很让人困惑。块级作用域通过花括号来声明，而不是函数。 2.6.1 块级作用域和let声明通过块级作用域，在现有分支代码语句(如if、for或while)的基础上，嵌套任意新的{}块即可创建更深的作用域，而不需要声明新的函数。只要我们愿意，JavaScript允许创建任意数量的块。 [P49 代码1] 使用var声明的变量是基于词法作用域的，在deep变量声明所在块的外部仍然可以访问到该变量，并不会报错。但在以下几种情况下，如果能够抛出异常会更好： 访问内部变量会破坏代码的封装性 内部变量和外部变量没有任何关联 同级的兄弟块中也可能使用相同的变量名 某个父级块中已经存在名称相同的变量，但是仍需在内部使用该变量。 let声明是var声明的一个替代方案。它遵循块级作用域规则而不是默认的词法作用域规则。使用var时，只能通过嵌套函数来创建更深的作用域。但是使用let时，新增一对花括号即可创建更深的作用域。这就意味着通过{}块即可创建新的作用域，而不需要创建新的函数。 [P49 代码2 - P50 代码1] 123456 // attempts to access innermost here would throw // 在此处尝试访问innermost，会抛出异常// attempts to access inner here would throw// 在此处尝试访问inner，会抛出异常// attempts to access innermost here would throw// 在此处尝试访问innermost，会抛出异常 let声明有一个非常有用的用法，如果在for循环中使用let，则变量的作用域会封闭在循环体内。如下： [P50 代码2] 在循环内声明的let变量会被封闭在每一次的循环内部，哪怕在函数体异步函数调用中使用这些变量也能够像预期一样工作，这一点和使用var声明的变量恰恰相反。一起看一下具体的例子。 首先，看一个关于var作用域工作原理的典型示例。下例中，i变量会绑定到printNumbers函数作用域，在循环添加每个timeout回调时，它的值会一直增加到10。等到每隔100毫秒执行每个回调函数时，i的值就是10，所以每次都会输出10。 [P50 代码3] 相反地，如果使用let声明，会将变量绑定到块级作用域。虽然每次循环仍然会递增变量的值，但是每一次循环中都会创建一个新的绑定。也就是说每次添加timeout回调时，每个回调函数都会持有一个绑定保存当前变量i的引用，所以最终会输出期望中的结果：0到9。 [P50 代码4 - P51 代码1] 除了上面这些内容之外，let还涉及“暂时性死区”这一概念。 2.6.2 暂时性死区毫无疑问：下面这样的代码片段，必然会抛出异常。从作用域的开始，到let声明的执行之前，访问let声明的变量都会报错。这就是所谓的暂时性死区(TDZ，Temporal Dead Zone)。 [P51 代码2] 如果在let name声明执行之前访问该变量，程序会抛出异常。在name变量定义之前，声明一个函数，在函数内引用name变量没问题，只要不在暂时性死区内执行函数即可。在let name声明之前，都是name的暂时性死区。下面的代码并不会报错，因为return name并没有在name的暂时性死区内执行。 [P51 代码3] 相反，下面的代码会报错，因为在name离开暂时性死区之前就访问了name变量。 [P51 代码4] 注意，即使声明时没有对name赋值，上例的结果并不会发生改变。以下代码同样会抛出异常，同样因为在暂时性死区内访问了name变量。 [P52 代码1] 下面的代码能够正常工作，是因为它在离开暂时性死区后才访问name变量。 [P52 代码2] 只有一点需要特别记住，即在函数声明中访问暂时性死区中的变量时没问题的，只要访问暂时性死区中变量的语句在let声明语句之后执行即可。 TDZ的主要目的是为了更容易地捕获错误，防止在用户代码声明变量前就访问变量，从而避免一些不可预期的行为。在ES6之前，由于变量的提升和不良的编码习惯，这一情况是非常常见的。在ES6中能够很简单地避免该问题。要记住提升仍然适用于let，即变量在作用域的开始就会创建，但是会产生暂时性死区，这些变量在声明语句没有执行前无法访问，在离开暂时性死区之后才能够访问。 我们已经学习了暂时性死区，是时候学习const声明了。它与let相似，但是也有很多不同。 2.6.3 Const声明const声明和let相似，都只在块级作用域内有效，也存在暂时性死区。实际上，暂时性死区就是为了const而实现的，之后为了保持统一，也应用在了let上。const之所以需要暂时性死区，是因为如果没有暂时性死区，则可以在const声明执行之前给提升的const变量赋值，这样执行声明语句时就会报错。暂时性死区就是为了保证只在const声明时进行赋值而实现的，可以避免使用let的一些潜在问题，并且使得其他依赖于暂时性死区的特性更容易实现。 由下例可以看出，const和let一样，只在块级作用域内有效。 [P53 代码1] 前面提到let和const有很多不同之处。第一个不同之处就是使用const声明的变量必须在声明时就进行初始化，如下例所示： [P53 代码2] 除了在声明时初始化外，使用const声明的变量无法重复赋值，即const初始化之后，无法再改变它的值。在严格模式下，改变const变量的值会报错。非严格模式下，不会报错，但改变不生效，如下所示。 [P53 代码3] 需要注意的是，创建一个const变量并不意味值所赋的值不可改变。这是一个常见的混淆点，强烈建议仔细阅读以下警告信息。 使用const声明的变量并不是不可变的使用const声明只是意味着所声明的变量会一直持有对同一个对象或原始值的引用，保持不变的只是这个引用。引用保持不变，但是引用所指向值并不是不可变的。 从下例可以看出，尽管people的引用不能被改变，但是数组本身确实可以修改。如果数组是不可变的，不可能产生下面的结果。 [P54 代码1] const声明只会禁止变量绑定到一个新的引用。以下代码从另一方面说明了该问题。使用const创建了一个people变量，然后将这个变量赋值给了一个普通的用var声明的humans变量。我们可以给humans重新赋值其他引用，是因为它并不是使用const声明的。但是我们不能将其他引用赋给people，因为它是通过const声明的。 [P54 代码2] 如果想要确保值不变，可以使用Object.freeze函数。使用Object.freeze可以禁止对传入的对象进行扩展，如下例所示： [P54 代码3] 接下来我们一起讨论下const和let的优势。 2.6.4 const和let的优势永远不要为了使用新特性而使用新特性。ES6特性应该合理应用在能够真正提升代码可读性和可维护性的地方。很多情况下，let声明能够简化一部分代码逻辑，比如当我们需要在函数的顶部进行var声明，从而保证变量的提升不会产生意想不到的结果时，使用let就可以不用在整个函数的顶部进行声明，可以在块级作用域的顶部声明，可以减少思维从作用域顶部开始所延续的范围。 使用const声明能够有效地避免一些问题。以下代码展示一个可能会出错的场景：当我们将items的引用传递给checklist函数，这个函数会返回一个todoAPI用于操作传入的items引用。当items变量被改变，引用指向其他数组时，情况就完全不一样了——todoAPI仍然会从操作items之前引用的值，而items引用了其他的值。 [P55 代码1] 这种问题是很难调试的，可能需要花不短的时间，才能查出引用被改变而导致的问题。如果使用const声明能够防止发生这一错误，因为使用const会在运行时报错（严格模式下），从而能够在问题发生时定位到问题所在。 使用const声明还有一个相似的好处就是能够显示地定义不可重复赋值的变量。const表明变量引用的绑定是只读的，这样我们在阅读代码时就不用关心这些常量了。 如果我们默认使用const来声明变量，使用let来声明需要重复赋值的变量，所有的变量都会遵循相同的作用域规则，会使代码变得更加易于理解。为什么会提议默认使用const声明方式呢，是因为只需要使用它就能达成以下几点目标：禁止重新赋值，遵循块级作用域，并且在变量声明语句执行之前不能访问变量。let语句虽然允许重新赋值，但是它的行为和const类似，所以如果需要一个可以重新赋值的变量可以选择使用let声明。 另一方面，var声明方式更加复杂，如由于函数作用域规则，在分支语句中使用较为困难；并且var允许重新赋值，且可以在变量声明语句执行前访问变量。由于var做的事情并不如const和let多，所以在现代JavaScript代码库中var声明并不常见。 通过本章，我们学习了默认使用const，在需要重新赋值时使用let。第九章我们将会学习更多关于这一选择的原因。 注1 和polyfill一样，ponyfill（https://ponyfoo.com/articles/polyfills-or-ponyfills）是对尚未被所有JavaScript运行环境所支持的功能的用户实现。polyfill主要是试图修补运行环境，从而使某一特性看起来像是原生支持一样，而ponyfill是将运行环境所缺失的功能实现成为一个独立的模块，并且不会污染运行环境。这样做的好处是不会超出第三方库对于运行环境的期望，因为它们可能并不知道我们所使用的polyfill。 注2 Label（https://mjavascript.com/out/label）用于定义指令。可以用在`goto`语句中，用来指明需要跳转的指令；也可以用在`break`语句中，表示所要跳出的序列；还有`continue`语句中，表示想要执行的序列。 [注释 3] 在使用多行模板字符串时，空格并不会被自动保留。不过多数情况下，只需要提供足够多的缩进就能使其保留空格。所以缩进时需要注意，避免在代码块嵌套时产生不正确的缩进。","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://verymuch.com/tags/翻译/"}]},{"title":"第1章 ECMAScript 和 JavaScript 的未来","slug":"第1章-ECMAScript-和-JavaScript-的未来","date":"2017-10-23T10:54:46.000Z","updated":"2018-02-09T12:24:46.000Z","comments":true,"path":"2017/10/23/第1章-ECMAScript-和-JavaScript-的未来/","link":"","permalink":"http://verymuch.com/2017/10/23/第1章-ECMAScript-和-JavaScript-的未来/","excerpt":"JavaScript已经从1995年的一个为了赢得战略性优势的市场营销策略，变成了如今(2017年)世界上最广泛使用的应用运行平台中的核心编程语言。该语言不再是只运行在浏览器中，现在也被用于创建桌面和移动应用、硬件设备中，甚至NASA的太空服设计中。 JavaScript是如何做到这一步的呢，接下来它又该怎么做呢？","text":"JavaScript已经从1995年的一个为了赢得战略性优势的市场营销策略，变成了如今(2017年)世界上最广泛使用的应用运行平台中的核心编程语言。该语言不再是只运行在浏览器中，现在也被用于创建桌面和移动应用、硬件设备中，甚至NASA的太空服设计中。 JavaScript是如何做到这一步的呢，接下来它又该怎么做呢？ 1.1 JavaScript标准简史1995年，网景(NetScape)公司想要构建一个动态的web页面，而这HTML是无法实现的。Brendan Eich最初进入网景就是为了给浏览器开发一个功能类似于Scheme的语言。但在他加入之后，他才发现他的上级主管希望这一语言看起来像Java，而且这一决定已然正在实施。 Brendan花了十天的时间创建了JavaScript的第一个原型，主要采纳了Scheme中的一等公民函数和Self中的原型作为它的主要构成。JavaScript这一初始版本的代号为Mocha。这时，它还没有包含数组或者对象字面量，以及会导致警告的各类错误。异常处理方面的缺失也是为什么到今天仍有很多操作返回NaN或者undefined的原因。Brendan在DOM0和JavaScript初始版本上所做的工作为现在的标准工作奠定了基础。 1995年9月，Netscape Navigator 2.0测试版发布，JavaScript开始与其一起发布，这一版本是JavaScript的修订版，被命名为LiveScript。同年12月，当Navigator 2.0 beta 3发布时，又被重新命名为JavaScript(由Sun注册商标，现在被Oracle持有)。此后不久，网景公司推出了服务端JavaScript的实现，用于在网景企业服务器中运行脚本，并将其命名为LiveWire[注释 1]。1996年，由微软通过逆向工程技术实现的JavaScript版本——JScript，与IE3一起发布。JScript也可以用于Internet Information Server(IIS)的服务端。 1996年，该语言由ECMA的TC39技术委员会标准化为ECMA-262规范，并命名为ECMAScript(ES)。一方面，Sun公司不同意将JavaScript商标转让给ECMA；另一方面，虽然微软提供了JScript，但是其他成员公司并不想使用该名称。因此，使用了ECMAScript这个名字。 当时，有关于网景JavaScript和微软JScript实现差异的讨论几乎占用了整个TC39标准委员会议的大部分时间。尽管如此，委员会还是取得了成果：向后兼容被定为黄金准则。比如，引入严格相等运算符(===和!==)，而不影响依赖松散相等比较算法的现有程序。 ECMA-262的第一版在1997年6月发布。次年六月，该标准经过国际ISO机构的诸多严格审查，在ISO/IEC 16262国际标准下进行了完善，并正式化成为第二版。 1999年12月，第三版发布。该版本对正则表达式、switch语句、do/whille、try/catch、Object#hasOwnProperty以及一些其他改变进行了标准化。这些功能中的大部分功能在网景的JavaScript运行环境SpiderMonkey中都已经可以使用了。 之后不久，TC39发布了ES4规范的草案。ES4的早期工作促使了2000年年中JScript.NET的产生，并最终在2006年促使了Flash中ActionScript 3的产生。 关于JavaScript应该如何向前推进难以达成统一的观点，这就导致规范工作停滞不前。对于Web标准来说这是一个很微妙的时刻：微软几乎垄断了整个Web行业，但是他们对于制定标准却毫无兴趣。 2003年，AOL裁掉了50名网景员工[注释 4]，Mozilla基金会因此成立了。同时，由于微软占据了超过95%的网络浏览市场份额，TC39 被迫解散。 直到两年后，Brendan在Mozilla以Firefox日益增长的市场份额为杠杆使得微软回归，ECMA才得以重新开始TC39的相关工作。2005年年中，TC39再次开始召开定期会议。对于ES4，计划引入模块系统、类、遍历器(Iterator)、生成器(Generator)、解构赋值、类型注释、尾调用优化、代数输入以及其他各类功能。由于这一项目太过庞大，导致了ES4的规范工作一次又一次的推迟。 2007年，委员会主要有两种立场：一部分人主张规范ES3.1，这一版本只是在ES3的基础上新增更多的方法；另一个立场则是主张规范ES4，虽然这部分内容则是过度设计并且有一定不足之处的。直到2008年[注释 5]，如前所提ES3.1才讨论通过，之后更名为ES5。尽管ES4最终被废弃了，除了其中一些仍在考虑以及很少的被废弃的功能，其中的很多功能都最终加入到了ES6中(ES6在决议时的代号是Harmony)。ES3.1中更新的内容，是ES4能够逐渐实现的基础。 2009年12月，ES3发布十周年，ECMAScript第五版发布。这一版本对于该语言规范进行了更实用的扩展，使得该语言规范在浏览器中得到了普遍的实现。这一版本主要增加了get和set存取器、Array原型中的函数扩展、反射机制和内省机制以及原生支持JSON解析和严格模式。 两年以后，2011年6月，该规范再一次进行了审查和编辑，形成了第三版的国际标准ISO/IEC 16262:2011，并正式化为ECMAScript5.1。 之后TC39又用了四年的时间来规范ECMAScirpt 6，并于2015年6月发布。第六版是该语言发布以来改动最大的一次，这一版本实现了许多ES4中被推迟到Harmony决议中的提案。通过本书，我们将深入探讨ES6。 在ES6进行规范化的同时，2012年，WHATWG(一个旨在推动web发展的标准组织)开始着手记录ES5.1和浏览器实现在兼容性和可操作性方面的差异。这一工作促成了String#substr的标准化，这一方法之前并不明确；统一了在HTML标签中包装字符串的几种方法，这些方法在不同的浏览器中是不一致的；并在Object.prototype上新增如__proto__和__defineGeter__等属性以及其他改进[注释 6]。这些工作最终形成了一份独立的Web ECMAScript规范，最终在2015年中被加入到附录B当中。附录B是ECMAScript规范核心中的建议部分，浏览器可以不遵照其进行实现。与此次geng新一起，附录B也成为了web浏览器的规范和要求。 第六版是JavaScript历史上一个意义重大的里程碑。除了成打的新功能之外，ES6也是ECMAScipt成为一个频繁更新的滚动标准的主要标志。 1.2 滚动标准ECMAScript在ES3之后，花费了十年的时间，但语言规范却并没有重大改变；之后又用了四年才形成ES6。显然，TC39的会议流程需要改善。之前的修订流程通常是期限驱动的。任何内容延迟达成一致，都会使得修订过程等待很长一段时间，这就会导致特征蠕动，进而引起更多的推迟。规范中一些较小的改动常常因为较大的新增内容而推迟。因此为了不再推迟，较大的新增内容在完成前需要承受很大的压力。 随着ES6的发布，TC39对提案修订的流程进行了优化[注释7]，使得它能够满足现在的预期：更快更一致的迭代，使得规范的开发更加大众化。基于这一点，TC39不再采用古老的书面提案形式，而是使用Ecmarkup(用于格式化ECMAScript规范的HTML语法超集)和GitHub来提交需求，大大增加了非会员的提案数量[注释 8]，他们就像是外在的参与者一样。这种新的形式是持续的，并且也更加透明：最新的规范草案随时都能够看到，而不是像之前那样，必须到网页上去下载Word文档或者PDF版本。 Firefox、Chrome、Edge、Safari以及Node.js对于ES6规范的支持均已超过95%[注释 9]。我们已经可以在这些浏览器中使用这些已经支持的功能，而不用等到它们对ES6的支持度达到100%才能使用。 新的流程引入了四个不同的成熟度阶段[注释 10]。越成熟的提案，最终被添加到规范中的可能性越大。 任何关于修改或者新增内容、还没有被提交为正式提案的讨论、想法或者提案都被认为是一个有雄心的“稻草人”提案(即stage 0)，不过只有TC39委员会成员可以创建稻草人提案。在写本书的时候，大概有十多个活跃的稻草人提案[注释 11]。 第一阶段表示提案被正式提出，并被期望解决交叉问题、和其他提案的交互问题以及实现上的问题。这一阶段的提案需要定义一个独立的问题，并给出该问题的具体解决方式。第一阶段的提案常常包括以下几方面的内容：高级API描述、说明性的用法示例、内部语法和算法的讨论。第一阶段提案可能会随着过程的不断进行发生很大的改变。 第二阶段的提案提供了规范的初始草案。从这时开始，就可以开始在运行环境中尝试具体的实现了。实现的方式可以采用补丁(polyfill)的形式，一种能使得运行环境支持提案内容的用户代码；也可以是一种引擎实现，原生地为提案内容提供支持；或者是使用构建工具将源代码转换，编译成现有引擎可以执行的代码。 第三阶段提案则是候选推荐。只有规范的编辑和指定的审查人员在最终的规范上签字确认，提案才能进入第三阶段。实现者也需要对该提案感兴趣才行。实际上，一个提案只有在满足下面三个条件之一时才能进入第三阶段：某个浏览器已经实现、高度可用的补丁或者在类似于Babel的实时编译工具中已经得到支持。第三阶段提案除了修复使用过程中新发现的问题外，不会再有其他的改动。 一个提案想要进入第四阶段，则必须有两个独立的实现方案能够通过验收测试。进入第四阶段的提案，最终会添加到ECMAScript的下一版当中。 该规范预计从现在开始每年发布都发布新版本。为了和年度发版计划统一，规范的版本从现在开始与出版的年份相关联。因此，ES6也是ES2015，之后将有ES2016而不是ES7，以及ES2017等等。实际上，ES2015这个称呼并没有被接受，仍被称为ES6。ES2016也是在命名约定改变之前就发布了的，因此有时候它也指ES7。因为ES6这一名称在社区中已经普遍被接受，我们抛开不谈，最终的规范版本将会是：ES6，ES2016，ES2017，ES2018等。 调整后的提案流程加上每年都进行时标准化形成了一个更加一致的标准发版过程，并且这也意味着规范的修订版本号变得不再那么重要。现在的重点是提案阶段，并且我们可以期待ECMAScript标准特定修订的引用变得更加不寻常【李老师重点关注语句】。 1.3 浏览器支持和辅助工具如果能够在JavaScript引擎中提供两种独立的实现方式，第三阶段的候选推荐提案最有可能在下一个版本加入到规范之中。实际上，通过实验性的引擎实现、补丁或者使用编译器，第三阶段的提案已经能够安全地在实际应用程序中使用了。其实第二阶段和更早阶段的提案也已经被JavaScript开发人员使用，这也加强了实现者和使用者之间的反馈循环。 Babel和类似的编译器，将代码作为输入，生成web平台(HTML、CSS或JavaScript)原生支持的输出。这些编译器通常被称为转换器，即编译器的一个子集。如果我们想要在代码中使用一个JavaScript引擎还没有普遍实现的提案，则Babel之类的编译器可以将使用了新提案的部分代码转换成现有JavaScript实现已经广泛支持的代码。 转换的过程可以在构建时进行，这样使用者可以得到所选JavaScript运行环境所支持的代码。这一机制改善了运行环境的支持基线，使得JavaScript开发者能够更早地利用新的语言功能和语法。这对于规范的编写者和实现者来说也是非常有利的，因为这样使得他们可以收集诸如可行性、渴求性以及可能存在的bug或者边界用例等方面的反馈。 编译器可以将我们所写的ES6源代码生成浏览器可以更加一致性解释的ES5代码。这是现在在生产环境中运行ES6代码的最可靠方式：通过编译生成ES5代码，这样大多数旧浏览器也能和现代浏览器一样正常执行。 这个方法同样适用于ES7及其之后的版本。因为语言规范将每年都会发布新版本，那么我们可以期待编译器能够支持ES2017输入、ES2018输入等等。同样地，随着浏览器的支持度越来越好，编译器可以逐渐降低为了支持ES6输出的复杂性，然后是ES7及其之后的版本。从这种情况来说，我们可以将JavaScript编译器看成一个移动的窗口，输入使用语言中最新可用的语法编写的代码，生成不影响浏览器支持的最新代码。 接下来，我们讨论一下如何在工作中使用Babel。 1.3.1 Babel编译器简介Babel可以将基于ES6特性的现代JavaScript代码编译成ES5代码。当我们使用的新特性还没有完全支持时，编译器更加受欢迎，因为它能够让我们写出可读性更高的代码。 Babel的在线REPL(读取-求值-打印 循环)转换器是一种很好的学习ES6的方法，而不需要经历安装Node.js和babel CLI、手动编译源码等任何麻烦。 REPL提供了一个源代码输入框，可以自动实时编译，编译后的代码在源代码的右侧。 现在我们在REPL中输入一些代码，你可以使用下面的这个代码片段： 123var double = value =&gt; value * 2 console.log(double(3))// &lt;- 6 如下图1-1所示，在输入的源码的右侧，我们能够看到转换后的ES5等价代码。源码更新后，编译结果也会实时更新。 Babel REPL是一个有效的工具，可以通过它来尝试书中介绍的一些特性。不过，需要知道的是Babel并不转换新的内置对象，如Symbol、Proxy和WeakMap。这些引用会被原封不动地保留下来了，依赖于执行Babel输出的运行环境提供这些内置对象。如果我们想要支持还没有实现这些内置对象的运行环境，我们可以在代码中引入babel-polyfill包。 在一些较老的JavaScript版本中，这些特性在语义上正确地实现很难，甚至完全不可能实现。补丁可能能够缓解这一问题，但是它们通常不能覆盖所有情况，因此需要做一些妥协。所以在我们将转换后的使用了内置对象和补丁的代码发布到生产环境时，我们需要很小心并且测试我们所假设的内容。 基于这种情况，我们最好等到浏览器整体支持这些新的内置对象时再开始使用它们。所以，建议大家使用不依赖于这些新内置对象的替代方案。同时，学习这些特性也是很重要的，这样我们对于JavaScript语言的理解才不会落后。 诸如Chrome、Firefox和Edge等现代浏览器现在已经支持ES2015及之后版本的大部分内容，所有当我们试着运行某个浏览器已经支持的新特性语法时，它们的开发者工具很好用。当生产级应用需要依赖于新的JavaScript特性时，推荐使用转换器进行编译处理，这样应用能够支持更多的JavaScript运行环境。 除了REPL，Babel还提供了一个Node.js的命令行工具包。你可以通过Node.js的包管理工具npm来安装。 下载Node.js。安装node后，就可以在终端内使用npm命令了。 开始之前，我们先创建一个项目目录以及一个package.json文件。package.json是一份描述Node.js应用的清单。我们可以通过npm命令行创建package.json文件。 123mkdir babel-setupcd babel-setupnpm init --yes 执行init命令时传递--yes参数表示不用询问我们，同意使用npm提供的默认值配置package.json文件。 同样，我们再创建一个example.js文件，并在其中加入以下代码，将其保存在刚刚创建的babel-setup下的src子目录中： 123var double = value =&gt; value * 2console.log(double(3))// &lt;- 6 在我们常用的终端中，输入下面两行命令可以安装Babel： 12npm install babel-cli@6 --save-devnpm install babel-preset-env@6 --save-dev 通过npm安装的包存放在项目根目录的node_modules目录下。可以通过创建npm script命令或者使用require声明来访问这些包。 --save-dev参数会将所安装的包作为开发依赖添加到package.json文件中。这样一来，当我们将项目移植到一个新的环境时，可以仅仅通过运行npm install命令就重新安装每个依赖。 @符号指明我们想要安装的包的特定版本。使用@6则是告诉npm安装babel-cli的6.x版本中最新的一个。这种优先策略对于我们的应用在将来不出问题是有好处的。因为这样一来，将永远不会安装7.0.0或者之后的版本。因为7.0.0之后的版本可能会包含一些在撰写本文时无法预见的破坏性变化。 接下来，我们用下面的值替换package.json中scripts属性。babel-cli提供的babel命令行功能可以将src目录下的全部内容，编译成所需的输出格式，并且将结果保存到dist目录，并且保留文件在原始目录中的结构： 12345&#123; \"scripts\": &#123; \"build\": \"babel src --out-dir dist\" &#125;&#125; 加上在之前各步骤中安装的包，一个最小的package.json文件看起来如下面的代码片段所示： 123456789&#123; \"scripts\": &#123; \"build\": \"babel src --out-dir dist\" &#125;, \"devDependencies\": &#123; \"babel-cli\": \"^6.24.0\", \"babel-preset-env\": \"^1.2.1\" &#125; &#125; scripts对象中列举的所有命令都可以通过npm run &lt;name&gt;来执行，通过这种方式执行会临时修改环境变量$PATH的值，因此我们才可以在没有在系统上全局安装babel-cli的情况下，找到babel-cli并在命令行执行。 如果你现在在终端内执行npm run build，你就能看到生成后的dist/example.js文件。输出的文件和我们的源文件是完全相同的。这是因为Babel并没有做任何的假设，所以我们需要事先配置它。在package.json之后创建一个.babelrc文件，并在其中写入以下JSON数据： 123&#123; \"presets\": [\"env\"]&#125; 前面我们通过npm安装的env预设向Babel之中添加了一系列的插件，从而可以将不同的ES6代码转换为ES5。这个预设包含很多内容，可以将类似example.js中所用的箭头函数转换成ES5的代码。通常情况下，Babel的env预设会开启最新的浏览器已经支持的特性相关转换插件。这一预设是可配置的，这意味着我们能够决定要覆盖多久之前的浏览器支持度。支持的浏览器越多，我们的编译包就越大。支持的浏览器越少，我们的用户满意度就越低。一如既往，研究的本质是确定对于Babel的env预设来说什么是正确的配置。默认地，每一个转换都会被开启，从而支持更多的运行环境。 现在如果我们再一次运行编译脚本，能够看到输出的是有效的ES5代码。 123456789» npm run build» cat dist/example.js\"use strict\"var double = function double(value) &#123; return value * 2&#125;console.log(double(3))// &lt;- 6 下面我们来学习一个不同种类的工具，代码检查工具eslint，可以帮助我们在应用项目中形成高质量的代码标准。 1.3.2 使用ESLint提高代码质量和一致性当我们开发一个代码库时，我们会分解那些冗余的或者没用的代码片段，编写新的代码片段，删除不再相关或必要的功能，并在兼容新的架构时进行代码块迁移。随着代码库的增长，编写代码库的团队也会随之改变：刚开始时可能只是几个人甚至只有一个人，但是随着项目规模的扩大，团队也会越来越大。 代码检测工具可以用来标识语法错误。现代的检测工具多是可定制的，可以帮助我们建立一个适用于团队中所有人的代码风格约定。通过坚持一致的代码风格和质量基准，可以使得团队在编码风格方面更加接近。不同的团队成员对于代码风格可能会有不同的意见，但是只要我们将代码检测工具用在合适的地方，并且意见上达成一致，则所有这些观点都可以被浓缩为风格规则。 除了确保程序能被解析，我们也可能想要防止throw抛出字符串字面量作为异常，或者不允许在生产环境中使用console.log和debugger语句。然而，要求必须所有的函数调用都必须只能有一个参数的规则可能就太过严厉了。 虽然代码检测工具能够很好地定义并且强制实行一种编码风格，但我们在定义规则集合时应该谨慎一点。如果检测过程太过严格，开发者可能会因为生产力受到影响而感到挫败。如果检测过程太过松散，可能在我们的代码库中就难以形成统一的编码风格。 为了能够把握好这个度，我们可以尽量避免那些即使用了在大多数情况下也不能改善程序的风格规则。每当我们想要新增一条规则时，我们应当扪心自问，加了它之后能否显著地改善现有代码库以及未来的新代码。 ESLint是一个现代代码检测工具，它集合了一些插件、有不同的规则，允许我们选择想要实行的规则。我们可以决定如果不遵守这些规则，是否在输出内容中输出一个警告，或者一个禁止错误。就像在之前的章节中安装babel那样，通过npm就可以安装eslint： 1npm install eslint@3 --save-dev 接下来，我们需要对ESLint进行配置。既然我们安装了eslint，并将其加入了本地依赖，那么我们能够在node_modules/.bin中找到它的命令行工具。在项目中首次进行ESLint配置时，执行以下命令能够指导我们进行配置。一开始，指明使用一个流行的规则指南，并且选择标准规则指南[注释 12]，最后选择JSON格式的配置文件： 12345./node_modules/.bin/eslint --init? How would you like to configure ESLint?Use a popular style guide? Which style guide do you want to follow? Standard? What format do you want your config file to be in? JSON 除了独立的规则，eslint允许我们使用打包成Node.js模块的预定义规则集。这样在多项目甚至社区中共享配置就会很方便。选择标准规则指南后，我们能够看到ESLint向package.json中添加了一些依赖，即定义了预设标准规则集的包；然后创建了一个名为.eslintrc.json文件，包含以下内容： 1234567&#123; \"extends\": \"standard\", \"plugins\": [ \"standard\", \"promise\" ] &#125; 关于npm引用node_modules/.bin目录下的命令及如何工作的实现细节，不在本文的讨论范围之内。虽然我们在初始化ESLint配置时使用了这一引用命令，但没必要一直使用这一引用命令，同样也没必要在每次检测代码库时都重新输入。可以将下面代码片段中的lint脚本加入到packge.json中，从而避免重复输入引用命令： 12345&#123; \"scripts\": &#123; \"lint\": \"eslint .\" &#125;&#125; 在之前的Babel有提到，npm run命令在执行script脚本时会将node_modules加入PATH环境变量。所以想要检查我们的代码库，可以执行npm run lint，然后npm会在node_modules目录中找到嵌入在其中的ESLint CLI。 思考一下下面的example.js文件，其内有着人为的代码风格问题，从而用来演示ESLint具体做了什么： 123456var goodbye='Goodbye!' function hello()&#123; return goodbye&#125; if(false)&#123;&#125; 如下图1-2所示，当我们执行lint脚本命令时，ESLint会标识文件中所有错误的地方。 如果在执行命令时传递--fix参数，ESLint能够自动修复大多数的风格问题。在package.json中加入以下脚本： 12345&#123; \"scripts\": &#123; \"lint-fix\": \"eslint . --fix\" &#125;&#125; 如果我们执行lint-fix，将只会得到两个错误：hello未使用和false是个不变的条件。其他的错误都已经被修复了，结果如下面的代码所示。这些仍然存在的错误之所以没有被修复，主要是因为避免对代码进行假设，并且不倾向于引起语义变化。鉴于ESLint所做的这些工作，--fix是一个很有用的工具，它能够解决代码风格问题，而不会存在导致程序破坏的风险。 1234567var goodbye = 'Goodbye!'function hello() &#123; return goodbye&#125;if (false) &#123;&#125; 还有一种类似的工具——prettier，它也可以用来自动格式化代码。Prettier可以配置自动重写我们代码，从而确保代码遵照我们设定的首选项，如使用给定的空格缩进、单引号或者双引号、尾逗号或者最大行长度。 现在我们已经知道了如何将现代Javascript代码编译成每一个浏览器都能理解的代码，以及如何正确检查和格式化我们的代码，接下来我们来学习ES6的特性主题和JavaScript的未来。 1.4 ES6特性主题ES6非常庞大：ES6语言规范的页数是ES5.1规范的两倍多，ES5.1是258页，而ES6高达566页。规范中的各个更新可以归纳为以下几个不同的类别： 语法糖 新的机制 更好的语义 更多的内置对象和方法 不打破现有限制的解决方案 语法糖是ES6中最重要的驱动因素之一。新版本中提供了很多简洁的方式，如使用新的Class语法来表达对象的集成；使用箭头函数作为函数的缩写语法；对于属性可以使用属性值缩写。还有其他一些特性我们将要讨论，如解构赋值、rest参数以及扩展运算符，也提供了一种更加语义化的编程方式。第二章和第三章会介绍ES6中的这部分内容。 ES6提供了一些新的机制用来描述异步代码流程，如Promise，代表一个操作的最终结果；Iterator代表一序列的值；Generator一种特殊的迭代器，能够生成一系列的值。在ES2017中，async/await则是构建在这些新概念和结构之上的，让我们可以像编写同步代码一样编写异步代码。我们会在第四章介绍这里提到的所有迭代器以及流控制机制。 在JavaScript中有一种常见的做法，即开发者使用普通的对象创建一个带有任意字符串键值的散列映射。如果我们不够小心，并且允许用户输入最终定义这些键值，那么就可能导致产生漏洞。ES6引入了一些新的原生内置对象来管理集合和映射，并且没有只能使用字符串键值的限制。这一系列的内容将在第九章介绍。 代理对象(Proxy)重新定义了可以通过Javascript Reflect对象完成的操作。代理对象和其他语境中所提到的代理类似，比如网络流量路由中所说的代理。它可以拦截JavaScript对象的任何交互，比如属性的定义、删除以及访问。鉴于代理的工作机制，很难全面地对其实现补丁：当然补丁是有的，只是在某些用例下会与规范不符。我们将在第六章讲解代理。 除了一些新的内置对象，ES6还对Number、Math、Array以及String对象进行了一定的扩展。在第七章，我们将介绍一系列添加在这些内置对象上的新实例方法和静态方法。 JavaScript将原生支持一个新的模块系统。第八章中，在讲解完Node.js中使用的CommonJS模块格式之后，我们将详细讲解予以厚望的原生JavaScript模块语义。 由于ES6引入了相当多的修改，所以很难将其新特性与现有的JavaScript知识相结合。我们将通过第九章整章来分析每个不同的特性的优点和重要性，这样你对于ES6就能有一定的实践经验，基于此你可以立刻开始使用ES6。 1.5 JavaScript的未来JavaScript语言已经从1995年一门没啥名气的语言发展成为了今天这样一门强大的语言。虽然ES6已经有了很大的进步，但是这远远不是终点。鉴于每年都会有新的规范发布，那么如何保持对最新规范的了解是很重要的。 在1.2小节中，我们学习了滚动标准规范的开发过程。时刻跟进标准的最好方式之一就是定期访问TC39提案库[注释 13]。时刻关注一下候选推荐提案(即第三阶段提案)，因为这些提案最有可能加入到规范中。 鉴于标准化过程的滚动特性，在一本书中描述一门不断变化的语言是富有挑战的。想要时刻跟进最新的JavaScript更新，最有效的方式是关注TC39提案库，订阅电子邮件新闻周刊[注释 14]，并阅读JavaScript博客[注释 15]。 在撰写本书时，期待已久的Async函数已经加入规范，并在ES2017中发布。当时，有很多候选提案，比如动态import()，支持动态加载原生JavaScript模块；以及使用新的rest和扩展运算符语法描述对象属性枚举，它们在ES6中首次引入，用于参数列表和数组之中。 虽然本书的主要关注点是ES6，但我们也同样会学习重要的候选推荐，比如：之前提及的Async函数，动态import()调用，对象rest/扩展以及其他内容。 [注释 1] 1998年的这本手册详细讲解了关于服务端JavaScript以及LiveWire的复杂之处。 [注释 2] 在微软的网站上可以找到最初的公告(2000年6月)。 [注释 3] 收听Brendan Ecih的播客，能够找到关于JavaScript起源的内容。 [注释 4] The Mac Observer有该新闻的报道(2003年7月)。 [注释 5] 2008年，Brendan Eich给es讨论邮件组发送了一封邮件，在其中概括了会议情况，此时ES3已经发布了近十年。 [注释 6] 对于在将Web ECMAScript规范合并到主干时所做的全部更改，请参阅WHATWG博客。 [注释 7] 可以查看2013年的这一公告——公告 - ES6 规范流程，公告指出了优化后的提案修订流程。 [注释 8] 点击查看被TC39采纳的所有提案 [注释 9] 点击查看ES6的浏览器兼容性详情列表 [注释 10] 点击查看TC39的提案流程文档说明 [注释 11] 点击查看稻草人提案 [注释 12] 注意，Standard是指一种自我宣告，并未由任何官方组织进行实际的标准化。其实，只要能够保持统一，使用哪种风格并不重要。在阅读项目代码库时，一致性有助于减少困扰。Airbnb风格指南也是很受欢迎，和Standard不同，它默认不可省略分号。 [注释 13] 点击查看TC39收录的所有提案 [注释 14] 有很多类似于Pony Foo周刊和Javascriot周刊的新闻刊物。 [注释 15] Pony Foo上有很多关于ECMAScript开发的文章，Axel Rauschmayer也写了很多关于这方面的文章。","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://verymuch.com/tags/翻译/"}]},{"title":"跟扎克伯格学习提高工作效率","slug":"跟扎克伯格学习提高工作效率","date":"2017-02-11T03:44:27.000Z","updated":"2017-12-14T06:31:06.000Z","comments":true,"path":"2017/02/11/跟扎克伯格学习提高工作效率/","link":"","permalink":"http://verymuch.com/2017/02/11/跟扎克伯格学习提高工作效率/","excerpt":"前言 几天前看到了这样一篇文章《鸡年上班的第一天，扎克伯格的26张PPT帮助你提高工作效率，把握“鸡”会》。然后不知道扎克伯格的童靴，我相信做技术的应该都知道的。","text":"前言 几天前看到了这样一篇文章《鸡年上班的第一天，扎克伯格的26张PPT帮助你提高工作效率，把握“鸡”会》。然后不知道扎克伯格的童靴，我相信做技术的应该都知道的。 文章开篇就对扎克伯格进行了介绍——全球最年轻亿万富豪宝座的Facebook创始人马克·扎克伯格。当然这样的标题能够够吸引人查看，因为我们相信优秀的人都是值得学习。不过对于我，我觉得只要是优秀的习惯不管是在谁的身上都是值得学习的。 只看了几页简单的文字PPT，我就不得不佩服，成功人士的经验确实是非常值得学习的。他们或多或少都有一些自己的“成功秘诀”，有一些习惯也许会适合于迷茫中的你和我。 文中给出了26张PPT，之前也没有太认真研究，今天就一边看，一边附上自己的想法，激励自己。 1. 时间常有，时间在于优先。 每天的时间都是固定的，所以我们要把时间用来做有意义的事情。每个人对于有意义的事都有一个定义，但是不管如何在每个人的心里，想要做的事情都会有一个先后顺序或者说重要程度。所以不管是每天的任务还是长期的计划，充分利用自己的时间，并且不能避重就轻，要先完成重要的事情。 马克的第一页PPT中也给出了对比，可能你想做的事情时享受生活，但是你要有享受生活的能力。所以你需要去实现自我，去努力工作，而工作和娱乐相比，则工作是你更应该去做的并且有意义的事情，虽然娱乐来的更舒服，要知道舒适使人丧失斗志，要打破自己的舒适区，挑战自己，成就更好的自己。 2. 每天都会很充实：只需要计划4-5小时用来工作就好 每天都会过的很足，用这句话来说，是想说，不管你一天干什么，你都会过足24小时，只是不同的人的不同的24小时带来的感觉并不相同而已。 当然，这么说并是让大家自己想怎么过就怎么过。而是想说，一天的时间很短，有很多有意的事情需要我们去做，不要把时间都花在工作上。每天真正花在工作上的时间有4-5小时就很好了。 一方面，花费远超于这些的时间在工作上，可能效率并不好，而且会使人疲惫；另一方面，把太多的时间花在工作上，将没有时间让你来做其他有意义的事情，而其他事情也会帮助你更好地工作，如锻炼来的一个健康的身体，学习来的更好的个人能力等等。 所以要合理安排工作时间，把握好自己的时间，过足自己的每一天。 3. 跟着状态走 状态这个东西特别。有的时候你会一点都不在状态，有的时候又非常在状态，就跟打了鸡血似的，天天能忙活12个小时。所以在状态的时候，就可以多干点活；不然的话就好好休息，这样才能更快的调整好自己的状态。 4. 重视自己的时间，并使其值得重视 “你的时间值1000美元/小时，你得行动起来！” 是的，你的时间是有价值的，要认清自己时间的价值，不要去荒废自己的时间，重视起自己的时间。 我要对自己说：“你的时间也要小一百一小时呢，你要重视起来，你每浪费一个小时就浪费100大洋，重视起来吧，好好利用自己的时间，还能够提升自己，加油!” 5. 一次专注一个任务 不要一次进行多个任务，这只会消耗我们的注意力。保持专注，一心易用，这样才能够提高效率。 当自己想要转移注意力的时候一定要严厉地提醒自己。 6. 养成并适应习惯 养成良好的工作习惯，并持之以恒，你的身体会适应的。 是的，不管是生活上的习惯还是工作上的习惯或者说是学习上的习惯，只要是坚持成为习惯了，一切做起来都不再会那么困难。就想之前每天陪媳妇早睡早起觉得很难，但是慢慢调整之后就适应了，也能体会到规律作息的好处。每天早上能够多出两个小时的个人时间，可以用来学习、整理与安排等。 所以养成一个良好的工作习惯，坚持下去，你会越来越好的。 7. 当限定时间做某件事情时，我们往往更加专注并且有效率 我想大家都切身经历过，当一件事情没有最后时限时，我们可能一拖再拖，一直没有紧迫感，而不去完成它。而当这件事情有着最后期限时，我们往往会更加优先、更加专注、更加有效率地完成它。 所以日常生活里，自己安排的事情可能并没有给自己设定期限，那么试一试给自己要做的事情设置个时间限制，去看看自己是不是能够更好更快的完成。 8. 进入工作状态的最佳方式就是工作 进入工作状态最好的方式就是工作，可以先从简单的工作任务开始，由此进入工作状态，然后再按照重要程度、优先级，来完成自己的工作安排。 9. 做完事情，要胜于完美收工 迭代工作，期待完美收工会令人窒息：“做完事情，要胜于完美收工” Facebook 办公室墙壁上贴的箴言。动手做，胜过任何完美的想象。 大多数都有着这样一个缺点，觉得有些事情需要自己去做，但更多的是只是口头说说，纸上写写却并没有真正去做。这就是人的惰性。想到要做的事情，就立马执行起来，如果优先级不够，就先记录下来，然后在需要做的时间去做。不要嘴上说说，让自己动起来。 10. 凡事有个度 凡事要有个度，工作时间越长并不意味着效率越高。要把握好这个度，劳逸结合，才能让自己的续航能力更强。so 该工作的时候好好工作，该休息的时候也要好好休息，该锻炼的时候更要好好锻炼。 11. 分类工作（执行类和思考类），提高效率 工作的时候，将工作清除的分为两类：执行类和思考类。这样在思考的时候能够更好地思考，在执行的时候能够更快的执行，从而提高自己的工作效率。因为思考和执行的过程如果被打断，需要付出更多的时间。 12. 有会议今早安排 有会议就尽早安排，用于准备会议的时间往往都浪费掉了。这个我还没有经验，不过想想是很有道理的。每次周会的下午往往都是浪费了的。 13. 创造不间断工作时间 把会议和沟通 (邮件或电话) 结合，创造不间断工作时间：一个小会，也会毁了一个下午，因为它会把下午撕成两个较小的时间段，以至于啥也干不成。PS：当看到一个程序员冥思苦想时，不要过去打扰，甚至一句问候都是多余的。 对自己说：不要自己碎片化自己的时间，集中注意力。 14. 一天保持相同的工作环境 一整天保持相同的工作环境。在项目/客户之间切换，会效率低。 还没有跟客户对接过的我好像并不懂。 15. 工作—放松—工作=高效(番茄工作法) 番茄工作法是弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。 使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。 对自己说：“利用已有的方法论，提高自己的效率”！ 16. 分割任务 把不切实际的任务分割成合理的小任务，只要每天都完成小任务，你就会越来越接近那个大目标了。 和年度目标细化成执行清单一样，朝着目标一步一步，一点一点地去完成目标的一部分，你会发现完成一个大目标是那么容易。 不要觉得一件事情很难就不去做了，知难行易，也许只是你觉得它很难，但是真正做起来就回变得简单。 17. 确认优先级 从来没有两个任务会有相同的优先级，总会有个更重要，仔细考虑待办事情列表。 每次专注于一个任务，而且要挑选重要的任务来做，不要避重就轻。 18. 一定要完成那件影响最大的事情 必须清楚白天必须完成的那件事，是什么。请确认好事情的优先级，一定要完成影响最大的那件事情。 19. 拆分任务 把任务按时间分段，就能感觉它快被搞定了。 长得任务总是让人感觉很难完成，但是分成一个个的小阶段去完成，你会发现事情变的简单很多。 20. 擅用他人的力量 授权并擅用他人的力量。—君子善假于物(人)也，如果某件事其他人也可以做到八成，那就给他做！ 虽然我还没到这一步，但是要提前有这种意识。 21. 好汉不提当年勇 把昨天翻过去，只考虑今天和明天。昨天的全垒打赢不了今天的比赛。—好汉不提当年勇。 22. 给事情设限 给所有事情都设定一个期限。不要让工作无期限地进行下去。 23. 针对时间紧或有压力的任务，设置结束时间 针对时间紧或有压力的任务，设置结束时间，万事皆可终结 24. 好记性胜过烂笔头 多记，多做笔记。 好记性胜于烂笔头，记笔记能够加深对知识的印象。 25. 记下让你分散注意力的点子 进入高效状态后，记下任何分散你注意力的东西比如Google搜索词、灵光乍现的想法、新点子等等。如果你把它们记下来，它就不会再蹦来蹦去了。 26. 劳逸结合","categories":[{"name":"GROWING_SPACE","slug":"GROWING-SPACE","permalink":"http://verymuch.com/categories/GROWING-SPACE/"}],"tags":[{"name":"有感","slug":"有感","permalink":"http://verymuch.com/tags/有感/"},{"name":"工作效率","slug":"工作效率","permalink":"http://verymuch.com/tags/工作效率/"},{"name":"他人经验总结","slug":"他人经验总结","permalink":"http://verymuch.com/tags/他人经验总结/"}]},{"title":"实现墨刀首页两个弹跳的圆的效果","slug":"实现墨刀首页两个弹跳的圆的效果","date":"2017-02-09T06:59:53.000Z","updated":"2017-02-09T09:20:26.000Z","comments":true,"path":"2017/02/09/实现墨刀首页两个弹跳的圆的效果/","link":"","permalink":"http://verymuch.com/2017/02/09/实现墨刀首页两个弹跳的圆的效果/","excerpt":"练习目标实现墨刀首页两个弹跳的圆的效果","text":"练习目标实现墨刀首页两个弹跳的圆的效果 练习效果 .circle-wrapper { position: relative; width: 560px; height: 560px; border: 1px solid lightblue; } .circle { position: absolute; left: 50%; top: 50%; transform: translate3d(-50%, -50%, 0); /*transform: translate(-50%, -50%);*/ border-radius: 50%; } .circle-1 { width: 65%; height: 65%; border: 80px solid rgba(255, 0, 0, .1); animation: 4s ease-in-out bounce-1; } .circle-2 { width: 80%; height: 80%; border: 1px solid rgba(255, 0, 0, .3); animation: 4s ease-in-out bounce-2; } @keyframes bounce-1 { 0% { width: 5%; height: 5%; border-width: 15px; } 15% { width: 20%; height: 20%; border-width: 20px; } 30% { width: 5%; height: 5%; border-width: 15px; } 40% { width: 20%; height: 20%; border-width: 20px; } 50% { width: 5%; height: 5%; border-width: 15px; } } @keyframes bounce-2 { 0% { width: 25%; height: 25%; } 15% { width: 35%; height: 35%; } 30% { width: 25%; height: 25%; } 40% { width: 35%; height: 35%; } 50% { width: 25%; height: 25%; } } HTML1234&lt;div class=\"circle-wrapper\"&gt; &lt;div class=\"circle circle-1\"&gt;&lt;/div&gt; &lt;div class=\"circle circle-2\"&gt;&lt;/div&gt;&lt;/div&gt; CSS结构样式 1234567891011121314151617181920212223242526.circle-wrapper &#123; position: relative; width: 560px; height: 560px; border: 1px solid lightblue;&#125;.circle &#123; position: absolute; left: 50%; top: 50%; transform: translate3d(-50%, -50%, 0); /*transform: translate(-50%, -50%);*/ border-radius: 50%;&#125;.circle-1 &#123; width: 65%; height: 65%; border: 80px solid rgba(255, 0, 0, .1); animation: 4s ease-in-out bounce-1;&#125;.circle-2 &#123; width: 80%; height: 80%; border: 1px solid rgba(255, 0, 0, .3); animation: 4s ease-in-out bounce-2;&#125; 动画设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@keyframes bounce-1 &#123; 0% &#123; width: 5%; height: 5%; border-width: 15px; &#125; 15% &#123; width: 20%; height: 20%; border-width: 20px; &#125; 30% &#123; width: 5%; height: 5%; border-width: 15px; &#125; 40% &#123; width: 20%; height: 20%; border-width: 20px; &#125; 50% &#123; width: 5%; height: 5%; border-width: 15px; &#125;&#125;@keyframes bounce-2 &#123; 0% &#123; width: 25%; height: 25%; &#125; 15% &#123; width: 35%; height: 35%; &#125; 30% &#123; width: 25%; height: 25%; &#125; 40% &#123; width: 35%; height: 35%; &#125; 50% &#123; width: 25%; height: 25%; &#125;&#125;","categories":[{"name":"EXERCISE_SPACE","slug":"EXERCISE-SPACE","permalink":"http://verymuch.com/categories/EXERCISE-SPACE/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-01-07T00:40:48.000Z","updated":"2017-01-10T11:04:50.000Z","comments":true,"path":"2017/01/07/hello-world/","link":"","permalink":"http://verymuch.com/2017/01/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}