{"meta":{"title":"歪马行空","subtitle":"做一只默默奋斗的程序猿~！","description":null,"author":"verymuch","url":"http://verymuch.com"},"pages":[{"title":"Categories","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://verymuch.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"about/index.html","permalink":"http://verymuch.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"tags/index.html","permalink":"http://verymuch.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-12-14T05:37:43.000Z","updated":"2017-12-14T05:37:43.000Z","comments":true,"path":"css/custom.css","permalink":"http://verymuch.com/css/custom.css","excerpt":"","text":".text-highlight { color: red; } .text-hint { color: #999; } button { padding: 5px 10px; background: #38b7ea; color: #fff; border: none; border-radius: 2px; cursor: pointer; } /* 示例区域 */ .demo-area { border: 1px solid #f8f8f8; padding: 10px; } .demo-area textarea { display: block; margin-top: 5px; width: 100%; height: 120px; } .demo-area canvas { width: 200px; height: 100px; } /* 重置样式 */ .article-entry td { padding: 0; }"}],"posts":[{"title":"Data URL简介与使用","slug":"Data-URL简介与使用","date":"2017-12-14T00:34:41.000Z","updated":"2017-12-15T13:59:39.000Z","comments":true,"path":"2017/12/14/Data-URL简介与使用/","link":"","permalink":"http://verymuch.com/2017/12/14/Data-URL简介与使用/","excerpt":"1. 简介Data URL，是以data:模式为前缀的URL，允许内容的创建者将较小的文件嵌入到文档中。与常规的URL使用场合类似（下面会具体介绍可以将Data URL用在哪些地方）。 Data URL由data:前缀、MIME类型（表明数据类型）、base64标志位（如果是文本，则可选）以及数据本身四部分组成。 语法格式如下： 1data:[&lt;mediatype&gt;][;base64],data mediatype是一个MIME（Multipurpose Internet Mail Extension）类型字符串，如image/jpeg表示一个JPEG图片文件。如果省略，默认值为text/plain;charset=US-ASCII。","text":"1. 简介Data URL，是以data:模式为前缀的URL，允许内容的创建者将较小的文件嵌入到文档中。与常规的URL使用场合类似（下面会具体介绍可以将Data URL用在哪些地方）。 Data URL由data:前缀、MIME类型（表明数据类型）、base64标志位（如果是文本，则可选）以及数据本身四部分组成。 语法格式如下： 1data:[&lt;mediatype&gt;][;base64],data mediatype是一个MIME（Multipurpose Internet Mail Extension）类型字符串，如image/jpeg表示一个JPEG图片文件。如果省略，默认值为text/plain;charset=US-ASCII。 2. Data URL的优缺点 Data URL的优势 和传统的外部资源引用，Data URL有着以下优势： 当访问外部资源很麻烦或受限时，可以将外部资源转为Data URL引用(这个比较鸡肋) 当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时，这是需要返回一个可用的URL（场景较少） 当图片的体积太小，占用一个HTTP会话不是很值得时（雪碧图可以出场了） Data URL的缺点 虽然Data URL允许使用者将文件嵌入到文档中，这在某些场景下较为合适，但是Data URL也有一些缺点： 体积更大：Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3 不会缓存：Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。 3. 如何获取base64编码 Linux/Mac OS X下可以使用uuencode命令 1uuencode -m &lt;源文件&gt; &lt;转码后标识&gt; 如执行uuencode -m hello-base64 hello，会得到如下结果： 123begin-base64 644 helloaGVsbG8gYmFzZTY0 // 此处为base64编码，对应文本内容为 'hello base64'==== 使用原生Web API编码/解码 Javascript中有两个函数负责编码和解码base64字符串，分别是atob和btoa。 atob(): 负责解码已经使用base64编码了的字符串。 btoa(): 将二进制字符串转为base64编码的ASCII字符串。 两者都只针对Data URL中的data进行处理。 12btoa('hello base64') // \"aGVsbG8gYmFzZTY0\"atob('aGVsbG8gYmFzZTY0') // \"hello base64\" Canvas的toDataURL方法 Canvas提供了toDataURL方法，用于获取canvas绘制内容，将其转为base64格式。 如下所示，文本框中的内容即为canvas中绘制内容的base64格式。 var canvas = document.getElementById('testCanvas'); if (canvas.getContext) { var ctx = canvas.getContext('2d'); // 设置字体 ctx.font = \"Bold 20px Arial\"; // 设置对齐方式 ctx.textAlign = \"left\"; // 设置填充颜色 ctx.fillStyle = \"#000\"; // 设置字体内容，以及在画布上的位置 ctx.fillText(\"hello base64\", 10, 30); // 绘制空心字 ctx.strokeText(\"hello base64\", 10, 80); // 获取 Data URL document.getElementById('testCanvas-content').value = canvas.toDataURL(); } Html: 12&lt;canvas id=\"testCanvas\" width=\"200\" height=\"100\"&gt;&lt;/canvas&gt;&lt;textarea id=\"testCanvas-content\"&gt;&lt;/textarea&gt; JS: 12345678910111213141516var canvas = document.getElementById('testCanvas');if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); // 设置字体 ctx.font = \"Bold 20px Arial\"; // 设置对齐方式 ctx.textAlign = \"left\"; // 设置填充颜色 ctx.fillStyle = \"#000\"; // 设置字体内容，以及在画布上的位置 ctx.fillText(\"hello base64\", 10, 30); // 绘制空心字 ctx.strokeText(\"hello base64\", 10, 80); // 获取 Data URL document.getElementById('testCanvas-content').value = canvas.toDataURL();&#125; 使用FileReader API的readAsDataURL方法 FileReader API提供的readAsDataURL方法能够返回一个基于base64编码的Data URL。 如下所示，选择文件后返回Data URL。 var reader = new FileReader() reader.onload = function(e) { var textarea = document.getElementById('testReadAsDataURL-content'); textarea.value = reader.result } document.getElementById('testReadAsDataURL').onchange = function(e) { var file = e.target.files[0] reader.readAsDataURL(file) } Html: 1234&lt;div class=\"demo-area\"&gt; &lt;input type=\"file\" id=\"testReadAsDataURL\"&gt; &lt;textarea id=\"testReadAsDataURL-content\"&gt;&lt;/textarea&gt;&lt;/div&gt; JS: 123456789var reader = new FileReader()reader.onload = function(e) &#123; var textarea = document.getElementById('testReadAsDataURL-content'); textarea.value = reader.result&#125;document.getElementById('testReadAsDataURL').onchange = function(e) &#123; var file = e.target.files[0] reader.readAsDataURL(file)&#125; 4. Data URL能用在何处呢？最开始已经说了Data URL，是以data:模式为前缀的URL，使用场合与常规URL相同，即常规URL能够使用的场合，Data URL也可以使用。如：浏览器地址栏、link中引入css文件、script中引入js文件、img src中引入图片、video中引入视频、iframe中引入网页、css background url引入背景。 在浏览器地址栏中使用Data URL 在浏览器地址栏中使用Data URL，打开上述canvas中绘制的内容 注意：chrome 从56开始将Data URL标记为“不安全”，从60开始屏蔽从页面打开的 Data URI 网址，可以右键新标签打开。详情 document.getElementById('setDataURLInHref').href = document.getElementById('testCanvas-content').value Html: 1&lt;a href=\"base64内容\" target=\"_blank\" id=\"setDataURLInHref\"&gt;&lt;/a&gt; 在script/img/video/iframe等标签的src属性内使用Data URL 以在script中使用Data URL为例： 点击加入script标签 var scriptDataURL = `data:text/javascript;base64,YWxlcnQoJ+WcqHNjcmlwdOS4reS9v+eUqERhdGEgVVJMJykK` // 对应文本为：alert('在script中使用Data URL') $('#setDataURLInScriptBtn').click(function() { $('').attr('src', scriptDataURL).appendTo($('body')) }) JS: 12345var scriptDataURL = `data:text/javascript;base64,YWxlcnQoJ+WcqHNjcmlwdOS4reS9v+eUqERhdGEgVVJMJykK`// 对应文本为：alert('在script中使用Data URL')$('#setDataURLInScriptBtn').click(function() &#123; $('&lt;script&gt;').attr('src', scriptDataURL).appendTo($('body'))&#125;) 在&lt;link&gt;标签的href中使用Data URL 点击将文字的颜色设为红色 var linkDataURL = `data:text/css;base64,I3NldERhdGFVUkxJbkxpbmtCdG57Y29sb3I6IHJlZDt9Cg==` // 对应内容为：setDataURLInLinkBtn{color: red;} $('#setDataURLInLinkBtn').click(function() { $('').attr('href', linkDataURL).appendTo($('head')) }) JS: 12345var linkDataURL = `data:text/css;base64,I3NldERhdGFVUkxJbkxpbmtCdG57Y29sb3I6IHJlZDt9Cg==`// 对应内容为：setDataURLInLinkBtn&#123;color: red;&#125;$('#setDataURLInLinkBtn').click(function() &#123; $('&lt;link rel=\"stylesheet\" type =\"text/css\"&gt;').attr('href', linkDataURL).appendTo($('head'))&#125;) 在css样式background的url中使用Data URL const bgDataURL = $('#testCanvas-content')[0].value $('#setDataURLInBG').css('background-image', `url(${bgDataURL})`) JS: 12const bgDataURL = $('#testCanvas-content')[0].value$('#setDataURLInBG').css('background-image', `url($&#123;bgDataURL&#125;)`) 5. 参考链接 MDN Data URLs","categories":[],"tags":[{"name":"沉淀","slug":"沉淀","permalink":"http://verymuch.com/tags/沉淀/"}]},{"title":"escape、encodeURI和encodeURIComponent的区别与使用","slug":"escape、encodeURI和encodeURIComponent的区别与使用","date":"2017-12-12T14:51:18.000Z","updated":"2017-12-15T01:48:31.000Z","comments":true,"path":"2017/12/12/escape、encodeURI和encodeURIComponent的区别与使用/","link":"","permalink":"http://verymuch.com/2017/12/12/escape、encodeURI和encodeURIComponent的区别与使用/","excerpt":"1. escapeescape是对字符串(string)进行编码(而另外两种是对URL)，作用是让它们在所有电脑上可读。编码之后的效果是%XX或者%uXXXX这种形式。其 ASCII字母、数字、@*/+，这几个字符不会被编码，其余的都会。 注意，当需要对URL编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于URL。 在实际工作中使用较少，可以先了解功能，待有需求时再使用。 2. encodeURI 和 encodeURIComponent对URL编码是常见的事，所以这两个方法应该是实际中要特别注意的。 它们都是编码URL，唯一区别就是编码的字符范围： encodeURI方法不会对下列字符编码ASCII字母、数字、~!@#$&amp;*()=:/,;?+&#39; encodeURIComponent方法不会对下列字符编码ASCII字母、数字、~!*()&#39; 由此可见encodeURIComponent比encodeURI编码范围更大。如，encodeURIComponent会把http://编码 http%3A%2F%2F而encodeURI却不会。","text":"1. escapeescape是对字符串(string)进行编码(而另外两种是对URL)，作用是让它们在所有电脑上可读。编码之后的效果是%XX或者%uXXXX这种形式。其 ASCII字母、数字、@*/+，这几个字符不会被编码，其余的都会。 注意，当需要对URL编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于URL。 在实际工作中使用较少，可以先了解功能，待有需求时再使用。 2. encodeURI 和 encodeURIComponent对URL编码是常见的事，所以这两个方法应该是实际中要特别注意的。 它们都是编码URL，唯一区别就是编码的字符范围： encodeURI方法不会对下列字符编码ASCII字母、数字、~!@#$&amp;*()=:/,;?+&#39; encodeURIComponent方法不会对下列字符编码ASCII字母、数字、~!*()&#39; 由此可见encodeURIComponent比encodeURI编码范围更大。如，encodeURIComponent会把http://编码 http%3A%2F%2F而encodeURI却不会。 3. 总结：适用场合三个方法的区别从上面已经能够看出，但是说实话，估计具体哪些字符会被编码没人能记得住，所以化简为繁，只要记住三种方法的使用场合就行了。 如果只是编码字符串，不和URL有半毛钱关系，那么用escape。 如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。 比如encodeURI(&quot;http://www.cnblogs.com/season-huang/some other thing&quot;); 编码后会变为&quot;http://www.cnblogs.com/season-huang/some%20other%20thing&quot;; 其中，空格被编码成了%20。但是如果你用了encodeURIComponent，那么结果变为 &quot;http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2Fsome%20other%20thing&quot; 看到了区别吗，连/都被编码了，整个URL已经没法用了。 当你需要编码URL中的参数（如rdurl）的时候，那么encodeURIComponent是最好方法。 12345var param = \"http://www.cnblogs.com/season-huang/\"; //param为参数param = encodeURIComponent(param);var url = \"http://www.cnblogs.com?next=\" + param;console.log(url) // \"http://www.cnblogs.com?next=http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2F\" 从上例可以看出，参数中的/被编码了，如果用encodeURI肯定要出问题，因为后面的/是需要编码的。","categories":[],"tags":[{"name":"沉淀","slug":"沉淀","permalink":"http://verymuch.com/tags/沉淀/"}]},{"title":"Javascript - RegExp正则表达式","slug":"Javascript-RegExp正则表达式","date":"2017-11-01T14:28:23.000Z","updated":"2017-11-30T03:50:57.000Z","comments":true,"path":"2017/11/01/Javascript-RegExp正则表达式/","link":"","permalink":"http://verymuch.com/2017/11/01/Javascript-RegExp正则表达式/","excerpt":"1. 概述 2. 如何新建 3. 正则表达式对象的属性和方法 3.1 正则表达式对象的属性 3.2 正则表达式对象的方法 3.2.1 test() 3.2.2 exec() 4. 字符串对象的方法 4.1 String.prototype.match() 4.2 String.prototype.search() 4.3 String.prototype.replace() 4.3.1 用法 4.3.2 使用场景 4.4 String.prototype.split() 5. 匹配规则 5.1 字面量字符和元字符 5.2 转义符 5.3 特殊字符 5.4 字符类 5.5 预定义模式 5.6 重复类 5.7 量词符 5.8 贪婪模式 5.9 修饰符 5.10 组匹配 1. 概述正则表达式（Regular Expression）是一种表达文本模式（即字符串结构）的方法，用来按照“给定模式”匹配文本。 JavaScript的正则表达式体系是参照 Perl 5 建立的。 2. 如何新建 使用字面量，以斜杠表示开始和结束。(编译时新建) -&gt; 书写方便直观，常用 1var regex = /verymuch/; 使用 RegExp 构造函数。(运行时新建) 1var regex = new RegExp('verymuch'); RegExp 构造函数还可以接受第二个参数，表示修饰符，i/g/m。 注意，上述两种方式都会建立一个内容为verymuch的正则表达式对象，它们的主要区别是第一种方法在编译时新建，第二种方法在运行时新建。","text":"1. 概述 2. 如何新建 3. 正则表达式对象的属性和方法 3.1 正则表达式对象的属性 3.2 正则表达式对象的方法 3.2.1 test() 3.2.2 exec() 4. 字符串对象的方法 4.1 String.prototype.match() 4.2 String.prototype.search() 4.3 String.prototype.replace() 4.3.1 用法 4.3.2 使用场景 4.4 String.prototype.split() 5. 匹配规则 5.1 字面量字符和元字符 5.2 转义符 5.3 特殊字符 5.4 字符类 5.5 预定义模式 5.6 重复类 5.7 量词符 5.8 贪婪模式 5.9 修饰符 5.10 组匹配 1. 概述正则表达式（Regular Expression）是一种表达文本模式（即字符串结构）的方法，用来按照“给定模式”匹配文本。 JavaScript的正则表达式体系是参照 Perl 5 建立的。 2. 如何新建 使用字面量，以斜杠表示开始和结束。(编译时新建) -&gt; 书写方便直观，常用 1var regex = /verymuch/; 使用 RegExp 构造函数。(运行时新建) 1var regex = new RegExp('verymuch'); RegExp 构造函数还可以接受第二个参数，表示修饰符，i/g/m。 注意，上述两种方式都会建立一个内容为verymuch的正则表达式对象，它们的主要区别是第一种方法在编译时新建，第二种方法在运行时新建。 3. 正则表达式对象的属性和方法3.1 正则表达式对象的属性 修饰符类属性：返回一个布尔值，表示对应的修饰符是否设置 ignoreCase：返回一个布尔值，表示是否设置了i修饰符，该属性只读。 global：返回一个布尔值，表示是否设置了g修饰符，该属性只读。 multiline：返回一个布尔值，表示是否设置了m修饰符，该属性只读。 12345var regex = /verymuch/igm;regex.ignoreCase // trueregex.global // trueregex.multiline // true 与修饰符无关的属性 lastIndex: 返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。 source: 返回正则表达式的字符串形式，不包括斜杠，该属性只读。 1234var regex = /verymuch/igm;regex.lastIndex // 0regex.source // \"verymuch\" 3.2 正则表达式对象的方法3.2.1 test()该方法表示当前模式是否匹配参数字符串，返回值为布尔值。 常规用法 1/cat/.test('cats and dogs') // true 正则表达式带有g修饰符，每次test方法都从上次结束的位置开始向后匹配。 1234567891011var r = /x/g;var s = '_x_x';r.lastIndex // 0r.test(s) // truer.lastIndex // 2r.test(s) // truer.lastIndex // 4r.test(s) // false 带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置。 12345var r = /x/g;var s = '_x_x';r.lastIndex = 4;r.test(s) // false 注意：lastIndex属性只对同一个正则表达式有效。下面这么写是错的，因为每次匹配条件都是一个新的正则，lastIndex都是0。 12var count = 0;while (/a/g.test('babaa')) count++; 特例用法：如果正则模式是一个空字符串，则匹配所有字符串。 3.2.2 exec()exec方法可以返回匹配结果。匹配成功，则返回一个数组，成员是每一个匹配成功的子字符串；不成功则返回null。 常规用法 123456var s = '_x_x';var r1 = /x/;var r2 = /y/;r1.exec(s) // [\"x\"]r2.exec(s) // null exec方法返回的数组还包括以下两个属性： input：整个原字符串。 index：整个模式匹配成功的开始位置（从0开始计数） 123var s = 'verymuch';var r = /m/g;r.exec(s); // [\"m\", index: 4, input: \"verymuch\"] 包含组匹配 如果正则表达式包括圆括号(即包含“组匹配”)，则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。 1234var s = '_x_x';var r = /_(x)/;r.exec(s) // [\"_x\", \"x\"] 带有g修饰符 如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。 123456789101112131415161718192021var r = /a(b+)a/g;var a1 = r.exec('_abbba_aba_');a1 // ['abbba', 'bbb']a1.index // 1r.lastIndex // 6var a2 = r.exec('_abbba_aba_');a2 // ['aba', 'b']a2.index // 7r.lastIndex // 10var a3 = r.exec('_abbba_aba_');a3 // nulla3.index // TypeError: Cannot read property 'index' of nullr.lastIndex // 0var a4 = r.exec('_abbba_aba_');a4 // ['abbba', 'bbb']a4.index // 1r.lastIndex // 6 前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，正则对象的lastIndex属性重置为0，意味着第四次匹配将从头开始。 手动设置lastIndex的值，会从指定位置开始匹配，只有在g修饰符存在下，才有效。 12345678910111213/* 无g修饰符，lastIndex设置无效 */var r1 = /a/;r1.lastIndex = 7; // 无效var match = r1.exec('xaxa');match.index // 1r1.lastIndex // 7/* 有g修饰符，lastIndex设置有效 */var r2 = /a/g;r2.lastIndex = 2;var match = r2.exec('xaxa');match.index // 3r2.lastIndex // 4 特例用法：如果正则对象是一个空字符串，则exec方法会匹配成功，但返回的也是空字符串。 1234567891011var r1 = new RegExp('');var a1 = r1.exec('abc');a1 // ['']a1.index // 0r1.lastIndex // 0var r2 = new RegExp('()');var a2 = r2.exec('abc');a2 // ['', '']a2.index // 0r2.lastIndex // 0 4. 字符串对象的方法字符串对象的方法中，有四种与正则对象有关。 match()：返回一个数组，成员是所有匹配的子字符串。 search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。 replace()：按照给定的正则表达式进行替换，返回替换后的字符串，原字符串不变。 split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。 4.1 String.prototype.match() 常规用法 与正则对象的exec方法类似，成功返回数组，且包含index和input属性；不成功返回null。 123456var s = 'verymuch';var r1 = /v/;var r2 = /z/;s.match(r1) // [\"v\", index: 0, input: \"verymuch\"]s.match(r2) // null 带有g修饰符时，与exec不同，会一次性返回所有匹配成功的结果。 12345var s = 'verymuchve';var r = /v(e)/g;s.match(r) // [\"ve\", \"ve\"]r.exec(s) // [\"ve\", \"e\", index: 0, input: \"verymuchve\"] 特别注意：设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。 1234var s = 'verymuchve';var r = /v(e)/g;r.lastIndex = 15; // 无效s.match(r) // [\"ve\", \"ve\"] 4.2 String.prototype.search()字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置，如未匹配，则返回-1。 1'verymuch'.search(/v/); // 0 该方法会忽略g修饰符，并且和match类似，设置lastIndex无效，永远从第一个字符开始匹配。 123var r = /v(e)/g;r.lastIndex = 15; // 无效'verymuch'.search(r) // 0 4.3 String.prototype.replace()4.3.1 用法对象字符串的replace方法可以替换匹配的值。接收两个参数，第一个是搜索模式，第二个是替换内容：str.replace(search, replacement)。 不加g修饰符，则只替换第一个匹配成功的值；加了g修饰符，则替换所有匹配成功的值。 123'aaa'.replace('a', 'b') // \"baa\"'aaa'.replace(/a/, 'b') // \"baa\"'aaa'.replace(/a/g, 'b') // \"bbb\"，替换了所有的匹配值 replace方法的第二个参数中可以使用$符号，用来指代所替换的内容。 $&amp; 指代匹配的子字符串。 $` 指代匹配结果前面的文本。 $’ 指代匹配结果后面的文本。 $n 指代匹配成功的第n组内容，n是从1开始的自然数。 $$ 指代美元符号$。 123'hello world'.replace(/(\\w+)\\s(\\w+)/, '$2 $1'); // \"world hello\"'abc'.replace('b', '[$`-$&amp;-$\\']'); // \"a[a-b-c]c\" replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。 1234'3 and 5'.replace(/[0-9]+/g, function(match)&#123; return 2 * match;&#125;)// \"6 and 10\" 作为replace方法第二个参数的替换函数，可以接受多个参数。第一个参数是匹配到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。 4.3.2 使用场景 用于消除字符串首尾两端的空格。 1234var str = ' #id div.class ';str.replace(/^\\s+|\\s+$/g, '')// \"#id div.class\" 网页模板字符串替换 1234567891011121314var prices = &#123;'pr_1': '$1.99','pr_2': '$9.99','pr_3': '$5.00'&#125;;var template = '/* ... */'; // 这里可以放网页模块字符串template.replace( /(&lt;span id=\")(.*?)(\"&gt;)(&lt;\\/span&gt;)/g, function(match, $1, $2, $3, $4)&#123; return $1 + $2 + $3 + prices[$2] + $4; &#125;); 4.4 String.prototype.split()字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。 语法为：str.split(separator, [limit])。第一个参数为分割规则，第二个参数为返回数组的最大成员数，该参数可缺省。 123456789101112131415// 非正则分隔'a, b,c, d'.split(',')// [ 'a', ' b', 'c', ' d' ]// 正则分隔，去除多余的空格'a, b,c, d'.split(/, */)// [ 'a', 'b', 'c', 'd' ]// 指定返回数组的最大成员'a, b,c, d'.split(/, */, 2)[ 'a', 'b' ]// 特殊示例，第二次以0个`a`分割'aaa**a*'.split(/a*/)// [\"\", \"*\", \"*\", \"*\"] 如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。若不想返回括号中的内容，则可以使用非捕获括号（见下文）。 12'aaa*a*'.split(/(a*)/)// [ '', 'aaa', '*', 'a', '*' ] 5. 匹配规则5.1 字面量字符和元字符大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”（literal characters）。 除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。 点字符(.) 点字符（.）匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符（只能一个字符）。 位置字符 ^ 表示字符串的开始位置 $ 表示字符串的结束位置 123456789// test必须出现在开始位置/^test/.test('test123') // true// test必须出现在结束位置/test$/.test('new test') // true// 从开始位置到结束位置只有test/^test$/.test('test') // true/^test$/.test('test test') // false 选择符(|) 竖线符号（|）在正则表达式中表示“或关系”（OR），即very|much表示匹配very或much。并且多个选择符可以联合使用。 1234/11|22/.test('911') // true// 匹配fred、barney、betty之中的一个/fred|barney|betty/ 选择符会包括它前后的多个字符，比如/ab|cd/指的是匹配ab或者cd，而不是指匹配b或者c。如果想修改这个行为，可以使用圆括号。 1/a( |\\t)b/.test('a\\tb') // true 其他元字符：还包括\\\\、\\*、+、?、()、[]、{}等，将在下文解释。 5.2 转义符正则表达式中那些有特殊含义的字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配加号，就要写成+。 123/1+1/.test('1+1'); // false/1\\+1/.test('1+1'); // true 正则模式中，需要用斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\\\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。 123(new RegExp('1\\+1')).test('1+1'); // false(new RegExp('1\\\\+1')).test('1+1'); // true 上面代码中，RegExp作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。 5.3 特殊字符正则表达式对一些不能打印的特殊字符，提供了表达方法。 \\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。 [\\b] 匹配退格键(U+0008)，不要与\\b混淆。 \\n 匹配换行键。 \\r 匹配回车键。 \\t 匹配制表符tab（U+0009）。 \\v 匹配垂直制表符（U+000B）。 \\f 匹配换页符（U+000C）。 \\0 匹配null字符（U+0000）。 \\xhh 匹配一个以两位十六进制数（\\x00-\\xFF）表示的字符。 \\uhhhh 匹配一个以四位十六进制数（\\u0000-\\uFFFF）表示的unicode字符。 5.4 字符类字符类（Class）有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[very]表示匹配v,e、r、y之中的任意一个。 12/[m]/.test('very') // false/[m]/.test('much') // true 在字符类中有两个字符有特殊含义 脱字符(^) 如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，匹配其他任意字符。比[^very]表示匹配v,e、r、y之外的任意一个。 12/[^m]/.test('very') // true/[^m]/.test('much') // false 如果方括号内没有其他字符，只有[^]，则匹配一切字符，其中包括换行符，而点号(.)是不包括换行符。 12/./.test('\\n'); // false/^/.test('\\n'); // true 注意，脱字符只有在字符类的第一个位置才有特殊含义，其他位置为字面含义 连字符(-) 某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。 1[1-31] // 只代表1到3，不代表1到31 注意，字符类的连字符必须在头尾两个字符中间，才有特殊含义，否则就是字面含义。比如，[-9]就表示匹配连字符和9，而不是匹配0到9。 连字符还可以用来指定Unicode字符的范围。 123var str = \"\\u0130\\u0131\\u0132\";/[\\u0128-\\uFFFF]/.test(str)// true 另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。 5.5 预定义模式预定义模式是指常见模式的简写方式。 \\d 匹配0-9之间的任一数字，相当于[0-9]。 \\D 匹配所有0-9以外的字符，相当于[^0-9]。 \\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。 \\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。 \\s 匹配空格（包括制表符、空格符、断行符等），相等于[\\t\\r\\n\\v\\f]。 \\S 匹配非空格的字符，相当于[^\\t\\r\\n\\v\\f]。 \\b 匹配词的边界。 \\B 匹配非词边界，即在词的内部。 1234567891011// \\s的例子/\\s\\w*/.exec('hello world') // [\" world\"]// \\b的例子/\\bworld/.test('hello world') // true/\\bworld/.test('hello-world') // true/\\bworld/.test('helloworld') // false// \\B的例子/\\Bworld/.test('hello-world') // false/\\Bworld/.test('helloworld') // true 通常，正则表达式遇到换行符（\\n）就会停止匹配。 12345// [\\S\\s]可以匹配所有字符var html = \"&lt;b&gt;Hello&lt;/b&gt;\\n&lt;i&gt;world!&lt;/i&gt;\";/[\\S\\s]*/.exec(html)[0]// \"&lt;b&gt;Hello&lt;/b&gt;\\n&lt;i&gt;world!&lt;/i&gt;\" 5.6 重复类模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。 12/lo&#123;2&#125;k/.test('look') // true/lo&#123;2,5&#125;k/.test('looook') // true 5.7 量词符用来设定某个模式出现的次数 ? 问号表示某个模式出现0次或1次，等同于{0, 1}。 * 星号表示某个模式出现0次或多次，等同于{0,}。 + 加号表示某个模式出现1次或多次，等同于{1,}。 1234567891011121314// t出现0次或1次/t?est/.test('test') // true/t?est/.test('est') // true// t出现1次或多次/t+est/.test('test\") // true/t+est/.test('ttest') // true/t+est/.test('est') // false// t出现0次或多次/t*est/.test('test') // true/t*est/.test('ttest') // true/t*est/.test('tttest') // true/t*est/.test('est') // true 5.8 贪婪模式上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。 12var s = 'aaa';s.match(/a+/) // [\"aaa\"] 上述代码中，默认是贪婪模式，会一直匹配到不出现a为止，所以匹配结果为3个a。 在量词符后加一个问号，可以将贪婪模式改为非贪婪模式。非贪婪模式，一旦条件满足，就不在往下匹配。 12var s = 'aaa';s.match(/a+?/) // [\"a\"] ??：匹配时采用非贪婪模式，则在满足匹配条件的情况下，不贪婪，不一定是匹配0次。 *?：匹配时采用非贪婪模式，则在满足匹配条件的情况下，不贪婪，不一定是匹配0次。 +?：匹配时采用非贪婪模式，则在满足匹配条件的情况下，不贪婪，不一定是匹配1次。 5.9 修饰符修饰符(modifier)表示模式的附加规则，放在正则模式的尾部。 g修饰符 g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换，前面介绍的内容能够看出。 i修饰符 默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。 m修饰符 m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\\n）。 1234/world$/.test('hello world\\n') // false/world$/m.test('hello world\\n') // true 匹配行尾/^b/m.test('a\\nb') // true 匹配行首 5.10 组匹配正则表达式的括号表示分组匹配。 捕获组 在正则表达式内部，可以用\\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。 12/(.)b(.)\\1b\\2/.test(\"abcabc\")// true 上面的代码中，\\1表示第一个括号匹配的内容（即“a”），\\2表示第二个括号匹配的内容（即“c”） 括号还可以嵌套。 1/y((..)\\2)\\1/.test('yabababab') // true 上面代码中，\\1指向外层括号，\\2指向内层括号。 组匹配非常有用，下面是一个匹配网页标签的例子。 123var tagName = /&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\\/\\1&gt;/;tagName.exec(\"&lt;b&gt;bold&lt;/b&gt;\")[1] 上面代码中，圆括号匹配尖括号之中的标签，而\\1就表示对应的闭合标签。 将上面的代码略作修改，就可以捕获带有属性的标签。 1234567891011121314var html = '&lt;b class=\"hello\"&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;';var tag = /&lt;(\\w+)([^&gt;]*)&gt;(.*?)&lt;\\/\\1&gt;/g;var match = tag.exec(html);match[1] // \"b\"match[2] // \"class=\"hello\"\"match[3] // \"Hello\"match = tag.exec(html);match[1] // \"i\"match[2] // \"\"match[3] // \"world\" 注意，中间的非贪婪匹配了hello，在满足匹配条件的情况下不贪婪。 非捕获组 (?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。 非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成/(foo){1, 2}/，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为/(?:foo){1, 2}/，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容，也不能用\\n引用括号匹配的内容 12345var m = 'abc'.match(/(?:.)b(.)/);m // [\"abc\", \"c\"] 非捕获括号的内容在结果中没有var n = 'aba'.match(/(?:.)b\\1/);n // null 先行断言 x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\\d+(?=%)/。 “先行断言”中，括号里的部分是不会返回的。 12var m = 'abc'.match(/b(?=c)/);m // [\"b\"] 先行否定断言 x(?!y)称为先行否定断言（Nagative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着的不是百分号的数字，可以写成/\\d+(?!%)/。 12/\\d+(?!\\.)/.exec('3.14')// [\"14\"] 上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是14。","categories":[],"tags":[{"name":"沉淀","slug":"沉淀","permalink":"http://verymuch.com/tags/沉淀/"}]},{"title":"第二章 ES6 基础","slug":"第二章-ES6-基础","date":"2017-11-01T08:53:14.000Z","updated":"2017-12-12T03:21:20.000Z","comments":true,"path":"2017/11/01/第二章-ES6-基础/","link":"","permalink":"http://verymuch.com/2017/11/01/第二章-ES6-基础/","excerpt":"JavaScript语言的第六版\b中引入了大量的非破坏性语法改进。本章我们将讨论其中的大部分内容。大部分的改变都是语法糖，能够使用ES5的代码进行实现，虽然需要使用更复杂的代码。还有一部分改变并不仅仅是语法糖，比如在本章最后，我们将会介绍let和const这两种完全不同的声明变量的方式。 对象字面量的语法在ES6发生了改变，就让我们从这方面开始讲述吧。","text":"JavaScript语言的第六版\b中引入了大量的非破坏性语法改进。本章我们将讨论其中的大部分内容。大部分的改变都是语法糖，能够使用ES5的代码进行实现，虽然需要使用更复杂的代码。还有一部分改变并不仅仅是语法糖，比如在本章最后，我们将会介绍let和const这两种完全不同的声明变量的方式。 对象字面量的语法在ES6发生了改变，就让我们从这方面开始讲述吧。 2.1 对象字面量对象字面量是指使用{}缩写语法进行对象声明的形式，具体语法格式如下： 12345var book=&#123; title: 'Modular ES6', author: 'Nicolas', publisher: 'O ́Reilly'&#125; ES6中对象字面量语法有一些小的改进：属性值缩写，可计算属性名和方法定义。下面我们来学习一下这些内容，并介绍一下它们的用法。 2.1.1 属性值缩写有时我们会声明一个对象，该对象有一个或多个属性值的属性名和所引用的变量名相同。比如，有一个listeners数组，为了将其赋值给对象字面量中名为listeners的属性名，必须重复输入该名称。下面的这段代码很好地展示了包含两个重复属性的对象字面量： 123456var listeners = [] function listen() &#123;&#125; var events = &#123; listeners: listeners, listen: listen&#125; 在ES6中，如果我们遇到这种问题，借助新的属性值缩写语法就可以省略属性值和分号。如下例所示，新的ES6语法进行了隐性赋值： 123var listeners = []function listen() &#123;&#125;var events = &#123; listeners, listen &#125; 随着接下来对于本书第二章的学习，我们会发现属性值缩写在不影响代码含义的情况下，能够有效地减少重复代码的书写。在下面的代码片段中，我重新实现了浏览器中的持久存储APIlocalStorage的部分内容，可以将其看成是内存存储的填充实现[注释 1]。如果没有使用缩写语法，storage对象看起来会更加冗长： 1234567891011var store = &#123;&#125;var storage = &#123; getItem, setItem, clear &#125; function getItem(key) &#123; return key in store ? store[key] : null &#125;function setItem(key, value) &#123; store[key] = value&#125;function clear() &#123; store = &#123;&#125; &#125; ES6 中有很多旨在减少所维护代码的复杂性的特性，属性值缩写只是我们所要介绍的第一个特性。一旦你习惯了这一新语法，你就会发现代码的可读性和开发者的生产效率都得到了提升。 2.1.2 可计算属性名如下面的ES5代码所示，有时，我们可能需要声明这样一个对象：包含属性名基于其他变量或者JavaScript表达式的属性。在本例中，假设expertise是作为一个函数参数，而我们事先并不知道它的值： 123456789var expertise = 'journalism' var person = &#123; name: 'Sharon', age: 27 &#125;person[expertise] = &#123; years: 5, interests: ['international', 'politics', 'internet']&#125; 在ES6中，对象字面量并不限制使用静态名称来声明。使用可计算属性名，可以用方括号将任何表达式包裹起来，作为属性名使用。当声明执行时，表达式才会被计算，并被当做属性名使用。下面的例子向我们展示了上例中所看到的代码如何用一步声明person对象，而不需要借助第二个声明来添加expertise属性。 123456789var expertise = 'journalism' var person = &#123; name: 'Sharon', age: 27, [expertise]: &#123; years: 5, interests: ['international', 'politics', 'internet'] &#125;&#125; 属性值缩写和可计算属性名不能同时使用。属性值缩写只是用来避免重复的在编译时执行的语法糖，而可计算属性名是在运行时进行计算的。如果下例所示，当我们试图同时使用这两个冲突的特性时，系统会抛出一个语法错误的异常。多数情况下，这种组合使用会导致代码难以理解，所以最好不要同时使用这两个特性。 12345678910var expertise = 'journalism' var journalism = &#123; years: 5, interests: ['international', 'politics', 'internet']&#125;var person = &#123; name: 'Sharon', age: 27, [expertise] // 语法错误！&#125; 可计算属性名有一个常用的使用场景，即如下面的代码所示，当我们想要将一个实体添加到一个对象映射中，并且想使用实体的id字段作为键值，就可以使用可计算属性名。我们可以直接在groceries对象字面量中进行内联声明，而不需要单独使用第三条声明语句将grocery添加到groceries映射中。 12345678910var grocery = &#123; id: 'bananas', name: 'Bananas', units: 6, price: 10, currency: 'USD'&#125;var groceries = &#123; [grocery.id]: grocery&#125; 还有一种使用场景：当一个函数接受一个参数，并用该参数构建一个对象并返回。如果用ES5的代码来实现，则需要分配一个变量进行对象字面量的声明，然后添加一个动态计算的属性，最后返回这个对象。下面的例子展示了这一使用场景，创建一个信封，之后能够用于Ajax消息，这些消息主要遵循以下约定：当发生错误时，有一个error属性，用于描述发生了什么错误；在结果正常时，有一个success属性表示成功： 1234567function getEnvelope(type, description) &#123; var envelope = &#123; data: &#123;&#125; &#125; envelope[type] = description return envelope &#125; 可计算属性名能够帮我们用更简明的代码实现同样的函数，仅使用一条语句就能够实现： 123456function getEnvelope(type, description) &#123; return &#123; data: &#123;&#125;, [type]: description &#125;&#125; 方法的定义通常，我们会通过向对象添加一个属性的方式来为该对象声明一个方法。在下面的代码片段中，我们将创建一个能够支持多种事件类型的小型事件发射器。时间发射器的emitter#on方法可以用来注册事件监听函数，emitter#emit方法可以用来触发事件。 1234567891011121314151617var emitter = &#123; events: &#123;&#125;, on: function (type, fn) &#123; if (this.events[type] === undefined) &#123; this.events[type] = [] &#125; this.events[type].push(fn) &#125;, emit: function (type, event) &#123; if (this.events[type] === undefined) &#123; return &#125; this.events[type].forEach(function (fn) &#123; fn(event) &#125;) &#125; &#125; 从ES6开始，我们可以使用新的方法定义语法在对象字面量中进行方法的声明。这时，我们可以省略分号和function关键字。新的方法定义语法可以作为传统的使用function关键字声明方法的一种更加简洁的替代方案。 1234567891011121314151617var emitter = &#123; events: &#123;&#125;, on(type, fn) &#123; if (this.events[type] === undefined) &#123; this.events[type] = [] &#125; this.events[type].push(fn) &#125;, emit(type, event) &#123; if (this.events[type] === undefined) &#123; return &#125; this.events[type].forEach(function (fn) &#123; fn(event) &#125;) &#125; &#125; 箭头函数是ES6中的另一种函数声明方式，它有好几种形式。现在让我们来探究一下箭头函数到底是什么，它们是如何声明的以及它们的语法形式。 2.2 箭头函数在JavaScript中，我们通常使用类似下面的代码进行函数声明：函数名，参数列表和函数体。 123function name(parameters) &#123; // function body&#125; 我们也可以创建一个匿名函数，这是需要省略函数的名称，并将其赋值给一个变量或者对象的属性，也可以直接进行调用。 123var example = function (parameters) &#123; // function body&#125; 在ES6中，我们可以使用另一种方式来声明匿名函数，即箭头函数。值得一提的是，箭头函数有几种不同的写法。下面的所示代码中的箭头函数和前面刚看过的匿名函数非常相似。唯一的不同就是缺少了function关键字，并且在参数列表的右侧多了个=&gt;箭头。 123var example = (parameters) =&gt; &#123; // function body&#125; 尽管箭头函数看起来和常规的匿名函数很相似，但是本质上它们是完全不同的：箭头函数不能显示地命名，不过现代的运行环境会将箭头函数所赋予的变量名作为函数名；不能用作构造函数，也没有prototype属性，所以不能使用new关键字调用箭头函数；箭头函数被绑定到词法作用域中，这样是为什么它们不会改变this含义的原因。 让我们深入了解它们与传统函数的语义差异，声明箭头函数的多种方法以及它们的实际用例。 2.2.1 词法作用域箭头函数不会创建新的作用域，在箭头函数的函数体内，this、arguments以及super指向所在的父级作用域。来看一下下面的例子。创建一个timer计时器对象，对象上有一个seconds计数器属性和一个start方法，这个方法就是用我们前面所学习的方法定义语法创建的。然后我们开启这个计时器，等待几秒钟，然后打印出已经过去的秒数。 12345678910111213var timer = &#123; seconds: 0, start() &#123; setInterval(() =&gt; &#123; this.seconds++ &#125;, 1000) &#125;&#125;timer.start()setTimeout(function () &#123; console.log(timer.seconds) &#125;, 3500)// &lt;- 3 如果我们使用常规的匿名函数来定义传入setInterval的函数，而不是使用箭头函数的话，this将绑定到匿名函数的上下文中，而不是start方法的上下文中。这时，如果想实现上面的timer计时器，可以在start方法的开头加上类似var self = this的声明语句，然后在setInterval函数内部引用self即可。由此可见，使用箭头函数，能够避免为保持上下文引用而额外增加的复杂性，只关注代码的功能即可。 同样地，ES6中箭头函数的作用域绑定也意味着当使用.call、.apply、.bind等方法调用函数时也无法改变this的指向。这一限制通常是很有作用的，因为这能够保证上下文不被修改。 现在我们再看一下下面这个例子。你认为console.log会输出出什么呢？ 123456function puzzle() &#123; return function () &#123; console.log(arguments) &#125;&#125;puzzle('a', 'b', 'c')(1, 2, 3) 答案是arguments指向匿名函数的上下文，因此传入匿名函数的参数会被输出。在本里中，这些参数是1, 2, 3。 如果将上例重点匿名函数换为箭头函数，结果会如何呢？ 1234function puzzle() &#123; return () =&gt; console.log(arguments)&#125;puzzle('a', 'b', 'c')(1, 2, 3) 这时，arguments对象指向puzzle函数的上下文，因为箭头函数并不会创建闭包。因此，&#39;a&#39;, &#39;b&#39;, &#39;c&#39;将被输出。 上面我有提到箭头函数有几种写法，但到目前为止，我们只使用了完整版的写法。其他几种写法是什么呢？ 2.2.2 箭头函数的写法让我们再一起回顾下目前所学的箭头格式语法： 123var example = (parameters) =&gt; &#123; // function body&#125; 如果箭头函数只有一个参数，则可以省略圆括号。当然，这不是必须的。当将箭头函数传递到其他方法中时，这么做很有用，因为这样能够减少圆括号的数量，从而使得代码更加可读。 123var double = value =&gt; &#123; return value * 2&#125; 当使用箭头函数来声明简单函数时，则完整的写法是较为麻烦的，就如上面的double方法一样。接下来要说的这种箭头函数的写法与函数体有关。我们可以使用value * 2表达式来代替函数体。当函数被调用时，表达式会被计算，结果则作为返回值返回。这时，return语句是隐式的，并且不需要使用花括号包裹函数体，而是使用一个简单的表示来替代： 1var double = (value) =&gt; value * 2 我们还可以同时省略括号和return语句，这样箭头函数会更加简洁： 1var double = value =&gt; value * 2 隐式返回对象字面量当想要隐式返回对象字面量时，则需要使用圆括号将对象字面量包裹起来。否则，编译器会将花括号当成函数体的开始和结束标志。 1var objectFactory = () =&gt; (&#123; modular: 'es6' &#125;) 下例中，JavaScript就将花括号当成了箭头函数的函数体。此外，number会被当成是一个label[注释 2]，然后有一个没有做任何事的value表达式。既然函数体没有返回任何内容，则映射的结果就是undefined： 12[1, 2, 3].map(value =&gt; &#123; number: value &#125;) // &lt;- [undefined, undefined, undefined] 如果我们作为隐式返回的对象字面量具有多个属性，编译器无法识别第二个属性，因此会跑出一个SyntaxError异常： 12[1, 2, 3].map(value =&gt; &#123; number: value, verified: true &#125;) // &lt;- SyntaxError 在对象字面量外添加圆括号可以解决该问题，这样编译器就不会再将其当做函数体，此时的对象声明即为我们想要隐式返回的对象字面量。 123456[1, 2, 3].map(value =&gt; (&#123; number: value, verified: true &#125;)) /* &lt;- [ &#123; number: 1, verified: true &#125;, &#123; number: 2, verified: true &#125;, &#123; number: 3, verified: true &#125;]*/ 现在你应该已经理解什么是箭头函数了，接下来我们思考下箭头函数的优点以及正确的用法。 2.2.3 优点和用法一般来说，我们不应该盲目地使用ES6的特性。相反地，最好在使用每个特性前都仔细思考下使用了这个新特性后是否真的能提高代码的可读性和可维护性。严格来说，ES6特性并不比现有特性好，因此最好不要随意使用它们。 箭头函数在某些情况下并不适用。比如，当一个函数包含很多行代码时，这时候使用箭头函数对代码并不能起到改进作用。箭头函数更适合用于简短的实例中，比如当function关键字和语法模板占函数表达式的很大一部分时。 适当地为函数命名能使得人类理解起来更容易。箭头函数不能显示地命名，但是可以通过赋值给其他变量的方式，隐式地命名。在下例中，我们将箭头函数赋值给了throwError变量。当调用函数式的过程中发生错误时，调用栈能够正确地定位到throwError 123456var throwError = message =&gt; &#123; throw new Error(message)&#125;throwError('this is a warning')&lt;- Uncaught Error: this is a warning at throwError 当需要定义一个在任何情况下词法作用域都不改变的匿名函数时，使用箭头函数是很整洁的，并且在某些情况下，它还可以是我们的代码更加整洁。在大多数函数式编程的情况下，箭头函数是特别有用的，比如使用数组对象的.map、.filter或者.reduce等方法。具体示例如下图所示： 1234567[1,2,3,4] .map(value =&gt; value * 2) .filter(value =&gt; value &gt; 2) .forEach(value =&gt; console.log(value))// &lt;- 4// &lt;- 6// &lt;- 8 2.3 解构赋值解构赋值是ES6中最灵活最有表现力的特性之一。同时，它也是最简单的。它可以将对象的属性值绑定到任意多的变量上。解构赋值可以用于对象、数组以及函数参数列表中。让我们先从对象开始一点一点介绍吧。 2.3.1 对象的解构假设我们有一个程序，程序中有一些漫画书的角色，Bruce Wayne是这些角色中的一个，我们现在想要引用用于描述Bruce Wayne的对象中的属性。下面的代码就是用于描述蝙蝠侠的示例对象： 123456789var character = &#123; name: 'Bruce', pseudonym: 'Batman', metadata: &#123; age: 34, gender: 'male' &#125;, batarang: ['gas pellet', 'bat-mobile control', 'bat-cuffs']&#125; 如果我们想要声明一个pseudonym变量，并引用character.pseudonym的值，我们可能会写出如下的代码片段。如果我们需要在多个地方引用pseudonym，我们更希望能够避免每次都输入character.pseudonym： 1var pseudonym = character.pseudonym 如果在赋值语句中使用解构赋值，则语法会变得更加清晰。在下面的例子中能够看出，使用解构赋值后，我们不需要重复两次输入pseudonym，并且仍能清晰地表达含义。下面的这段代码和上面用ES5的编写的代码是等价的。 1var &#123; pseudonym &#125; = character 通过var声明时，使用逗号隔开能一次声明多个变量。同样地，在结构赋值的花括号中也可以声明多个变量。 1var &#123; pseudonym, name &#125; = character 并且，我们可以在同一个var语句中同时使用常规的变量声明和解构赋值。这种用法一开始看起来可能很奇怪，而且还要看我们所使用的JavaScript代码样式规范是否允许在单个语句中声明多个变量。不管如何，从这一点还是能够看出解构语法的灵活性。 1var &#123; pseudonym &#125; = character, two = 2 如果想要提取pseudonym属性，并将其声明为alias变量，我们可以使用下面这种解构语法，可以称之为别名语法。除了alias之外，我们可以使用任何其他合法的变量名。 123var &#123; pseudonym: alias &#125; = character console.log(alias)// &lt;- 'Batman' 别名看起来并不比ES5的写法alias = character.pseudonym简单。不过如果解构赋值支持深度解构的话，就另当别论了。如下面代码所示： 1var &#123; metadata: &#123; gender &#125; &#125; = character 在类似上面这种情况，当我们需要解构一个嵌套较深的属性值时，使用别名能够更清晰地传递属性名。试想一下，一个叫code的属性名，并不能如colorCode一样清晰表达所指的内容。 1var &#123; metadata: &#123; gender: characterGender &#125; &#125; = character 上面我们所看到的这种情况是很常见的，因为属性通常是基于其宿主对象命名的。palette.color.code的含义很清楚，而单独使用code则可以表示很多内容，所以在结构赋值中使用类似colorCode的别名能够将上下文含义带入到变量中。 在ES5中，访问一个不存在的属性时，会返回undefined。 1234console.log(character.boots) // &lt;- undefined console.log(character['boots']) // &lt;- undefined 在解构赋值中也同样如此。当进行解构赋值的属性不存在时，同样会得到undefined。 123var &#123; boots &#125; = character console.log(boots)// &lt;- undefined 当解构声明中访问的是一个嵌套属性，并且嵌套属性的父对象是null或undefined时，会抛出异常，就像在其他情况下访问null或undefined的属性会报错一样。 1234var &#123; boots: &#123; size &#125; &#125; = character // &lt;- Exceptionvar &#123; missing &#125; = null// &lt;- Exception 由于解构赋值主要是语法糖，所以看一下下面的ES5等价代码，就能够清楚地知道上述的代码为何会抛出异常了。 123var nothing = nullvar missing = nothing.missing // &lt;- Exception 在解构赋值中，我们可以为这些值为undefined的属性提供默认值。默认值可以使任何类型的值：如数值、字符串、函数、对象或者对其他变量的引用等。 123var&#123;boots=&#123;size:10&#125;&#125;=characterconsole.log(boots)// &lt;- &#123; size: 10 &#125; 默认值在嵌套属性的解构中也可以使用。 123var &#123; metadata: &#123; enemy = 'Satan' &#125; &#125; = character console.log(enemy)// &lt;- 'Satan' 当和别名结合使用时，应如下所示，将别名放在前面，默认值放在后面： 1var &#123; boots: footwear = &#123; size: 10 &#125; &#125; = character 在解构的模式部分可以使用可计算属性名语法。这种情况下，则必须提供一个别名作为变量名。这是因为可计算属性名中允许任意表达式，所以编译器无法推断出变量的名称。下例中，即使用了别名和可计算属性从character对象中提取出了boots属性。 123var &#123; ['boo' + 'ts']: characterBoots &#125; = character console.log(characterBoots)// &lt;- true 这一写法可能没有什么用途，因为characterBoots = character[type]比{ [type]: characterBoots } = character简单很多。也就是说，可计算属性名声明对象字面量的属性名时很有用，但是在解构赋值中却恰恰相反。 这些就是对象解构的相关内容。那么数组的解构又是怎么样的呢？ 2.3.2 数组的解构数组的解构语法和对象解构比较相似。下例中，展示了如何将coordinates数组解构成x和y两个变量。可以看到，我们不再是使用花括号，而是使用了方括号，这就表示我们使用的是数组解构，而不是对象解构。使用解构我们能够在不显示引用索引情况下清晰地为数组中的值命名，而不需要使用类似x = coordi nates[0]这样的代码。 1234var coordinates = [12, -7] var [x, y] = coordinates console.log(x)// &lt;- 12 使用数组解构时，我们可以跳过不感兴趣或者不需要引用的值。 1234var names = ['James', 'L.', 'Howlett'] var [ firstName, , lastName ] = names console.log(lastName)// &lt;- 'Howlett' 和对象解构相似，数组解构也可以设定默认值。 1234var names = ['James', 'L.']var [ firstName = 'John', , lastName = 'Doe' ] = names console.log(lastName)// &lt;- 'Doe' 在ES5中，当我们需要交换两个变量的值时，通常需要引入第三个临时变量。如以下代码所示。 12345var left=5var right = 7 var aux = left left = right right = aux 解构使我们可以不用声明aux变量，而是专注于原本的意图。这也是解构能够使我们的表达更加清晰有效率的另一种使用场景。 123var left=5var right = 7[left, right] = [right, left] 我们将要讨论最后一个关于解构的内容，即函数的参数。 2.3.3 函数参数的默认值ES6中，函数的参数也能够指定默认值。下面的这个例子中，就为exponent参数定义了一个最常用的默认值。 123function powerOf(base, exponent = 2) &#123; return Math.pow(base, exponent)&#125; 箭头函数的参数也可以指定默认值。当为箭头函数的参数指定默认值时，哪怕只有一个参数，也要用圆括号将箭头函数的参数列表包裹起来。 1var double = (input = 0) =&gt; input * 2 和一些其他编程语言不同，不限制只能给函数的最后一个参数设置默认值。可以为任何一个参数设置默认值。 12345functionsumOf(a=1,b=2,c=3)&#123; return a+b+c&#125;console.log(sumOf(undefined, undefined, 4)) // &lt;- 1 + 2 + 4 = 7 在JavaScript中，向函数传递一个包含多个属性的options对象参数的情况是再常见不过的了。如果使用函数的时候没有传递options，我们可以为其设定一个默认值。具体代码如下所示。 12345678var defaultOptions = &#123; brand: 'Volkswagen', make: 1999 &#125; function carFactory(options = defaultOptions) &#123; console.log(options.brand) console.log(options.make)&#125;carFactory()// &lt;- 'Volkswagen' // &lt;- 1999 这一方法存在一个问题，即如果carFactory的使用者传入了一个options对象，那么所有的默认值就都没用了。 123carFactory(&#123; make: 2000 &#125;) // &lt;- undefined// &lt;- 2000 我们可以同时使用函数参数的默认值和解构赋值，这样能够获得更好的结果。 2.3.4 函数参数的解构与只提供一个默认值相比，还有一个更好的方法，那就是对整个options进行解构，并在解构模式中，为每个属性都指定默认值。这个方法使我们能够不通过options对象就能引用options中的每个选项，但我们也不能直接引用options了，这在某些情况下可能会发生问题。 12345function carFactory(&#123; brand = 'Volkswagen', make = 1999 &#125;) &#123; console.log(brand)console.log(make)&#125;carFactory(&#123; make: 2000 &#125;) // &lt;- 'Volkswagen'// &lt;- 2000 然而，这种情况下，如果使用者没有传入options对象，默认值会再一次缺失。也就是说，如果没有传入options对象参数，carFactory会报错。不过如下面的代码所示，为options添加一个空对象作为默认值，就能避免这一问题。然后这个空对象就会被解构模式中设定了默认值的属性一一填充。 12345678910function carFactory(&#123; brand = 'Volkswagen', make = 1999&#125; = &#123;&#125;) &#123; console.log(brand) console.log(make)&#125;carFactory()// &lt;- 'Volkswagen' // &lt;- 1999 除了默认值以外，我们还可以在函数参数中使用解构来描述函数能够处理的对象的结构。参考以下代码，假设有一个car对象，对象上包含多个属性。car对象中描述了它的拥有者、类型、品牌、制造时间以及拥有者购买时的偏好。 1234567891011121314var car=&#123; owner: &#123; id: 'e2c3503a4181968c', name: 'Donald Draper' &#125;, brand: 'Peugeot', make: 2015, model: '208', preferences: &#123; airbags: true, airconditioning: false, color: 'red' &#125;&#125; 如果在某个函数中只想提取对象中的某些属性作为参数，则可以通过解构来提前显示地引用这些属性。这样做的好处就是在看到函数声明时，我们就能知道函数中需要使用哪些属性。 当我们提前解构所需要的每个属性时，当输入不正确时，就很容易发现。下面的例子中向我们展示了如何在参数列表中指定我们所需的每一个属性，从而表明getCarProductiModel结构方法能够处理的参数对象解构。 1234567var getCarProductModel = (&#123; brand, make, model &#125;) =&gt; (&#123; sku: brand + ':' + make + ':' + model, brand, make, model&#125;)getCarProductModel(car) 除了设置默认值和填充options对象外，解构还有很多其他的有用之处。下面让我们一起来看看。 2.3.5 解构的用法当一个函数返回一个对象或者数组时，解构使我们能够更简洁地处理返回值。 如下例所示，函数返回一个包含一些坐标的对象，而我们只对其中的x和y感兴趣。我们可以不用借助中间变量point，并且不会影响代码的可读性。 1234function getCoordinates() &#123; return &#123; x: 10, y: 22, z: -1, type: '3d' &#125;&#125;var &#123; x, y &#125; = getCoordinates() 默认值的使用会产生一定的重复。假设存在一个random函数，函数会生成一个值在min和max之间的随机整数，默认生成1和10之间的值。在类似Python和C#的强类型语言里，使用这样一种方式来作为命名属性的替代方案是一件特别有趣的事情。这种能够为选项参数定义默认值，并且允许使用者独自覆盖的模式使用起来是非常灵活的。 1234567function random(&#123; min = 1, max = 10 &#125; = &#123;&#125;) &#123; return Math.floor(Math.random() * (max - min)) + min&#125;console.log(random())// &lt;- 7console.log(random(&#123; max: 24 &#125;)) // &lt;- 18 解构也非常适合用于正则表达式中。解构使我们能够在不使用索引值的情况下命名匹配结果数组中的数据。下面就有这样一个例子：通过正则表达式解析一个简单的日期，并且使用解构将解析出来的值分别赋值给对用的日期部分，即年月日等。在本例子中，匹配结果数组的第一个元素是原始输入，所以我们直接丢弃即可。 12345function splitDate(date) &#123; var rdate = /(\\d+).(\\d+).(\\d+)/ return rdate.exec(date)&#125;var [ , year, month, day] = splitDate('2015-11-06') 需要注意的是正则表达式未匹配的情况，这时匹配结果为null。所以如下例所示，最好在结构之前进行错误处理。 12345var matches = splitDate('2015-11-06') if (matches === null) &#123; return&#125;var [, year, month, day] = matches 接下来我们来关注一下扩展运算符和reset参数。 2.4 Rest参数和扩展运算符在ES6之前，处理任意数量的函数参数是很复杂的，必须借助arguments来处理。arguments不是一个数组，但是具有length属性。通常，我们会使用Array#slice.call方法来将arguments对象转换为真正的数组。具体代码如下所示。 123456function join() &#123; var list = Array.prototype.slice.call(arguments) return list.join(', ')&#125;join('first', 'second', 'third') // &lt;- 'first, second, third' ES6中有更好的方式解决这一问题，那就是rest参数。 2.4.1 Rest参数我们可以在函数的最后一个参数前添加三个点，将该参数转变为一个特殊的“剩余参数”。当rest参数是函数中的唯一一个参数时，则它会获取到所有传入函数的参数：这和上述使用.slice处理的结果是一样的，但是这样能够取消对复杂结构arguments的需求，而是在参数列表中就进行制定。 12345function join(...list) &#123; return list.join(', ')&#125;join('first', 'second', 'third') // &lt;- 'first, second, third' rest参数之前的参数不会被包含在list参数中。 12345function join(separator, ...list) &#123; return list.join(separator)&#125;join('; ', 'first', 'second', 'third') // &lt;- 'first; second; third' 注意，如果是箭头函数中包含rest参数，哪怕只有一个参数，也必须放置在圆括号内。否则，会抛出SyntaxError格式异常。下面的例子就完美展示了如何结合箭头函数和rest参数生成更简洁的函数式表达式。 1234var sumAll = (...numbers) =&gt; numbers.reduce( (total, next) =&gt; total + next)console.log(sumAll(1, 2, 5)) // &lt;- 8 与上面的代码相比，明显地，使用ES5实现的相同函数要更加复杂。虽然上面的实现方式较为简洁，但是这样的sumAll函数会对没有使用过.reduce方法的使用者产生困扰，并且同时使用两个箭头函数也会带来一定的困扰。这是一个复杂的权衡，也是我们将在本书第二部分讨论的内容。 12345678function sumAll() &#123; var numbers = Array.prototype.slice.call(arguments) return numbers.reduce(function (total, next) &#123; return total + next &#125;)&#125;console.log(sumAll(1, 2, 5)) // &lt;- 8 接下来我们一起讨论下扩展运算符。它也会用到...，但用法会稍有不同。 2.4.2 扩展运算符扩展运算符可以用于将可遍历对象转换为数组。扩展运算符能够有效地将数组或者函数调用表达式展开。下例中，使用了...arguments将函数参数转换成了一个数组。 12345function cast() &#123; return [...arguments]&#125;cast('a', 'b', 'c') // &lt;- ['a', 'b', 'c'] 我们也可以使用扩展运算符将一个字符串分割成数组，数组中元素为组成字符串的每个字符。 12[...'show me']// &lt;- ['s', 'h', 'o', 'w', ' ', 'm', 'e'] 扩展运算符的左右还可以添加其他内容，并且会得到你所期待的结果。 12345function cast() &#123; return ['left', ...arguments, 'right']&#125;cast('a', 'b', 'c')// &lt;- ['left', 'a', 'b', 'c', 'right'] 扩展运算符非常适合用来拼接多个数组。如下例所示，我们可以在一个数组字面量中展开任意数组，将其中的元素放置到指定位置。 123var all = [1, ...[2, 3], 4, ...[5], 6, 7] console.log(all)// &lt;- [1, 2, 3, 4, 5, 6, 7] 值得一提的是，扩展运算符不是只能用于数组和arguments中，它可以用于任何对象字面量中。遍历器是ES6中新引入的一种机制，它允许我们将对象转换成一种可被遍历的内容，我们将在第4章深入讨论这一部分的内容。 shift操作和扩展运算当我们想要从一个数组的开头处获取一个或者两个元素，通常可以使用.shift方法。下面的代码虽然在功能上能够实现，但是却难以一眼就理解，因为代码中使用了两次.shift方法，但是每次从数组的开头取到的是不同的值。和许多其他的ES6之前的情况相似，重点是让语言去做我们想做的事情。 12345var list = ['a', 'b', 'c', 'd', 'e'] var first = list.shift()var second = list.shift() console.log(first)// &lt;- 'a' ES6中，可以将数组的解构和扩展运算符结合使用。下面的代码和前面的代码相似。我们仅用一句代码即可实现，并且这一行代码比重复使用list.shift方法更具描述性。 12var [first, second, ...other] = ['a', 'b', 'c', 'd', 'e'] console.log(other)// &lt;- ['c', 'd', 'e'] 使用扩展运算符我们可以关注所要实现的功能，不用关心语言本身。在ES6的新特性上，提高代码的表达力并减少在语言限制上所花费的时间是很常见的。 在ES6之前，当我们有一个动态的参数列表需要用于某个函数调用时，我们会使用.aplly方法。这么做并不优雅，因为.apply也会改变this的指向，而在此时，我们并不希望this指向自身。 1fn.apply(null, ['a', 'b', 'c']) 除了扩展数组之外，我们还可以在函数调用中使用扩展运算符。如下例所示，我们可以使用扩展运算符向multiply函数传递任意数值作为参数。 123456function multiply(left, right) &#123; return left * right&#125;var result = multiply(...[2, 3]) console.log(result)// &lt;- 6 在函数调用中扩展参数可以和常规参数一起使用，只有有必要，可以使用任意数量的扩展参数，如同上文在数组字面量中一样。下面示例中，调用了print方法，并传入了一对常规参数和一对在参数列表中扩展开的数组。注意，使用rest参数list能够取到所有传入的参数。扩展运算符和rest参数可以使代码意图更加清晰，且不会稀释代码库。 12345function print(...list) &#123; console.log(list)&#125;print(1, ...[2, 3], 4, ...[5]) // &lt;- [1, 2, 3, 4, 5] 使用.apply方法就是还有一个不足之处，即当和new关键字一起实例化对象时，会非常冗长。一起来看下使用new和.apply来创建Date对象的示例。先不管在JavaScript中日期中的月份是从0开始的，即11指12月。思考一下除了这之外，为了实例化一个对象，我们向语言做了多少妥协。 12new (Date.bind.apply(Date, [null, 2015, 11, 31])) // &lt;- Thu Dec 31 2015 如下所示，扩展运算符能够避免这些复杂性，我们只需要关注重要的内容。下例的new实例中，在Date函数使用了...来扩展动态的参数列表。 12new Date(...[2015, 11, 31]) // &lt;- Thu Dec 31 2015 下表总结了上述我们所讨论的扩展运算符的使用场景。 使用场景 ES5 ES6 数组的连接 [1, 2].concat(more) [1, 2, …more] 将一个数组放入列表中 list.push.apply(list, items) list.push(…items) 解构 a = list[0], other = list.slice(1) [a, …other] = list new关键字和apply方法 new (Date.bind.apply(Date, [null,2015,31,8])) new Date(… [2015,31,8]) 2.5 模板字符串和JavaScript中的常规字符串相比，模板字符串有着巨大的改善。如下所示，模板字符串不是使用单引号或者双引号进行声明，而是使用反引号”`”。 1var text = `This is my first template literal` 由于模板字符串使用反引号来作为定界符，则我们在使用模板字符串来声明字符串时就不需要再转义其中的&#39;和&quot;。具体示例如下： 1var text = `I'm \"amazed\" at these opportunities!` 模板字符串的功能中最值得一提的就是可以再其中插入JavaScript表达式。 2.5.1 字符串插值使用模板字符串，我们可以在模板中插入任意的JavaScript表达式。当执行到模板字符串表达式时，会计算表达式，并将结果返回。下例中，在模板字符串内插入了一个name变量。 1234var name = 'Shannon'var text = `Hello, $&#123; name &#125;!` console.log(text)// &lt;- 'Hello, Shannon!' 前面已经说了，除了变量之外，我们可以使用任意的JavaScript表达式。我们可以将模板字符串的表达式当做是模板执行之前定义的一个变量，然后将各变量和其余字符串连接起来。这么做的好处就是代码变得更容易维护，因为不需要再手动的将各字符串和表达式拼接起来。不过在这些表达式中所使用的变量、所调用的函数等都必须在当前作用域内是可用的。 你想要在模板字符串中插入怎样的内置表达式逻辑，都取决于你自己的编码风格。下面的代码片段实力化了一个Date对象，并将其放在模板字符串中。 12`The time and date is $&#123; new Date().toLocaleString() &#125;.` // &lt;- 'the time and date is 8/26/2015, 3:15:20 PM' 同样也可以在模板字符串中插入数学运算。 12`The result of 2+3 equals $&#123; 2 + 3 &#125;` // &lt;- 'The result of 2+3 equals 5' 甚至可以嵌套模板字符串，因为它们也是合法的JavaScript表达式。 12`This template literal $&#123; `is $&#123; 'nested' &#125;` &#125;!` // &lt;- 'This template literal is nested!' 模板字符串还有另一个好处，它支持多行字符串。 2.5.2 多行模板字符串在模板字符串之前，如果想要在JavaScript中表示一个多行字符串，必须借助转义符、字符串连接、数组，甚至是借助注释。下面的代码总结了ES6之前最常见的几种多行字符串表示法。 123456789101112131415var escaped = 'The first line\\n\\A second line\\n\\ Then a third line'var concatenated = 'The first line\\n' ` 'A second line\\n' ` 'Then a third line'var joined = [ 'The first line', 'A second line', 'Then a third line'].join('\\n') 在ES6中，可以使用反引号来表示。模板字符串默认支持多行字符串。如下可以看出，代码中不再需要借助\\n、连接符和数组。 1234var multiline = `The first lineA second line Then a third line` 多行字符串非常实用。比如，当需要在一堆HTML中插入多个变量时。如果需要在模板中展示一个列表，可以直接遍历这个列表，将对应的内容添加到相应的标签内。如下所示，这么做使得在模板中声明子组件变得非常容易。 1234567891011121314151617181920varbook=&#123; title: 'Modular ES6', excerpt: 'Here goes some properly sanitized HTML', tags: ['es6', 'template-literals', 'es6-in-depth']&#125;var html = `&lt;article&gt; &lt;header&gt; &lt;h1&gt;$&#123; book.title &#125;&lt;/h1&gt; &lt;/header&gt; &lt;section&gt;$&#123; book.excerpt &#125;&lt;/section&gt; &lt;footer&gt; &lt;ul&gt; $&#123; book.tags .map(tag =&gt; `&lt;li&gt;$&#123; tag &#125;&lt;/li&gt;`) .join('\\n ') &#125; &lt;/ul&gt; &lt;/footer&gt;&lt;/article&gt;` 上述代码会生出树下所示的HTML结构。可以看到空格被保留下来了[注释 3]，并且通过join方法中的一连串空格，保证了&lt;li&gt;标签能够正确缩进。 123456789101112&lt;article&gt; &lt;header&gt; &lt;h1&gt;Modular ES6&lt;/h1&gt; &lt;/header&gt; &lt;section&gt;Here goes some properly sanitized HTML&lt;/section&gt; &lt;footer&gt; &lt;ul&gt; &lt;li&gt;es6&lt;/li&gt; &lt;li&gt;template-literals&lt;/li&gt; &lt;li&gt;es6-in-depth&lt;/li&gt; &lt;/ul&gt; &lt;/footer&gt;&lt;/article&gt; 多行模板字符串在缩进方面存在问题。下例中，函数内包含一个模板字符串，模板字符串内的代码都有着同样缩进。我们可能会期待最终的结果是没有缩进的，但是最后字符串的前面会保留有四个空格的缩进。 12345678910function getParagraph() &#123; return ` Dear Rod, This is a template literal string that's indented four spaces. However, you may have expected for it to be not indented at all. Nico `&#125; 我们可以通过下面这样的通用函数来将结果字符串中每一行的缩进移除，虽然这么做并不明智。 1234567function unindent(text) &#123; return text .split('\\n') .map(line =&gt; line.slice(4)) .join('\\n') .trim()&#125; 有些时候，最好是在将插值表达式的结果插入模板之前就进行预处理。对于这些更进一步的使用场景，可能需要用到另一种模板字符串，即标签模板。 2.5.3 标签模板通常情况下，JavaScript中\\具有特殊的含义，代表转义符。比如，\\n表示换行，\\uoof1表示ñ等。通过String.raw标签模板可以使得转义字符不进行转义。下面代码展示了如何使用String.raw，其中\\n并没有被解释成换行。 12345var text = String.raw`\"\\n\" is taken literally. It'll be escaped instead of interpreted.` console.log(text)// \"\\n\" is taken literally.// It'll be escaped instead of interpreted. 模板字符串的前缀String.raw是一个标签模板，用于解析模板字符串。标签模板接受一个数组参数和其他参数，数组中包含模板的每一个静态部分，其他参数对应每个表达式的计算结果。 思考一下以下代码中的标签模板。 1tag`Hello, $&#123; name &#125;. I am $&#123; emotion &#125; to meet you!` 实际上，标签模板最终会被解释为如下所示的函数调用。 12345tag( ['Hello, ', '. I am ', ' to meet you!'], 'Maurice', 'thrilled') 依次取出模板中的每个部分，并和相邻的表达式拼凑在一起，直到最终拼凑完模板中的所有部分，则为结果字符串。如果不知道默认模板字符串tag内部是如何实现的，参数列表理解起来比较困难。所以我们先学习一下tag的内部实现。 下面的代码是默认标签tag的一种可能实现方式。它的功能与不指定其他标签模板进行模板字符串处理时功能相同。它会将parts数组归纳为一个值，这个值以模板的第一部分开头，依次连接values中的值和模板中的内容，最终的值就是模板字符串的计算结果。通过rest参数语法来获取...value，能够更容易获取到模板字符串中每个表达式的计算结果。并且我们使用了带有隐式return语句的箭头函数，这样函数语句看起来更加简单。 12345function tag(parts, ...values) &#123; return parts.reduce( (all, part, index) =&gt; all + values[index - 1] + part )&#125; 可以通过以下代码来试运行上述的tag模板。可以看到，运行结果和不适用tag时相同，这是因为上述代码正是对默认模板行为的实现。 12345var name = 'Maurice'var emotion = 'thrilled'var text = tag`Hello, $&#123; name &#125;. I am $&#123; emotion &#125; to meet you!` console.log(text)// &lt;- 'Hello Maurice, I am thrilled to meet you!' 标签模板还有很多其他用法。比如，可以用来将用户输入变为大写，这样能够使得字符串看起来更加讽刺。下面的代码就实现了这一功能。相比与前面的tag，只是做了一些简单的修改，从而使得任意插入的字符串都转为大写形式。 123456789function upper(parts, ...values) &#123; return parts.reduce((all, part, index) =&gt; all + values[index - 1].toUpperCase() + part )&#125;var name = 'Maurice'var emotion = 'thrilled'upper`Hello, $&#123; name &#125;. I am $&#123; emotion &#125; to meet you!` // &lt;- 'Hello MAURICE, I am THRILLED to meet you!' 标签模板还有一个更加有用的用法，即可以通过标签模板来保证模板中插入的表达式的安全性。假设有一个模板，其中的所有表达式都是用户输入的内容，我们可以通过一个虚构的sanitize库来移除HTML标签和类似的危害，从而阻止用户在我们的网站中诸如恶意的HTML，防止跨域脚本攻击(XSS)。 123456789function sanitized(parts, ...values) &#123; return parts.reduce((all, part, index) =&gt; all + sanitize(values[index - 1]) + part )&#125;var comment = 'Evil comment&lt;iframe src=\"http://evil.corp\"&gt; &lt;/iframe&gt;'var html = sanitized`&lt;div&gt;$&#123; comment &#125;&lt;/div&gt;` console.log(html)// &lt;- '&lt;div&gt;Evil comment&lt;/div&gt;' 看，恶意的&lt;ifram&gt;差点就得逞了。接下来，我们继续学习ES6的语法改变——let和const声明。 2.6 let和const声明let声明是ES6中最广为人知的特性之一。它和var声明功能相似，但是它有着不同的作用域规则。 关于作用域，JavaScript有着一套非常复杂的规则集，以致于能弄疯很多初次尝试弄懂JavaScript变量工作原理的程序员。最终，当你知道了变量提升后，才开始对JavaScript有一点点感觉。变量提升是指不管变量声明在代码的哪个位置，它都会被提升到所在作用域的顶部。参看以下示例代码： 12345678910function isItTwo(value) &#123; if (value === 2) &#123; var two = true &#125; return two &#125;isItTwo(2)// &lt;- true isItTwo('two') // &lt;- undefined 尽管two是在if代码分支语句中声明的，但是可以在分支语句外访问到，所以上面的代码能够正常工作。这一行为是因为var声明会绑定到所在封闭作用域，如函数作用域或者顶级作用域。结合变量的提升，这就意味着前面缩写的代码将会被解释成如下所示的代码。 1234567function isItTwo(value) &#123; var two if (value === 2) &#123; two = true &#125; return two &#125; 不管我们喜欢与否，与使用块级作用域的变量相比，变量提升更加让人困惑。块级作用域通过花括号来声明，而不是函数。 2.6.1 块级作用域和let声明如果我们想要一个更深的作用域，通过块级作用域，我们可以在现有分支代码语句(如if、for或while)的基础上，嵌套任意新的{}块即可，而不需要声明新的函数。或许你还不知道，只要我们愿意，JavaScript允许创建任意数量的块。 123&#123;&#123;&#123;&#123;&#123; var deep = 'This is available from outer scope.'; &#125;&#125;&#125;&#125;&#125; console.log(deep)// &lt;- 'This is available from outer scope.' 如果使用var进行变量的声明，基于词法作用域，在deep变量声明所在块的外部仍然可以访问到该变量，并不会得到任何错误。但有时候这种情况能够抛出异常会更好，尤其是满足一下几个条件之一时： 访问内部变量会破坏代码的封装性 内部变量和外部变量没有任何关联 同级的兄弟块中也可能使用相同的变量名 某个父级块中已经使用了所要用的变量名，但是仍在内部使用该变量。 let声明是var声明的一个替代方案。它遵循块级作用域规则而不是默认的词法作用域规则。使用var时，只能通过嵌套函数来创建更深的作用域。但是使用let仅通过新增一对花括号即可创建更深的作用域。这就意味着通过{}块就可以创建一个新的作用域，而不需要创建一个新的函数。 12345678910let topmost = &#123;&#125; &#123; let inner = &#123;&#125; &#123; let innermost = &#123;&#125; &#125; // 在此处尝试访问innermost，会抛出异常&#125;// 在此处尝试访问inner，会抛出异常// 在此处尝试访问innermost，会抛出异常 let声明有一个非常有用的用法，如果在for循环中使用let，则变量的作用域会封闭在循环体内。下例就展示了这一用法。 1234567for(let i = 0; i &lt; 2; i++)&#123; console.log(i) // &lt;- 0 // &lt;- 1&#125;console.log(i)// &lt;- i is not defined 在循环内声明的let变量会被封闭在每一次的循环内部，哪怕在函数体异步函数调用中使用这些变量也能够像预期一样工作，这一点和使用var声明的变量恰恰相反。我们一起看一下具体的例子。 首先，我们看一个关于var作用域工作原理的典型示例。i变量会绑定到printNumbers函数作用域，在循环添加每个timeout回调时，它的值会一直增加到10。等到每隔100毫秒执行每个回调函数时，i的值就是10，所以每次都会输出10。 12345678function printNumbers() &#123; for(vari=0;i&lt;10;i++)&#123; setTimeout(function () &#123; console.log(i) &#125;,i*100) &#125;&#125;printNumbers() 相反地，如果使用let声明，会将变量绑定到块级作用域。虽然每次循环仍然会递增变量的值，但是每一次循环中都会创建一个新的绑定。也就是说每次添加timeout回调时，每个回调函数都会持有一个绑定保存当前变量i的引用，所以最终会输出期望中的结果：0到9。 123456789function printNumbers() &#123; for(let i = 0; i &lt; 10; i++)&#123; setTimeout(function () &#123; console.log(i) &#125;,i*100) &#125; &#125;printNumbers() let还涉及“暂时性死区”这一概念。 2.6.2 暂时性死区毫无疑问：下面这样的代码片段，必然会抛出异常。从作用域的开始，到let声明的执行之前，访问let声明的变量会报错。这就是所谓的暂时性死区(TDZ，Temporal Dead Zone)。 12345&#123; console.log(name) // &lt;- ReferenceError: name is not defined let name = 'Stephen Hawking'&#125; 如果在let name声明执行之前访问该变量，程序会抛出异常。在name变量定义之前，声明一个函数，在函数内引用name变量时没问题的，只要不在暂时性死区内执行函数即可。在let name声明之前，都是name的暂时性死区。下面的代码并不会报错，因为return name并没有在name的暂时性死区内执行。 123456function readName() &#123; return name&#125;let name = 'Stephen Hawking' console.log(readName())// &lt;- 'Stephen Hawking' 相反，下面的代码会报错，因为在name离开暂时性死区之前就访问了name变量。 123456function readName() &#123; return name&#125;console.log(readName())// ReferenceError: name is not defined let name = 'Stephen Hawking' 注意，即使在声明的时候没有对name进行赋值，上面的示例行为并不会发生改变。下面的代码同样会抛出异常，同样因为在暂时性死区内访问了name变量。 12345function readName() &#123; return name&#125;console.log(readName())// ReferenceError: name is not defined let name 下面的代码能够正常工作，是因为它在离开了暂时性死区后才访问name变量。 12345function readName() &#123; return name&#125;let name console.log(readName()) // &lt;- undefined 只有一个特别的地方需要记住，即在函数声明中访问暂时性死区中的变量时没问题的，只要访问暂时性死区中变量的语句在let声明语句之后。 TDZ的主要目的是为了更容易地捕获错误，防止在用户代码声明变量前就访问变量，从而避免一些不可预期的行为。在ES6之前，由于变量的提升和不良的编码习惯，这一情况是非常常见的。在ES6中能够很简单地避免该问题。要记住提升仍然适用于let，即变量在作用域的开始就会创建，但是会产生暂时性死区，这些变量在声明语句没有执行前无法访问，在离开暂时性死区之后才能够访问。 我们已经学习了暂时性死区，是时候学习const声明了。它与let相似，但是也有很多不同。 2.6.3 Const声明const声明和let相似，都只在块级作用域内有效，也存在暂时性死区。实际上，暂时性死区就是为了const而实现的，之后为了保持统一，也应用在了let上。const之所以需要暂时性死区，是因为如果没有暂时性死区，则可以在const声明执行之前给提升的const变量赋值，这样执行声明语句时就会报错。暂时性死区就是为了保证只在const声明时进行赋值而实现的，可以避免使用let时的一些潜在问题，并且使得其他依赖于暂时性死区的特性实现起来更加容易。 下例展示了const和let一样只在块级作用域内有效。 12345678const pi = 3.1415 &#123; const pi = 6 console.log(pi) // &lt;- 6&#125; console.log(pi) // &lt;- 3.1415 前面提到let和const有很多不同之处。第一个不同之处就是使用const声明的变量必须在声明时就进行初始化，如下例所示： 12const pi = 3.1415const e // SyntaxError, missing initializer 除了在声明时初始化外，使用const声明的变量无法重复赋值，即const初始化之后，无法再改变它的值。在严格模式下，改变const变量的值会报错。非严格模式下，不会报错，改变不生效，如下面的代码所示。 1234const people = ['Tesla', 'Musk'] people = []console.log(people)// &lt;- ['Tesla', 'Musk'] 需要注意的是，创建一个const变量并不意味值所赋的值不可改变。这是一个常见的混淆点，所以强烈建议仔细阅读以下警告信息。 使用const声明的变量并不是不可变的使用const声明只是意味着所声明的变量会一直持有对同一个对象和初始值的引用，所以保持不变的只是这个引用。引用保持不变，但是引用所指向值并不是不可变的。 从下例可以看出，尽管people的引用不能被改变，但是数组本身确实可以修改。如果数组时不可变的，下面的结果则是不可能的。 1234const people = ['Tesla', 'Musk'] people.push('Berners-Lee') console.log(people)// &lt;- ['Tesla', 'Musk', 'Berners-Lee'] const声明只会禁止变量绑定到一个新的引用。也可以从另一方面来说明。下面的代码中，我们使用const创建了一个people变量，然后将这个变量赋值给了一个普通的用var声明的humans变量。我们可以给humans重新赋值其他引用，是因为它并不是使用const声明的。但是我们不能将其他引用赋给people，因为它是通过const声明的。 12345const people = ['Tesla', 'Musk'] var humans = peoplehumans = 'evil' console.log(humans)// &lt;- 'evil' 如果想要确保值不变，可以使用Object.freeze函数。使用Object.freeze可以禁止对传入的对象进行扩展，如下例所示： 123456const frozen = Object.freeze( ['Ice', 'Icicle', 'Ice cube'])frozen.push('Water')// Uncaught TypeError: Can't add property 3 // object is not extensible 现在我们一起讨论下const和let的优势吧。 2.6.4 const和let的优势永远不要为了使用新特性而使用新特性。ES6特性应该合理应用在能够真正提升代码可读性和可维护性的地方。很多情况下，let声明能够简化一部分代码逻辑，比如当我们需要在函数的顶部进行var声明，从而保证变量的提升不会产生意想不到的结果。使用let就可以不用在整个函数的顶部进行声明，可以在块级作用域的顶部声明，可以减少思维从作用域顶部开始延续的范围。 使用const声明能够有效地避免一些事故。下面的代码展示一个可能会发生错误的场景：当我们将items的引用传递给checklist函数，这个函数会返回一个todoAPI用于操作传入的items引用。当items变量被改变，引用指向其他数组时，情况就完全不一样了——todoAPI仍然会从操作items之前引用的值，而items引用了其他的值。 1234567891011121314var items = ['a', 'b', 'c'] var todo = checklist(items) todo.check() console.log(items)// &lt;- ['b', 'c']items = ['d', 'e']todo.check()console.log(items)// &lt;- ['d', 'e'], 如果使用const声明items，结果将会是['c']function checklist(items) &#123; return &#123; check: () =&gt; items.shift() &#125; &#125; 这种问题是很难调试的，可能需要花不短的时间，才能查出引用被改变而导致的问题。如果const声明能够防止这一情景，因为使用const会在运行时报错（严格模式下），从而能够在问题发生时定位到问题所在。 使用const声明还有一个相似的好处就是能够显示地定义不可重复赋值的变量。const表明变量引用的绑定是只读的，这样我们在阅读代码时就不用关心这些常亮了。 如果我们默认使用const声明，使用let声明需要重复赋值的变量，所有的变量都会遵循相同的作用域规则，会使得代码更加易于理解。为什么会提议默认使用const声明方式呢，是因为只需要使用它就能够达成以下几点目标：禁止重新赋值，遵循块级作用域，并且在变量声明语句执行之前不能访问变量。let语句虽然允许重新赋值，但是它的行为和const类似，所以如果需要一个可以重新赋值的变量可以选择使用let声明。 另一方面，var声明方式更加复杂，如由于函数作用域规则，在分支语句中使用较为困难；并且var允许重新赋值，且可以在变量声明语句执行访问变量。由于var做的事情并不如const和let多，所以var不优先级使用，在现代JavaScript代码库中并不常见。 通过本章，我们学习了默认使用const，在需要重新赋值时使用let。第九章我们将会学习更多关于这一选择的原因。 [注释 1] 和polyfill一样，ponyfill是对于在每一个JavaScript运行环境中都不可用的功能的用户实现。polyfill主要是试图修补运行环境，从而使其看起来内部支持某一特性，而ponyfill是将运行环境中缺失的功能实现成为一个独立的模块，并且不会污染运行环境。这样做的好处是不会超出第三方库对于运行环境的期望，因为它们可能并不知道我们的polyfill。 [注释 2] Label用于定义指令。可以用在goto语句中，用来指明需要跳转的指；也可以用在break语句中，表示所要跳出的序列；还有continue语句中，表示想要执行的序列。 [注释 3] 在使用多行模板字符串时，空格并不会被自动保留。不过多数情况下，我们只需要提供足够多的缩进就能使其保留空格。所以缩进时需要注意，避免导致在代码块嵌套时产生不正确的缩进。","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://verymuch.com/tags/翻译/"}]},{"title":"第一章 ECMAScript 和 JavaScript 的未来","slug":"第一章-ECMAScript-和-JavaScript-的未来","date":"2017-10-23T10:54:46.000Z","updated":"2017-11-14T13:39:10.000Z","comments":true,"path":"2017/10/23/第一章-ECMAScript-和-JavaScript-的未来/","link":"","permalink":"http://verymuch.com/2017/10/23/第一章-ECMAScript-和-JavaScript-的未来/","excerpt":"JavaScript已经从1995年的一个为了赢得战略性优势的市场营销策略，变成了如今(2017年)世界上最广泛使用的应用运行平台中的核心编程语言。该语言不再是只运行在浏览器中，现在也被用于创建桌面和移动应用、硬件设备中，甚至NASA的太空服设计中。 JavaScript是如何做到这一步的呢，接下来它又该怎么做呢？","text":"JavaScript已经从1995年的一个为了赢得战略性优势的市场营销策略，变成了如今(2017年)世界上最广泛使用的应用运行平台中的核心编程语言。该语言不再是只运行在浏览器中，现在也被用于创建桌面和移动应用、硬件设备中，甚至NASA的太空服设计中。 JavaScript是如何做到这一步的呢，接下来它又该怎么做呢？ 1.1 JavaScript标准简史1995年，网景(NetScape)公司想要构建一个动态的web页面，而这HTML是无法实现的。Brendan Eich最初进入网景就是为了给浏览器开发一个功能类似于Scheme的语言。但在他加入之后，他才发现他的上级主管希望这一语言看起来像Java，而且这一决定已然正在实施。 Brendan花了十天的时间创建了JavaScript的第一个原型，主要采纳了Scheme中的一等公民函数和Self中的原型作为它的主要构成。JavaScript这一初始版本的代号为Mocha。这时，它还没有包含数组或者对象字面量，以及会导致警告的各类错误。异常处理方面的缺失也是为什么到今天仍有很多操作返回NaN或者undefined的原因。Brendan在DOM0和JavaScript初始版本上所做的工作为现在的标准工作奠定了基础。 1995年9月，Netscape Navigator 2.0测试版发布，JavaScript开始与其一起发布，这一版本是JavaScript的修订版，被命名为LiveScript。同年12月，当Navigator 2.0 beta 3发布时，又被重新命名为JavaScript(由Sun注册商标，现在被Oracle持有)。此后不久，网景公司推出了服务端JavaScript的实现，用于在网景企业服务器中运行脚本，并将其命名为LiveWire[注释 1]。1996年，由微软通过逆向工程技术实现的JavaScript版本——JScript，与IE3一起发布。JScript也可以用于Internet Information Server(IIS)的服务端。 1996年，该语言由ECMA的TC39技术委员会标准化为ECMA-262规范，并命名为ECMAScript(ES)。一方面，Sun公司不同意将JavaScript商标转让给ECMA；另一方面，虽然微软提供了JScript，但是其他成员公司并不想使用该名称。因此，使用了ECMAScript这个名字。 当时，有关于网景JavaScript和微软JScript实现差异的讨论几乎占用了整个TC39标准委员会议的大部分时间。尽管如此，委员会还是取得了成果：向后兼容被定为黄金准则。比如，引入严格相等运算符(===和!==)，而不影响依赖松散相等比较算法的现有程序。 ECMA-262的第一版在1997年6月发布。次年六月，该标准经过国际ISO机构的诸多严格审查，在ISO/IEC 16262国际标准下进行了完善，并正式化成为第二版。 1999年12月，第三版发布。该版本对正则表达式、switch语句、do/whille、try/catch、Object#hasOwnProperty以及一些其他改变进行了标准化。这些功能中的大部分功能在网景的JavaScript运行环境SpiderMonkey中都已经可以使用了。 之后不久，TC39发布了ES4规范的草案。ES4的早期工作促使了2000年年中JScript.NET的产生，并最终在2006年促使了Flash中ActionScript 3的产生。 关于JavaScript应该如何向前推进难以达成统一的观点，这就导致规范工作停滞不前。对于Web标准来说这是一个很微妙的时刻：微软几乎垄断了整个Web行业，但是他们对于制定标准却毫无兴趣。 2003年，AOL裁掉了50名网景员工[注释 4]，Mozilla基金会因此成立了。同时，由于微软占据了超过95%的网络浏览市场份额，TC39 被迫解散。 直到两年后，Brendan在Mozilla以Firefox日益增长的市场份额为杠杆使得微软回归，ECMA才得以重新开始TC39的相关工作。2005年年中，TC39再次开始召开定期会议。对于ES4，计划引入模块系统、类、遍历器(Iterator)、生成器(Generator)、解构赋值、类型注释、尾调用优化、代数输入以及其他各类功能。由于这一项目太过庞大，导致了ES4的规范工作一次又一次的推迟。 2007年，委员会主要有两种立场：一部分人主张规范ES3.1，这一版本只是在ES3的基础上新增更多的方法；另一个立场则是主张规范ES4，虽然这部分内容则是过度设计并且有一定不足之处的。直到2008年[注释 5]，如前所提ES3.1才讨论通过，之后更名为ES5。尽管ES4最终被废弃了，除了其中一些仍在考虑以及很少的被废弃的功能，其中的很多功能都最终加入到了ES6中(ES6在决议时的代号是Harmony)。ES3.1中更新的内容，是ES4能够逐渐实现的基础。 2009年12月，ES3发布十周年，ECMAScript第五版发布。这一版本对于该语言规范进行了更实用的扩展，使得该语言规范在浏览器中得到了普遍的实现。这一版本主要增加了get和set存取器、Array原型中的函数扩展、反射机制和内省机制以及原生支持JSON解析和严格模式。 两年以后，2011年6月，该规范再一次进行了审查和编辑，形成了第三版的国际标准ISO/IEC 16262:2011，并正式化为ECMAScript5.1。 之后TC39又用了四年的时间来规范ECMAScirpt 6，并于2015年6月发布。第六版是该语言发布以来改动最大的一次，这一版本实现了许多ES4中被推迟到Harmony决议中的提案。通过本书，我们将深入探讨ES6。 在ES6进行规范化的同时，2012年，WHATWG(一个旨在推动web发展的标准组织)开始着手记录ES5.1和浏览器实现在兼容性和可操作性方面的差异。这一工作促成了String#substr的标准化，这一方法之前并不明确；统一了在HTML标签中包装字符串的几种方法，这些方法在不同的浏览器中是不一致的；并在Object.prototype上新增如__proto__和__defineGeter__等属性以及其他改进[注释 6]。这些工作最终形成了一份独立的Web ECMAScript规范，最终在2015年中被加入到附录B当中。附录B是ECMAScript规范核心中的建议部分，浏览器可以不遵照其进行实现。与此次geng新一起，附录B也成为了web浏览器的规范和要求。 第六版是JavaScript历史上一个意义重大的里程碑。除了成打的新功能之外，ES6也是ECMAScipt成为一个频繁更新的滚动标准的主要标志。 1.2 滚动标准ECMAScript在ES3之后，花费了十年的时间，但语言规范却并没有重大改变；之后又用了四年才形成ES6。显然，TC39的会议流程需要改善。之前的修订流程通常是期限驱动的。任何内容延迟达成一致，都会使得修订过程等待很长一段时间，这就会导致特征蠕动，进而引起更多的推迟。规范中一些较小的改动常常因为较大的新增内容而推迟。因此为了不再推迟，较大的新增内容在完成前需要承受很大的压力。 随着ES6的发布，TC39对提案修订的流程进行了优化[注释7]，使得它能够满足现在的预期：更快更一致的迭代，使得规范的开发更加大众化。基于这一点，TC39不再采用古老的书面提案形式，而是使用Ecmarkup(用于格式化ECMAScript规范的HTML语法超集)和GitHub来提交需求，大大增加了非会员的提案数量[注释 8]，他们就像是外在的参与者一样。这种新的形式是持续的，并且也更加透明：最新的规范草案随时都能够看到，而不是像之前那样，必须到网页上去下载Word文档或者PDF版本。 Firefox、Chrome、Edge、Safari以及Node.js对于ES6规范的支持均已超过95%[注释 9]。我们已经可以在这些浏览器中使用这些已经支持的功能，而不用等到它们对ES6的支持度达到100%才能使用。 新的流程引入了四个不同的成熟度阶段[注释 10]。越成熟的提案，最终被添加到规范中的可能性越大。 任何关于修改或者新增内容、还没有被提交为正式提案的讨论、想法或者提案都被认为是一个有雄心的“稻草人”提案(即stage 0)，不过只有TC39委员会成员可以创建稻草人提案。在写本书的时候，大概有十多个活跃的稻草人提案[注释 11]。 第一阶段表示提案被正式提出，并被期望解决交叉问题、和其他提案的交互问题以及实现上的问题。这一阶段的提案需要定义一个独立的问题，并给出该问题的具体解决方式。第一阶段的提案常常包括以下几方面的内容：高级API描述、说明性的用法示例、内部语法和算法的讨论。第一阶段提案可能会随着过程的不断进行发生很大的改变。 第二阶段的提案提供了规范的初始草案。从这时开始，就可以开始在运行环境中尝试具体的实现了。实现的方式可以采用补丁(polyfill)的形式，一种能使得运行环境支持提案内容的用户代码；也可以是一种引擎实现，原生地为提案内容提供支持；或者是使用构建工具将源代码转换，编译成现有引擎可以执行的代码。 第三阶段提案则是候选推荐。只有规范的编辑和指定的审查人员在最终的规范上签字确认，提案才能进入第三阶段。实现者也需要对该提案感兴趣才行。实际上，一个提案只有在满足下面三个条件之一时才能进入第三阶段：某个浏览器已经实现、高度可用的补丁或者在类似于Babel的实时编译工具中已经得到支持。第三阶段提案除了修复使用过程中新发现的问题外，不会再有其他的改动。 一个提案想要进入第四阶段，则必须有两个独立的实现方案能够通过验收测试。进入第四阶段的提案，最终会添加到ECMAScript的下一版当中。 该规范预计从现在开始每年发布都发布新版本。为了和年度发版计划统一，规范的版本从现在开始与出版的年份相关联。因此，ES6也是ES2015，之后将有ES2016而不是ES7，以及ES2017等等。实际上，ES2015这个称呼并没有被接受，仍被称为ES6。ES2016也是在命名约定改变之前就发布了的，因此有时候它也指ES7。因为ES6这一名称在社区中已经普遍被接受，我们抛开不谈，最终的规范版本将会是：ES6，ES2016，ES2017，ES2018等。 调整后的提案流程加上每年都进行时标准化形成了一个更加一致的标准发版过程，并且这也意味着规范的修订版本号变得不再那么重要。现在的重点是提案阶段，并且我们可以期待ECMAScript标准特定修订的引用变得更加不寻常【李老师重点关注语句】。 1.3 浏览器支持和辅助工具如果能够在JavaScript引擎中提供两种独立的实现方式，第三阶段的候选推荐提案最有可能在下一个版本加入到规范之中。实际上，通过实验性的引擎实现、补丁或者使用编译器，第三阶段的提案已经能够安全地在实际应用程序中使用了。其实第二阶段和更早阶段的提案也已经被JavaScript开发人员使用，这也加强了实现者和使用者之间的反馈循环。 Babel和类似的编译器，将代码作为输入，生成web平台(HTML、CSS或JavaScript)原生支持的输出。这些编译器通常被称为转换器，即编译器的一个子集。如果我们想要在代码中使用一个JavaScript引擎还没有普遍实现的提案，则Babel之类的编译器可以将使用了新提案的部分代码转换成现有JavaScript实现已经广泛支持的代码。 转换的过程可以在构建时进行，这样使用者可以得到所选JavaScript运行环境所支持的代码。这一机制改善了运行环境的支持基线，使得JavaScript开发者能够更早地利用新的语言功能和语法。这对于规范的编写者和实现者来说也是非常有利的，因为这样使得他们可以收集诸如可行性、渴求性以及可能存在的bug或者边界用例等方面的反馈。 编译器可以将我们所写的ES6源代码生成浏览器可以更加一致性解释的ES5代码。这是现在在生产环境中运行ES6代码的最可靠方式：通过编译生成ES5代码，这样大多数旧浏览器也能和现代浏览器一样正常执行。 这个方法同样适用于ES7及其之后的版本。因为语言规范将每年都会发布新版本，那么我们可以期待编译器能够支持ES2017输入、ES2018输入等等。同样地，随着浏览器的支持度越来越好，编译器可以逐渐降低为了支持ES6输出的复杂性，然后是ES7及其之后的版本。从这种情况来说，我们可以将JavaScript编译器看成一个移动的窗口，输入使用语言中最新可用的语法编写的代码，生成不影响浏览器支持的最新代码。 接下来，我们讨论一下如何在工作中使用Babel。 1.3.1 Babel编译器简介Babel可以将基于ES6特性的现代JavaScript代码编译成ES5代码。当我们使用的新特性还没有完全支持时，编译器更加受欢迎，因为它能够让我们写出可读性更高的代码。 Babel的在线REPL(读取-求值-打印 循环)转换器是一种很好的学习ES6的方法，而不需要经历安装Node.js和babel CLI、手动编译源码等任何麻烦。 REPL提供了一个源代码输入框，可以自动实时编译，编译后的代码在源代码的右侧。 现在我们在REPL中输入一些代码，你可以使用下面的这个代码片段： 123var double = value =&gt; value * 2 console.log(double(3))// &lt;- 6 如下图1-1所示，在输入的源码的右侧，我们能够看到转换后的ES5等价代码。源码更新后，编译结果也会实时更新。 Babel REPL是一个有效的工具，可以通过它来尝试书中介绍的一些特性。不过，需要知道的是Babel并不转换新的内置对象，如Symbol、Proxy和WeakMap。这些引用会被原封不动地保留下来了，依赖于执行Babel输出的运行环境提供这些内置对象。如果我们想要支持还没有实现这些内置对象的运行环境，我们可以在代码中引入babel-polyfill包。 在一些较老的JavaScript版本中，这些特性在语义上正确地实现很难，甚至完全不可能实现。补丁可能能够缓解这一问题，但是它们通常不能覆盖所有情况，因此需要做一些妥协。所以在我们将转换后的使用了内置对象和补丁的代码发布到生产环境时，我们需要很小心并且测试我们所假设的内容。 基于这种情况，我们最好等到浏览器整体支持这些新的内置对象时再开始使用它们。所以，建议大家使用不依赖于这些新内置对象的替代方案。同时，学习这些特性也是很重要的，这样我们对于JavaScript语言的理解才不会落后。 诸如Chrome、Firefox和Edge等现代浏览器现在已经支持ES2015及之后版本的大部分内容，所有当我们试着运行某个浏览器已经支持的新特性语法时，它们的开发者工具很好用。当生产级应用需要依赖于新的JavaScript特性时，推荐使用转换器进行编译处理，这样应用能够支持更多的JavaScript运行环境。 除了REPL，Babel还提供了一个Node.js的命令行工具包。你可以通过Node.js的包管理工具npm来安装。 下载Node.js。安装node后，就可以在终端内使用npm命令了。 开始之前，我们先创建一个项目目录以及一个package.json文件。package.json是一份描述Node.js应用的清单。我们可以通过npm命令行创建package.json文件。 123mkdir babel-setupcd babel-setupnpm init --yes 执行init命令时传递--yes参数表示不用询问我们，同意使用npm提供的默认值配置package.json文件。 同样，我们再创建一个example.js文件，并在其中加入以下代码，将其保存在刚刚创建的babel-setup下的src子目录中： 123var double = value =&gt; value * 2console.log(double(3))// &lt;- 6 在我们常用的终端中，输入下面两行命令可以安装Babel： 12npm install babel-cli@6 --save-devnpm install babel-preset-env@6 --save-dev 通过npm安装的包存放在项目根目录的node_modules目录下。可以通过创建npm script命令或者使用require声明来访问这些包。 --save-dev参数会将所安装的包作为开发依赖添加到package.json文件中。这样一来，当我们将项目移植到一个新的环境时，可以仅仅通过运行npm install命令就重新安装每个依赖。 @符号指明我们想要安装的包的特定版本。使用@6则是告诉npm安装babel-cli的6.x版本中最新的一个。这种优先策略对于我们的应用在将来不出问题是有好处的。因为这样一来，将永远不会安装7.0.0或者之后的版本。因为7.0.0之后的版本可能会包含一些在撰写本文时无法预见的破坏性变化。 接下来，我们用下面的值替换package.json中scripts属性。babel-cli提供的babel命令行功能可以将src目录下的全部内容，编译成所需的输出格式，并且将结果保存到dist目录，并且保留文件在原始目录中的结构： 12345&#123; \"scripts\": &#123; \"build\": \"babel src --out-dir dist\" &#125;&#125; 加上在之前各步骤中安装的包，一个最小的package.json文件看起来如下面的代码片段所示： 123456789&#123; \"scripts\": &#123; \"build\": \"babel src --out-dir dist\" &#125;, \"devDependencies\": &#123; \"babel-cli\": \"^6.24.0\", \"babel-preset-env\": \"^1.2.1\" &#125; &#125; scripts对象中列举的所有命令都可以通过npm run &lt;name&gt;来执行，通过这种方式执行会临时修改环境变量$PATH的值，因此我们才可以在没有在系统上全局安装babel-cli的情况下，找到babel-cli并在命令行执行。 如果你现在在终端内执行npm run build，你就能看到生成后的dist/example.js文件。输出的文件和我们的源文件是完全相同的。这是因为Babel并没有做任何的假设，所以我们需要事先配置它。在package.json之后创建一个.babelrc文件，并在其中写入以下JSON数据： 123&#123; \"presets\": [\"env\"]&#125; 前面我们通过npm安装的env预设向Babel之中添加了一系列的插件，从而可以将不同的ES6代码转换为ES5。这个预设包含很多内容，可以将类似example.js中所用的箭头函数转换成ES5的代码。通常情况下，Babel的env预设会开启最新的浏览器已经支持的特性相关转换插件。这一预设是可配置的，这意味着我们能够决定要覆盖多久之前的浏览器支持度。支持的浏览器越多，我们的编译包就越大。支持的浏览器越少，我们的用户满意度就越低。一如既往，研究的本质是确定对于Babel的env预设来说什么是正确的配置。默认地，每一个转换都会被开启，从而支持更多的运行环境。 现在如果我们再一次运行编译脚本，能够看到输出的是有效的ES5代码。 123456789» npm run build» cat dist/example.js\"use strict\"var double = function double(value) &#123; return value * 2&#125;console.log(double(3))// &lt;- 6 下面我们来学习一个不同种类的工具，代码检查工具eslint，可以帮助我们在应用项目中形成高质量的代码标准。 1.3.2 使用ESLint提高代码质量和一致性当我们开发一个代码库时，我们会分解那些冗余的或者没用的代码片段，编写新的代码片段，删除不再相关或必要的功能，并在兼容新的架构时进行代码块迁移。随着代码库的增长，编写代码库的团队也会随之改变：刚开始时可能只是几个人甚至只有一个人，但是随着项目规模的扩大，团队也会越来越大。 代码检测工具可以用来标识语法错误。现代的检测工具多是可定制的，可以帮助我们建立一个适用于团队中所有人的代码风格约定。通过坚持一致的代码风格和质量基准，可以使得团队在编码风格方面更加接近。不同的团队成员对于代码风格可能会有不同的意见，但是只要我们将代码检测工具用在合适的地方，并且意见上达成一致，则所有这些观点都可以被浓缩为风格规则。 除了确保程序能被解析，我们也可能想要防止throw抛出字符串字面量作为异常，或者不允许在生产环境中使用console.log和debugger语句。然而，要求必须所有的函数调用都必须只能有一个参数的规则可能就太过严厉了。 虽然代码检测工具能够很好地定义并且强制实行一种编码风格，但我们在定义规则集合时应该谨慎一点。如果检测过程太过严格，开发者可能会因为生产力受到影响而感到挫败。如果检测过程太过松散，可能在我们的代码库中就难以形成统一的编码风格。 为了能够把握好这个度，我们可以尽量避免那些即使用了在大多数情况下也不能改善程序的风格规则。每当我们想要新增一条规则时，我们应当扪心自问，加了它之后能否显著地改善现有代码库以及未来的新代码。 ESLint是一个现代代码检测工具，它集合了一些插件、有不同的规则，允许我们选择想要实行的规则。我们可以决定如果不遵守这些规则，是否在输出内容中输出一个警告，或者一个禁止错误。就像在之前的章节中安装babel那样，通过npm就可以安装eslint： 1npm install eslint@3 --save-dev 接下来，我们需要对ESLint进行配置。既然我们安装了eslint，并将其加入了本地依赖，那么我们能够在node_modules/.bin中找到它的命令行工具。在项目中首次进行ESLint配置时，执行以下命令能够指导我们进行配置。一开始，指明使用一个流行的规则指南，并且选择标准规则指南[注释 12]，最后选择JSON格式的配置文件： 12345./node_modules/.bin/eslint --init? How would you like to configure ESLint?Use a popular style guide? Which style guide do you want to follow? Standard? What format do you want your config file to be in? JSON 除了独立的规则，eslint允许我们使用打包成Node.js模块的预定义规则集。这样在多项目甚至社区中共享配置就会很方便。选择标准规则指南后，我们能够看到ESLint向package.json中添加了一些依赖，即定义了预设标准规则集的包；然后创建了一个名为.eslintrc.json文件，包含以下内容： 1234567&#123; \"extends\": \"standard\", \"plugins\": [ \"standard\", \"promise\" ] &#125; 关于npm引用node_modules/.bin目录下的命令及如何工作的实现细节，不在本文的讨论范围之内。虽然我们在初始化ESLint配置时使用了这一引用命令，但没必要一直使用这一引用命令，同样也没必要在每次检测代码库时都重新输入。可以将下面代码片段中的lint脚本加入到packge.json中，从而避免重复输入引用命令： 12345&#123; \"scripts\": &#123; \"lint\": \"eslint .\" &#125;&#125; 在之前的Babel有提到，npm run命令在执行script脚本时会将node_modules加入PATH环境变量。所以想要检查我们的代码库，可以执行npm run lint，然后npm会在node_modules目录中找到嵌入在其中的ESLint CLI。 思考一下下面的example.js文件，其内有着人为的代码风格问题，从而用来演示ESLint具体做了什么： 123456var goodbye='Goodbye!' function hello()&#123; return goodbye&#125; if(false)&#123;&#125; 如下图1-2所示，当我们执行lint脚本命令时，ESLint会标识文件中所有错误的地方。 如果在执行命令时传递--fix参数，ESLint能够自动修复大多数的风格问题。在package.json中加入以下脚本： 12345&#123; \"scripts\": &#123; \"lint-fix\": \"eslint . --fix\" &#125;&#125; 如果我们执行lint-fix，将只会得到两个错误：hello未使用和false是个不变的条件。其他的错误都已经被修复了，结果如下面的代码所示。这些仍然存在的错误之所以没有被修复，主要是因为避免对代码进行假设，并且不倾向于引起语义变化。鉴于ESLint所做的这些工作，--fix是一个很有用的工具，它能够解决代码风格问题，而不会存在导致程序破坏的风险。 1234567var goodbye = 'Goodbye!'function hello() &#123; return goodbye&#125;if (false) &#123;&#125; 还有一种类似的工具——prettier，它也可以用来自动格式化代码。Prettier可以配置自动重写我们代码，从而确保代码遵照我们设定的首选项，如使用给定的空格缩进、单引号或者双引号、尾逗号或者最大行长度。 现在我们已经知道了如何将现代Javascript代码编译成每一个浏览器都能理解的代码，以及如何正确检查和格式化我们的代码，接下来我们来学习ES6的特性主题和JavaScript的未来。 1.4 ES6特性主题ES6非常庞大：ES6语言规范的页数是ES5.1规范的两倍多，ES5.1是258页，而ES6高达566页。规范中的各个更新可以归纳为以下几个不同的类别： 语法糖 新的机制 更好的语义 更多的内置对象和方法 不打破现有限制的解决方案 语法糖是ES6中最重要的驱动因素之一。新版本中提供了很多简洁的方式，如使用新的Class语法来表达对象的集成；使用箭头函数作为函数的缩写语法；对于属性可以使用属性值缩写。还有其他一些特性我们将要讨论，如解构赋值、rest参数以及扩展运算符，也提供了一种更加语义化的编程方式。第二章和第三章会介绍ES6中的这部分内容。 ES6提供了一些新的机制用来描述异步代码流程，如Promise，代表一个操作的最终结果；Iterator代表一序列的值；Generator一种特殊的迭代器，能够生成一系列的值。在ES2017中，async/await则是构建在这些新概念和结构之上的，让我们可以像编写同步代码一样编写异步代码。我们会在第四章介绍这里提到的所有迭代器以及流控制机制。 在JavaScript中有一种常见的做法，即开发者使用普通的对象创建一个带有任意字符串键值的散列映射。如果我们不够小心，并且允许用户输入最终定义这些键值，那么就可能导致产生漏洞。ES6引入了一些新的原生内置对象来管理集合和映射，并且没有只能使用字符串键值的限制。这一系列的内容将在第九章介绍。 代理对象(Proxy)重新定义了可以通过Javascript Reflect对象完成的操作。代理对象和其他语境中所提到的代理类似，比如网络流量路由中所说的代理。它可以拦截JavaScript对象的任何交互，比如属性的定义、删除以及访问。鉴于代理的工作机制，很难全面地对其实现补丁：当然补丁是有的，只是在某些用例下会与规范不符。我们将在第六章讲解代理。 除了一些新的内置对象，ES6还对Number、Math、Array以及String对象进行了一定的扩展。在第七章，我们将介绍一系列添加在这些内置对象上的新实例方法和静态方法。 JavaScript将原生支持一个新的模块系统。第八章中，在讲解完Node.js中使用的CommonJS模块格式之后，我们将详细讲解予以厚望的原生JavaScript模块语义。 由于ES6引入了相当多的修改，所以很难将其新特性与现有的JavaScript知识相结合。我们将通过第九章整章来分析每个不同的特性的优点和重要性，这样你对于ES6就能有一定的实践经验，基于此你可以立刻开始使用ES6。 1.5 JavaScript的未来JavaScript语言已经从1995年一门没啥名气的语言发展成为了今天这样一门强大的语言。虽然ES6已经有了很大的进步，但是这远远不是终点。鉴于每年都会有新的规范发布，那么如何保持对最新规范的了解是很重要的。 在1.2小节中，我们学习了滚动标准规范的开发过程。时刻跟进标准的最好方式之一就是定期访问TC39提案库[注释 13]。时刻关注一下候选推荐提案(即第三阶段提案)，因为这些提案最有可能加入到规范中。 鉴于标准化过程的滚动特性，在一本书中描述一门不断变化的语言是富有挑战的。想要时刻跟进最新的JavaScript更新，最有效的方式是关注TC39提案库，订阅电子邮件新闻周刊[注释 14]，并阅读JavaScript博客[注释 15]。 在撰写本书时，期待已久的Async函数已经加入规范，并在ES2017中发布。当时，有很多候选提案，比如动态import()，支持动态加载原生JavaScript模块；以及使用新的rest和扩展运算符语法描述对象属性枚举，它们在ES6中首次引入，用于参数列表和数组之中。 虽然本书的主要关注点是ES6，但我们也同样会学习重要的候选推荐，比如：之前提及的Async函数，动态import()调用，对象rest/扩展以及其他内容。 [注释 1] 1998年的这本手册详细讲解了关于服务端JavaScript以及LiveWire的复杂之处。 [注释 2] 在微软的网站上可以找到最初的公告(2000年6月)。 [注释 3] 收听Brendan Ecih的播客，能够找到关于JavaScript起源的内容。 [注释 4] The Mac Observer有该新闻的报道(2003年7月)。 [注释 5] 2008年，Brendan Eich给es讨论邮件组发送了一封邮件，在其中概括了会议情况，此时ES3已经发布了近十年。 [注释 6] 对于在将Web ECMAScript规范合并到主干时所做的全部更改，请参阅WHATWG博客。 [注释 7] 可以查看2013年的这一公告——公告 - ES6 规范流程，公告指出了优化后的提案修订流程。 [注释 8] 点击查看被TC39采纳的所有提案 [注释 9] 点击查看ES6的浏览器兼容性详情列表 [注释 10] 点击查看TC39的提案流程文档说明 [注释 11] 点击查看稻草人提案 [注释 12] 注意，Standard是指一种自我宣告，并未由任何官方组织进行实际的标准化。其实，只要能够保持统一，使用哪种风格并不重要。在阅读项目代码库时，一致性有助于减少困扰。Airbnb风格指南也是很受欢迎，和Standard不同，它默认不可省略分号。 [注释 13] 点击查看TC39收录的所有提案 [注释 14] 有很多类似于Pony Foo周刊和Javascriot周刊的新闻刊物。 [注释 15] Pony Foo上有很多关于ECMAScript开发的文章，Axel Rauschmayer也写了很多关于这方面的文章。","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://verymuch.com/tags/翻译/"}]},{"title":"跟扎克伯格学习提高工作效率","slug":"跟扎克伯格学习提高工作效率","date":"2017-02-11T03:44:27.000Z","updated":"2017-12-14T06:31:06.000Z","comments":true,"path":"2017/02/11/跟扎克伯格学习提高工作效率/","link":"","permalink":"http://verymuch.com/2017/02/11/跟扎克伯格学习提高工作效率/","excerpt":"前言 几天前看到了这样一篇文章《鸡年上班的第一天，扎克伯格的26张PPT帮助你提高工作效率，把握“鸡”会》。然后不知道扎克伯格的童靴，我相信做技术的应该都知道的。","text":"前言 几天前看到了这样一篇文章《鸡年上班的第一天，扎克伯格的26张PPT帮助你提高工作效率，把握“鸡”会》。然后不知道扎克伯格的童靴，我相信做技术的应该都知道的。 文章开篇就对扎克伯格进行了介绍——全球最年轻亿万富豪宝座的Facebook创始人马克·扎克伯格。当然这样的标题能够够吸引人查看，因为我们相信优秀的人都是值得学习。不过对于我，我觉得只要是优秀的习惯不管是在谁的身上都是值得学习的。 只看了几页简单的文字PPT，我就不得不佩服，成功人士的经验确实是非常值得学习的。他们或多或少都有一些自己的“成功秘诀”，有一些习惯也许会适合于迷茫中的你和我。 文中给出了26张PPT，之前也没有太认真研究，今天就一边看，一边附上自己的想法，激励自己。 1. 时间常有，时间在于优先。 每天的时间都是固定的，所以我们要把时间用来做有意义的事情。每个人对于有意义的事都有一个定义，但是不管如何在每个人的心里，想要做的事情都会有一个先后顺序或者说重要程度。所以不管是每天的任务还是长期的计划，充分利用自己的时间，并且不能避重就轻，要先完成重要的事情。 马克的第一页PPT中也给出了对比，可能你想做的事情时享受生活，但是你要有享受生活的能力。所以你需要去实现自我，去努力工作，而工作和娱乐相比，则工作是你更应该去做的并且有意义的事情，虽然娱乐来的更舒服，要知道舒适使人丧失斗志，要打破自己的舒适区，挑战自己，成就更好的自己。 2. 每天都会很充实：只需要计划4-5小时用来工作就好 每天都会过的很足，用这句话来说，是想说，不管你一天干什么，你都会过足24小时，只是不同的人的不同的24小时带来的感觉并不相同而已。 当然，这么说并是让大家自己想怎么过就怎么过。而是想说，一天的时间很短，有很多有意的事情需要我们去做，不要把时间都花在工作上。每天真正花在工作上的时间有4-5小时就很好了。 一方面，花费远超于这些的时间在工作上，可能效率并不好，而且会使人疲惫；另一方面，把太多的时间花在工作上，将没有时间让你来做其他有意义的事情，而其他事情也会帮助你更好地工作，如锻炼来的一个健康的身体，学习来的更好的个人能力等等。 所以要合理安排工作时间，把握好自己的时间，过足自己的每一天。 3. 跟着状态走 状态这个东西特别。有的时候你会一点都不在状态，有的时候又非常在状态，就跟打了鸡血似的，天天能忙活12个小时。所以在状态的时候，就可以多干点活；不然的话就好好休息，这样才能更快的调整好自己的状态。 4. 重视自己的时间，并使其值得重视 “你的时间值1000美元/小时，你得行动起来！” 是的，你的时间是有价值的，要认清自己时间的价值，不要去荒废自己的时间，重视起自己的时间。 我要对自己说：“你的时间也要小一百一小时呢，你要重视起来，你每浪费一个小时就浪费100大洋，重视起来吧，好好利用自己的时间，还能够提升自己，加油!” 5. 一次专注一个任务 不要一次进行多个任务，这只会消耗我们的注意力。保持专注，一心易用，这样才能够提高效率。 当自己想要转移注意力的时候一定要严厉地提醒自己。 6. 养成并适应习惯 养成良好的工作习惯，并持之以恒，你的身体会适应的。 是的，不管是生活上的习惯还是工作上的习惯或者说是学习上的习惯，只要是坚持成为习惯了，一切做起来都不再会那么困难。就想之前每天陪媳妇早睡早起觉得很难，但是慢慢调整之后就适应了，也能体会到规律作息的好处。每天早上能够多出两个小时的个人时间，可以用来学习、整理与安排等。 所以养成一个良好的工作习惯，坚持下去，你会越来越好的。 7. 当限定时间做某件事情时，我们往往更加专注并且有效率 我想大家都切身经历过，当一件事情没有最后时限时，我们可能一拖再拖，一直没有紧迫感，而不去完成它。而当这件事情有着最后期限时，我们往往会更加优先、更加专注、更加有效率地完成它。 所以日常生活里，自己安排的事情可能并没有给自己设定期限，那么试一试给自己要做的事情设置个时间限制，去看看自己是不是能够更好更快的完成。 8. 进入工作状态的最佳方式就是工作 进入工作状态最好的方式就是工作，可以先从简单的工作任务开始，由此进入工作状态，然后再按照重要程度、优先级，来完成自己的工作安排。 9. 做完事情，要胜于完美收工 迭代工作，期待完美收工会令人窒息：“做完事情，要胜于完美收工” Facebook 办公室墙壁上贴的箴言。动手做，胜过任何完美的想象。 大多数都有着这样一个缺点，觉得有些事情需要自己去做，但更多的是只是口头说说，纸上写写却并没有真正去做。这就是人的惰性。想到要做的事情，就立马执行起来，如果优先级不够，就先记录下来，然后在需要做的时间去做。不要嘴上说说，让自己动起来。 10. 凡事有个度 凡事要有个度，工作时间越长并不意味着效率越高。要把握好这个度，劳逸结合，才能让自己的续航能力更强。so 该工作的时候好好工作，该休息的时候也要好好休息，该锻炼的时候更要好好锻炼。 11. 分类工作（执行类和思考类），提高效率 工作的时候，将工作清除的分为两类：执行类和思考类。这样在思考的时候能够更好地思考，在执行的时候能够更快的执行，从而提高自己的工作效率。因为思考和执行的过程如果被打断，需要付出更多的时间。 12. 有会议今早安排 有会议就尽早安排，用于准备会议的时间往往都浪费掉了。这个我还没有经验，不过想想是很有道理的。每次周会的下午往往都是浪费了的。 13. 创造不间断工作时间 把会议和沟通 (邮件或电话) 结合，创造不间断工作时间：一个小会，也会毁了一个下午，因为它会把下午撕成两个较小的时间段，以至于啥也干不成。PS：当看到一个程序员冥思苦想时，不要过去打扰，甚至一句问候都是多余的。 对自己说：不要自己碎片化自己的时间，集中注意力。 14. 一天保持相同的工作环境 一整天保持相同的工作环境。在项目/客户之间切换，会效率低。 还没有跟客户对接过的我好像并不懂。 15. 工作—放松—工作=高效(番茄工作法) 番茄工作法是弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。 使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。 对自己说：“利用已有的方法论，提高自己的效率”！ 16. 分割任务 把不切实际的任务分割成合理的小任务，只要每天都完成小任务，你就会越来越接近那个大目标了。 和年度目标细化成执行清单一样，朝着目标一步一步，一点一点地去完成目标的一部分，你会发现完成一个大目标是那么容易。 不要觉得一件事情很难就不去做了，知难行易，也许只是你觉得它很难，但是真正做起来就回变得简单。 17. 确认优先级 从来没有两个任务会有相同的优先级，总会有个更重要，仔细考虑待办事情列表。 每次专注于一个任务，而且要挑选重要的任务来做，不要避重就轻。 18. 一定要完成那件影响最大的事情 必须清楚白天必须完成的那件事，是什么。请确认好事情的优先级，一定要完成影响最大的那件事情。 19. 拆分任务 把任务按时间分段，就能感觉它快被搞定了。 长得任务总是让人感觉很难完成，但是分成一个个的小阶段去完成，你会发现事情变的简单很多。 20. 擅用他人的力量 授权并擅用他人的力量。—君子善假于物(人)也，如果某件事其他人也可以做到八成，那就给他做！ 虽然我还没到这一步，但是要提前有这种意识。 21. 好汉不提当年勇 把昨天翻过去，只考虑今天和明天。昨天的全垒打赢不了今天的比赛。—好汉不提当年勇。 22. 给事情设限 给所有事情都设定一个期限。不要让工作无期限地进行下去。 23. 针对时间紧或有压力的任务，设置结束时间 针对时间紧或有压力的任务，设置结束时间，万事皆可终结 24. 好记性胜过烂笔头 多记，多做笔记。 好记性胜于烂笔头，记笔记能够加深对知识的印象。 25. 记下让你分散注意力的点子 进入高效状态后，记下任何分散你注意力的东西比如Google搜索词、灵光乍现的想法、新点子等等。如果你把它们记下来，它就不会再蹦来蹦去了。 26. 劳逸结合","categories":[{"name":"GROWING_SPACE","slug":"GROWING-SPACE","permalink":"http://verymuch.com/categories/GROWING-SPACE/"}],"tags":[{"name":"有感","slug":"有感","permalink":"http://verymuch.com/tags/有感/"},{"name":"工作效率","slug":"工作效率","permalink":"http://verymuch.com/tags/工作效率/"},{"name":"他人经验总结","slug":"他人经验总结","permalink":"http://verymuch.com/tags/他人经验总结/"}]},{"title":"实现墨刀首页两个弹跳的圆的效果","slug":"实现墨刀首页两个弹跳的圆的效果","date":"2017-02-09T06:59:53.000Z","updated":"2017-02-09T09:20:26.000Z","comments":true,"path":"2017/02/09/实现墨刀首页两个弹跳的圆的效果/","link":"","permalink":"http://verymuch.com/2017/02/09/实现墨刀首页两个弹跳的圆的效果/","excerpt":"练习目标实现墨刀首页两个弹跳的圆的效果","text":"练习目标实现墨刀首页两个弹跳的圆的效果 练习效果 .circle-wrapper { position: relative; width: 560px; height: 560px; border: 1px solid lightblue; } .circle { position: absolute; left: 50%; top: 50%; transform: translate3d(-50%, -50%, 0); /*transform: translate(-50%, -50%);*/ border-radius: 50%; } .circle-1 { width: 65%; height: 65%; border: 80px solid rgba(255, 0, 0, .1); animation: 4s ease-in-out bounce-1; } .circle-2 { width: 80%; height: 80%; border: 1px solid rgba(255, 0, 0, .3); animation: 4s ease-in-out bounce-2; } @keyframes bounce-1 { 0% { width: 5%; height: 5%; border-width: 15px; } 15% { width: 20%; height: 20%; border-width: 20px; } 30% { width: 5%; height: 5%; border-width: 15px; } 40% { width: 20%; height: 20%; border-width: 20px; } 50% { width: 5%; height: 5%; border-width: 15px; } } @keyframes bounce-2 { 0% { width: 25%; height: 25%; } 15% { width: 35%; height: 35%; } 30% { width: 25%; height: 25%; } 40% { width: 35%; height: 35%; } 50% { width: 25%; height: 25%; } } HTML1234&lt;div class=\"circle-wrapper\"&gt; &lt;div class=\"circle circle-1\"&gt;&lt;/div&gt; &lt;div class=\"circle circle-2\"&gt;&lt;/div&gt;&lt;/div&gt; CSS结构样式 1234567891011121314151617181920212223242526.circle-wrapper &#123; position: relative; width: 560px; height: 560px; border: 1px solid lightblue;&#125;.circle &#123; position: absolute; left: 50%; top: 50%; transform: translate3d(-50%, -50%, 0); /*transform: translate(-50%, -50%);*/ border-radius: 50%;&#125;.circle-1 &#123; width: 65%; height: 65%; border: 80px solid rgba(255, 0, 0, .1); animation: 4s ease-in-out bounce-1;&#125;.circle-2 &#123; width: 80%; height: 80%; border: 1px solid rgba(255, 0, 0, .3); animation: 4s ease-in-out bounce-2;&#125; 动画设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@keyframes bounce-1 &#123; 0% &#123; width: 5%; height: 5%; border-width: 15px; &#125; 15% &#123; width: 20%; height: 20%; border-width: 20px; &#125; 30% &#123; width: 5%; height: 5%; border-width: 15px; &#125; 40% &#123; width: 20%; height: 20%; border-width: 20px; &#125; 50% &#123; width: 5%; height: 5%; border-width: 15px; &#125;&#125;@keyframes bounce-2 &#123; 0% &#123; width: 25%; height: 25%; &#125; 15% &#123; width: 35%; height: 35%; &#125; 30% &#123; width: 25%; height: 25%; &#125; 40% &#123; width: 35%; height: 35%; &#125; 50% &#123; width: 25%; height: 25%; &#125;&#125;","categories":[{"name":"EXERCISE_SPACE","slug":"EXERCISE-SPACE","permalink":"http://verymuch.com/categories/EXERCISE-SPACE/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-01-07T00:40:48.000Z","updated":"2017-01-10T11:04:50.000Z","comments":true,"path":"2017/01/07/hello-world/","link":"","permalink":"http://verymuch.com/2017/01/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}