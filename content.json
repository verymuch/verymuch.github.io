{"meta":{"title":"歪马行空","subtitle":"做一只默默奋斗的程序猿~！","description":null,"author":"verymuch","url":"http://verymuch.com"},"pages":[{"title":"About","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"about/index.html","permalink":"http://verymuch.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-10T02:46:30.313Z","updated":"2018-02-10T02:46:30.000Z","comments":true,"path":"css/custom-toc.css","permalink":"http://verymuch.com/css/custom-toc.css","excerpt":"","text":".article { position: relative; } .custom-toc-container { position: absolute; top: 5px; right: 5px; width: 36px; height: 36px; border-radius: 50%; background: #f6f8f9; z-index: 2; cursor: pointer; border: 15px solid white; } .custom-toc-container:hover { background: #edf4ef; } /* .custom-toc-container:before { position: absolute; display: block; width: 10px; height: 10px; background: white; content: \"\"; top: 20px; left: -12px; z-index: 3; transform: translate(0, -50%) rotate(45deg); box-shadow: 0.5px -0.5px 1px 0 rgba(0, 0, 0, 0.12), 0.5px -0.5px 1.5px 0 rgba(0, 0, 0, 0.04); } */ .custom-toc-container img { width: 18px; height: 18px; line-height: 36px; display: block; margin: 10px auto; } .custom-toc-container:hover .custom-toc { display: block; } .custom-toc { display: none; position: absolute; max-height: 400px; overflow-y: scroll; top: 0; right: 40px; background: white; padding: 15px 20px 15px 15px; border-radius: 3px; line-height: 2; box-shadow: 0px 2px 2px 0px rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); border: 1px solid #eee; } .custom-toc li { cursor: pointer; min-width: 160px; max-width: 600px; white-space: nowrap; } .custom-toc .custom-toc--h3 { padding: 0 0 0 20px; } .custom-toc li a { transition: all 0.3s ease; color: #333; } .custom-toc li:hover a { color: #38b7ea; } .custom-toc--h2 { font-size: 13px; } .custom-toc--h3 { font-size: 12px; }"},{"title":"","date":"2018-10-09T08:37:07.740Z","updated":"2018-10-09T08:37:07.740Z","comments":true,"path":"css/custom.css","permalink":"http://verymuch.com/css/custom.css","excerpt":"","text":"@import './custom-toc.css'; #container { font-size: 16px; } .text-highlight { color: red; } .text-hint { color: #999; } button { padding: 5px 10px; background: #38b7ea; color: #fff; border: none; border-radius: 2px; cursor: pointer; } /* 示例区域 */ .demo-area { border: 1px solid #f8f8f8; padding: 10px; } .demo-area textarea { display: block; margin-top: 5px; width: 100%; height: 120px; } .demo-area canvas { width: 200px; height: 100px; } /* 重置样式 */ .article-entry td { /* padding: 0; */ } .article-entry--center th, .article-entry--center td { text-align: center; }"},{"title":"Categories","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://verymuch.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-10T02:50:50.189Z","updated":"2018-02-10T02:50:50.000Z","comments":true,"path":"js/generate-toc.js","permalink":"http://verymuch.com/js/generate-toc.js","excerpt":"","text":"$(window).ready(() => { // 生成目录容器 const $article = $(\".article\"); const $tocContainer = $(\"\").addClass(\"custom-toc-container\"); const $img = $(\"\").attr({ src: \"https://p0.ssl.qhimg.com/t01b4b55a270cdc08a6.png\" }); $img.appendTo($tocContainer); $tocContainer.appendTo($article); // 根据文章内容，为二级标题生成目录 const headers = $(\"h2,h3\", $article); const headersArr = [...headers]; const $toc = $(\"\").addClass(\"custom-toc\"); headersArr.forEach(header => { const headerText = $(header).text(); const hash = $(\"span\", header).attr(\"id\"); const className = header.tagName === \"H2\" ? \"custom-toc--h2\" : \"custom-toc--h3\"; const $newLink = $(\"\") .attr(\"href\", `#${hash}`) .html($(header).text()); const $newLi = $(\"\").addClass(className); $newLink.appendTo($newLi); $newLi.appendTo($toc); }); $toc.appendTo($tocContainer); });"},{"title":"Tags","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"tags/index.html","permalink":"http://verymuch.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CSS自定义属性及其用法","slug":"CSS自定义属性及其用法","date":"2019-04-15T08:32:06.000Z","updated":"2019-04-15T09:54:37.894Z","comments":true,"path":"2019/04/15/CSS自定义属性及其用法/","link":"","permalink":"http://verymuch.com/2019/04/15/CSS自定义属性及其用法/","excerpt":"大家可能不一定都用过CSS自定义属性（ CSS Custom Properties ），但是一定都用过预处理器中的变量。这也是CSS自定义属性有时候被称作CSS变量的原因。 但由于预处理器中变量的使用位置可以不局限在属性值，但是自定义属性只能作为属性值使用，所以其准确名称是CSS自定义属性，而不是CSS变量。 下面我们先从预处理器说起。","text":"大家可能不一定都用过CSS自定义属性（ CSS Custom Properties ），但是一定都用过预处理器中的变量。这也是CSS自定义属性有时候被称作CSS变量的原因。 但由于预处理器中变量的使用位置可以不局限在属性值，但是自定义属性只能作为属性值使用，所以其准确名称是CSS自定义属性，而不是CSS变量。 下面我们先从预处理器说起。 一、预处理器中的变量如果大家用过预处理器的话，一定会有这样的感触。设计师给的某个颜色值，只需要给其定义一个语义化的变量名，就可以在页面的任何（适当的）地方使用了，而不用记住或者复制粘贴这一色值。这样做的好处也是很明显，那就是当这一色值在多处使用需要修改时，直接修改变量的值即可。这就是预处理器中的变量的优势所在：减少复制粘贴，易于修改。 不过撇开优点不谈，预处理器的变量也有一些缺点和限制，如下： 不能动态修改变量：预处理器是在编译时进行变量的处理，编译后变量其实就不存在了。 没有DOM结构，无法级联继承。 不能用JavaScript进行读写。 看到这里大家都一定会想，既然预处理器变量有这些缺点，那是不是CSS的自定义属性就能做到这些呢？想知道的话，和我一起往下进行吧。 二、如何定义自定义属性2.1 自定义属性名CSS自定义属性的语法格式为--*，双横线加上具体的自定义属性名，属性名是一个合法的CSS标识符即可。 自定义属性没有具体的CSS含义，其用途完全由作者和使用者决定。自定义属性可以应用于任何元素，其可以被继承，并且支持级联，不支持动画。 注意：与CSS属性不同，自定义属性是大小写敏感的。 CSS不会被all属性重置，将来可能会定义一个重置所有变量的属性。 2.2 自定义属性值自定义属性值的要求可以说是非常地宽松，可以是任何有效的CSS值，如颜色、字符、布局的值、甚至是表达式。 既然自定义属性值的要求如此宽松，那我们只需要知道有哪些情况不允许即可。 只要自定义属性值不存在以下几种情况即为合法：无效字符值、无效url值、未配对的)/]/}、不能在最外层出现;、不能出现!。 有个例外，自定义属性后面可以跟!important，但是这个!important其实并没有卵用，因为在进行属性值检测前就会将其移除。 下面我们来看个自定义属性的例子，大家觉得下面这个是一个合法的自定义属性吗？ 1--foo: if(x &gt; 5) this.width = 10; 答案是这是一个合法的自定义属性，但显然它并没有任何用处，因为将其用于其他任何常规属性是都是无效的。 2.3 如何使用变量通过var()函数，自定义属性的值可以用作另一个属性的值。var()的语法格式如下： 1var() = var( &lt;custom-property-name&gt; [, &lt;declaration-value&gt; ]? ) 其中第一个参数为自定义属性名，第二个参数为后备值。当传入的自定义属性无效或者不存在时，会使用后备值。 var()可以用在属性值中的任何部分，但是不能用在属性名、选择器以及其他除属性值以外的地方。 注意，后备值允许逗号，如var(--foo, red, blud)会定义一个red, blue的后备值，也就是说第一个逗号之后的都会被当做默认值。 好了，我们已经知道了var()的基础用法，那么var()是如何替换成具体值的呢？ 如果自定义属性的值为初始值以外的任何值，则直接将var()替换为对应的值。 否则，如果var()函数有后备值，则替换成后备值，如果后备值中也有var()则同样进行替换。 否则在计算值过程中，var()就是无效的。 2.4 注意事项1. 自定义属性与动画上面有提到自定义属性不能用于动画。其实自定义属性可以出现在@keyframs中，但其行为较为特殊，会导致动画瑕疵，因为其只会在指定帧影响使用了自定义属性的可动画属性。如下所示： 1234567891011121314151617181920&lt;style&gt; :root &#123; --custom-color: #0f0; --custom-width: 200px; &#125; .box &#123; color: var(--custom-color); width: var(--custom-width); border: 1px solid grey; animation: linear 3s scale-width; &#125; @keyframes scale-width &#123; 50% &#123; --custom-width: 400px; &#125; &#125;&lt;/style&gt;&lt;div class=\"box\"&gt;Lorem ipsum dolor sit amet consectetur, adipisicing elit. Animi rerum labore numquam quo magni, modi quas dolores maiores alias! Consequatur optio error fugit velit, et veritatis quidem unde fuga nostrum?&lt;/div&gt; 可以看出，类.box元素div的宽度只发生了两次改变，这说明自定义属性无法进行动画，但是会在固定帧时生效，从而影响相关的属性。 2. 自定义属性大小写敏感如下例所示，两个div内的字体颜色不一样，可以看出CSS自定义属性大小写敏感性。 123456789101112131415&lt;style&gt; :root &#123; --custom-color: red; --CUSTOM-COLOR: green; &#125; .box--1 &#123; color: var(--custom-color); &#125; .box--2 &#123; color: var(--CUSTOM-COLOR); &#125;&lt;/style&gt;&lt;div class=\"box--1\"&gt;Lorem ipsum dolor sit amet consectetur, adipisicing elit. Animi rerum labore numquam quo magni, modi quas dolores maiores alias! Consequatur optio error fugit velit, et veritatis quidem unde fuga nostrum?&lt;/div&gt;&lt;div class=\"box--2\"&gt;Lorem ipsum dolor sit amet consectetur, adipisicing elit. Animi rerum labore numquam quo magni, modi quas dolores maiores alias! Consequatur optio error fugit velit, et veritatis quidem unde fuga nostrum?&lt;/div&gt; 3. 自定义属性不能作为一个独立属性值的一部分自定义属性不能作为一个独立属性值的一部分， 如下所示： 1234.foo &#123; --gap: 20; margin-top: var(--gap)px;&#125; 最终的并不是想象中的margin-top: 20px，而是margin-top: 20 px，而这是一个无效的值。这时我们可以用calc()函数来实现，如下： 1234.foo &#123; --gap: 20; margin-top: calc(var(--gap) * 1px);&#125; 4. 循环依赖既然能通过var()使用变量，不知道大家是不是和我一样会有这样的疑问，如果使用变量的时候产生了闭环咋办呢？ 其实大家可以放心，CSS规范在定义自定义属性的时候已经考虑到了这一点。规范中将其称为依赖循环，如果自定义属性引用自己，或者两个以上的属性互相引用则会导致依赖循环。如下所示 12345678:root &#123; /* 自定义属性引用自己 */ --self: calc(var(--self) + 10px); /* 两个自定义属性互相引用 */ --one: calc(var(--two) + 20px); --two: calc(var(--one) - 20px);&#125; 其实对于依赖循环的处理也没有想象中的复杂，如果在计算属性的时候，发现了依赖依赖循环，则依赖循环中的所有自定义属性值都使用初始值代替。 需要注意的是，自定义属性是在计算值时解析其中的var()函数的，这一步是在值继承之前。所以只有同一元素上的多个自定义属性相互引用时才会导致依赖循环；元素树中父级元素上的自定义属性不会导致子孙元素自定义属性的循环依赖。 如下所示，two中的—-bar在被three继承前值已经为calc(10px + 10px)，所以最终three中--foo的值为30px，并不会导致循环依赖。 12345&lt;one&gt;&lt;two&gt;&lt;three /&gt;&lt;/two&gt;&lt;/one&gt;one &#123; --foo: 10px; &#125;two &#123; --bar: calc(var(--foo) + 10px); &#125;three &#123; --foo: calc(var(--bar) + 10px); &#125; 三、自定义属性的优势前面提到了预处理器中，自定义属性有三个局限或缺点。那么CSS引入的自定义属性是否具备了相应的特性呢。是的，CSS自定义属性是具备的。 可以动态修改自定义属性 有DOM结构的概念，可以级联继承。 可以用JavaScript进行读写。 3.1 动态修改自定义属性我们先看下下例中SCSS代码和CSS自定义属性的对比： 1234567891011121314151617181920212223// SCSS$custom-size: 16px;@media (min-width: 1000px) &#123; $custom-size: 28px;&#125;body &#123; font-size: $custom-size;&#125;// CSS自定义属性:root &#123; --custom-size: 16px;&#125;@media (min-width: 1000px) &#123; :root &#123; --custom-size: 28px; &#125;&#125;body &#123; font-size: var(--custom-size)；&#125; 如果你实际试一下的话，你会发现使用SCSS预编译器时，在视口宽度变化时，并不能改变字体大小。而使用自定义属性时，当窗口宽度大于1000px时，字体会相应变大。 3.2 有DOM结构的概念，可以级联继承CSS自定义属性时存在DOM结构的概念，并且可以继承。如下例所示： 123456789101112:root &#123; --custom-color: red;&#125;div &#123; --custom-color: green;&#125;p &#123; color: var(--custom-color)&#125;&lt;div&gt;&lt;p&gt;Lorem ipsum dolor sit amet consectetur, adipisicing elit. Animi rerum labore numquam quo magni, modi quas dolores maiores alias! Consequatur optio error fugit velit, et veritatis quidem unde fuga nostrum?&lt;/p&gt;&lt;/div&gt;&lt;p&gt;Lorem ipsum dolor sit amet consectetur, adipisicing elit. Animi rerum labore numquam quo magni, modi quas dolores maiores alias! Consequatur optio error fugit velit, et veritatis quidem unde fuga nostrum?&lt;/p&gt; 其中第一个div内的p标签内的颜色为绿色，因为自定义属性继承了div中的值，而第二个p标签中文字颜色即为红色，因为它的值来自全局的:root中的自定义属性。 3.2 使用JavaScript进行读写我们可以通过window.getComputedStyle(element)的方法getPropertyValue获取属性值，通过el.style.setProperty来设置属性值。 如下所示，我们可以先获取当前元素的字体大小，然后再对其进行修改： 12345678:root &#123; --custom-font-size: 12px;&#125;p &#123; font-size: var(--custom-font-size);&#125;&lt;p id=\"p1\"&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Culpa, pariatur maiores esse perspiciatis quam itaque modi impedit soluta, reiciendis voluptatem non obcaecati dolorum eveniet ad reprehenderit hic eligendi maxime repudiandae.&lt;/p&gt; 123456789const el = document.getElementById('p1')setTimeout(() =&gt; &#123; const currSize = window.getComputedStyle(el).getPropertyValue('--custom-font-size') // 计算新的大小 const newSize = ( currSize.split('px')[0] * 2) + 'px' el.style.setProperty('--custom-font-size', newSize)&#125;, 3000) 执行如上代码，会发现，三秒后，字体的的大小会增大一倍，这就是通过JavaScript对自定义属性操作的结果。 四、兼容性 如图所示，目前主流的浏览器对于自定义属性都已经有了很好的兼容性。所以如果你的产品只用兼容现代浏览器，而且可以通过类似postcss-css-variables的插件来实现兼容，那么你就完全可以用起来了。或者也可以通过优雅降级的方式分别加载带有CSS自定义属性和不带有CSS自定义属性的代码。 总结本文介绍了CSS自定义属性的用法及其所具备的几个优势，但限于篇幅有限，本文没有介绍CSS自定属性的使用场景。其实CSS自定义属非常适合用来实现主题的切换，感兴趣的可以自己参考一下。 参考链接 https://www.w3.org/TR/2015/CR-css-variables-1-20151203/ https://www.smashingmagazine.com/2017/04/start-using-css-custom-properties/ https://www.smashingmagazine.com/2018/05/css-custom-properties-strategy-guide/ https://www.w3cplus.com/css3/start-using-css-custom-properties.html","categories":[],"tags":[]},{"title":"细数CSS伪元素及其用法","slug":"细数最新的CSS微元素及其用法","date":"2019-03-20T03:29:11.000Z","updated":"2019-03-20T11:09:11.727Z","comments":true,"path":"2019/03/20/细数最新的CSS微元素及其用法/","link":"","permalink":"http://verymuch.com/2019/03/20/细数最新的CSS微元素及其用法/","excerpt":"引言CSS中有两个很常见的概念，伪类和伪元素。 伪类用于在页面中的元素处于某个状态时，为其添加指定的样式。 伪元素会创建一个抽象的伪元素，这个元素不是DOM中的真实元素，但是会存在于最终的渲染树中，我们可以为其添加样式。 最常规的区分伪类和伪元素的方法是：实现伪类的效果可以通过添加类来实现，但是想要实现伪元素的等价效果只能创建实际的DOM节点。 此外，伪类是使用单冒号:，伪元素使用是双冒号::。 伪元素可以分为排版伪元素、突出显示伪元素、树中伪元素三类。下面我们一起看看具体都有哪些吧。 本文主要介绍CSS Pseudo-Elements Module Level 4涉及的伪元素，因为该标准仍处于草案阶段，所以会存在变动的可能。本文旨在带大家了解有哪些现在以及将来可用的伪类。有兴趣的可以持续跟进。","text":"引言CSS中有两个很常见的概念，伪类和伪元素。 伪类用于在页面中的元素处于某个状态时，为其添加指定的样式。 伪元素会创建一个抽象的伪元素，这个元素不是DOM中的真实元素，但是会存在于最终的渲染树中，我们可以为其添加样式。 最常规的区分伪类和伪元素的方法是：实现伪类的效果可以通过添加类来实现，但是想要实现伪元素的等价效果只能创建实际的DOM节点。 此外，伪类是使用单冒号:，伪元素使用是双冒号::。 伪元素可以分为排版伪元素、突出显示伪元素、树中伪元素三类。下面我们一起看看具体都有哪些吧。 本文主要介绍CSS Pseudo-Elements Module Level 4涉及的伪元素，因为该标准仍处于草案阶段，所以会存在变动的可能。本文旨在带大家了解有哪些现在以及将来可用的伪类。有兴趣的可以持续跟进。 第一类：排版伪元素1. ::first-line伪元素这个伪元素大家应该很熟悉，因为早在CSS2.1中就存在了。它表示所属源元素的第一格式化行。可以定义这一行的样式。 如下面的CSS和HTML代码，其对应的效果如图所示。 123p::first-line &#123; text-transform: uppercase;&#125; 1&lt;p&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Necessitatibus quisquam ipsum sunt doloribus accusamus quae atque quaerat quam deleniti beatae, ipsam nobis dignissimos fugiat reiciendis error deserunt. Odio, eligendi placeat.&lt;/p&gt; 第一格式化行被截断的位置与元素的宽度、字体大小等很多因素有关，本文的截图均只为了展示效果而截取的。 虽然在DOM中看不到，但实际上，上面的这段HTML代码会通过添加虚拟标签的方式进行修改。如下： 1&lt;p&gt;&lt;p::first-line&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit.&lt;/p::first-line&gt; Necessitatibus quisquam ipsum sunt doloribus accusamus quae atque quaerat quam deleniti beatae, ipsam nobis dignissimos fugiat reiciendis error deserunt. Odio, eligendi placeat.&lt;/p&gt; 如果::first-line伪元素的应用会截断真实的元素，这个时候会在截断的位置前先闭合标签，在截断位置之后再重新添加开标签。对比如下两段代码： 12345&lt;!-- 无伪元素 --&gt;&lt;p&gt;&lt;span&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Necessitatibus quisquam ipsum sunt doloribus accusamus quae atque quaerat quam deleniti beatae, ipsam nobis dignissimos fugiat reiciendis error deserunt.&lt;/span&gt; Odio, eligendi placeat.&lt;/p&gt;&lt;!-- 有伪元素 --&gt;&lt;p&gt;&lt;p::first-line&gt;&lt;span&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit.&lt;/span&gt;&lt;/p::first-line&gt;&lt;span&gt; Necessitatibus quisquam ipsum sunt doloribus accusamus quae atque quaerat quam deleniti beatae, ipsam nobis dignissimos fugiat reiciendis error deserunt.&lt;/span&gt; Odio, eligendi placeat.&lt;/p&gt; 1.1 如何确定第一格式化行需要注意的是，::first-line伪元素只有应用在块级容器上才有效，且必须出现在相同流中的块级子孙元素中（即没有定位和浮动）。 如下所示，DIV的首行就是P元素的首行 12345678&lt;div&gt; &lt;p&gt;Lorem ipsum&lt;/p&gt; dolor sit amet consectetur adipisicing elit. Omnis asperiores voluptatem sit ipsa ex fugit provident tenetur eum pariatur impedit cumque corrupti iste expedita, esse nulla ad et excepturi. Iste!&lt;/div&gt;&lt;!-- 等价抽象代码 --&gt;&lt;div&gt; &lt;p&gt;&lt;div::first-line&gt;Lorem ipsum&lt;/div::first-line&gt;&lt;/p&gt; dolor sit amet consectetur adipisicing elit. Omnis asperiores voluptatem sit ipsa ex fugit provident tenetur eum pariatur impedit cumque corrupti iste expedita, esse nulla ad et excepturi. Iste!&lt;/div&gt; 如果display值为table-cell和inline-block的元素的内容，不能作为祖先元素的第一格式化行内容。 如下所示，如果将上面HTML代码中p标签改为display: inline-block，则其不会应用首行效果。 如下所示，可以看出Lorem ipsum仍为小写： 12345678910&lt;div&gt; &lt;p style=\"display: inline-block;\"&gt;Lorem ipsum&lt;/p&gt; dolor sit amet consectetur adipisicing elit. Omnis asperiores voluptatem sit ipsa ex fugit provident tenetur eum pariatur impedit cumque corrupti iste expedita, esse nulla ad et excepturi. Iste!&lt;/div&gt;&lt;!-- 等价抽象代码 --&gt;&lt;div&gt; &lt;p style=\"display: inline-block;\"&gt;Lorem ipsum&lt;/p&gt;&lt;div::first-line&gt; dolor sit amet consectetur adipisicing elit. Omnis&lt;/div::first-line&gt; asperiores voluptatem sit ipsa ex fugit provident tenetur eum pariatur impedit cumque corrupti iste expedita, esse nulla ad et excepturi. Iste!&lt;/div&gt; 1.2 可以用于::first-line伪元素的样式::first-line生成的伪元素的行为类似于一个行级元素，还有一些其他限制。主要有以下样式可以应用于其上： 所有的字体属性 color和opacity属性 所有的背景属性 可以应用于行级元素的排版属性 文字装饰属性 可以用于行级元素的行布局属性 其他一些规范中特别指定可以应用的属性 此外，浏览器厂商有可能额外应用其他属性。 2. ::first-letter伪元素::first-letter伪元素代表所属源元素的第一格式化行的第一个排版字符单元，且其前面不能有任何其他内容。 ::first-letter常用于下沉首字母效果。 如下，我们可以创建一个下沉两行的段落。第一种方法，是CSS-INLINE-3中引入的，浏览器尚不支持。我们可以通过第二种方法实现同样的效果。 12&lt;p&gt;“Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dignissimos hic vero reprehenderit sunt temporibus? Doloribus consequatur quo illo porro quae recusandae autem eos. Corrupti itaque alias nam eius animi illum.&lt;/p&gt; 12345678910&lt;!-- initial-letter(尚不支持) --&gt;p::first-letter &#123; initial-letter: 2; &#125;&lt;!-- 普通实现 --&gt;h3 + p::first-letter &#123; float: left; display: inline-block; font-size: 32px; padding: 10px 15px;&#125; 注意，第一个排版字符单元前的标点符号（可以是多个标点符号）也要包含在::first-letter伪元素内。CSS3 TEXT中规定，一个排版字符单元可以包含超过一个的Unicode码点。不同的语言也可以有额外的规则决定如何处理。 如果将要放入::first-letter伪元素的字符不在同一个元素中，如&lt;p&gt;“&lt;em&gt;L中的&quot;L，浏览器可以选择一个元素创建伪元素，也可以两个都创建，或者都不创建。 在chrome下效果如下，还是挺奇怪的。所以尽量避免该情况。 此外，如果块元素的首字母不在行首（如由于双向重新排序），则浏览器不需要创建伪元素。 2.1 如何确定首字母首字母必须出现在第一格式化行内。 如下所示，将b标签改为display: inline-block;，则其不会出现在第一格式化行内，所以首字母无效果。 12&lt;p&gt;“&lt;b style=\"display: inline-block;\"&gt;Lorem&lt;/b&gt;” ipsum dolor sit amet, consectetur adipisicing elit. Dignissimos hic vero reprehenderit sunt temporibus? Doloribus consequatur quo illo porro quae recusandae autem eos. Corrupti itaque alias nam eius animi illum.&lt;/p&gt; 目前，::first-letter只可用于块级元素，未来可能会允许应用到更多的display类型中。 伪元素的虚拟标签应当紧跟在首字母之前，哪怕这个首字母是在子孙元素，这一点和::first-line类似。 如下例，首字母首字母在子孙元素中，首字母的并没有加粗，因为伪元素是添加到span标签内部的，所以字重是正常的。 123p &#123; line-height: 1.1 &#125;p::first-letter &#123; font-size: 2em; font-weight: normal &#125;span &#123; font-weight: bold &#125; 1&lt;p&gt;&lt;span&gt;Lorem ipsum&lt;/span&gt; dolor sit amet consectetur adipisicing elit. Magni possimus rerum eaque architecto, adipisci neque odio, recusandae sapiente placeat ullam velit ratione esse aut expedita quae earum. Velit, dignissimos accusamus?&lt;/p&gt; 如果元素有::before或者::after，则::first-letter伪元素也可以应用到其content值中。 如果元素是列表项（即display: list-item），则首字母会应用在标记符号后面。如下图： 如果列表项的显示位置在内部（即list-style-position: inside），浏览器可以选择忽略::first-letter伪元素。 2.2 可以用于::first-letter伪元素的样式::first-line生成的伪元素的行为类似于一个行级元素，还有一些其他限制。主要有以下样式可以应用于其上： 所有的字体属性 color和opacity属性 所有的背景属性 可以应用于行级元素的排版属性 文字装饰属性 可以用于行级元素的行布局属性 margin和padding属性 border和box-shadow 其他一些规范中特别指定可以应用的属性 同样，浏览器厂商有可能额外应用其他属性。 第二类：突出显示伪元素突出显示伪元素表示文档中特定状态的部分，通常采用不同的样式展示该状态。如页面内容的选中。 突出显示伪元素不需要在元素树中有体现，并且可以任意跨越元素边界而不考虑其嵌套结构。 突出显示伪元素主要有以下几类： ::selection与::inactive-selection 这两个伪元素表示用户在文档中选取的内容。::selection表示有效的选择，相反，::inactive-selection表示无效的选择（如当窗口无效，无法相应选中事件时） 如下图所示，我们可以定义页面中选中内容的样式，输入框中的内容也可以。 请原谅我也无法触发::inactive-selection。大家知道它是干啥的就行了。 ::spelling-error ::spelling-error表示浏览器识别为拼写错误的文本部分。暂无实现。 ::grammar-error ::grammar-error表示浏览器识别为语法错误的文本部分。暂无实现。 ::spelling-error和::grammar-error暂时均无实现。一方面，不同的语言的语法与拼写较为复杂。另一方面，::spelling-error和::grammar-error还可能会导致用户隐私的泄露，如用户名和地址等。所以浏览器实现必须避免读取这类突出显示内容的样式。 可以应用到突出显示类伪元素的样式对于突出显示类伪元素，我们只可以应用不影响布局的属性。如下： color background-color cursor caret-color caret-color text-decoration及其相关属性 text-shadow stroke-color/fill-color/stroke-width 草案中对这里可以应用的属性还有待确认，所以会存在一定的增减。现阶段，也只有color和background得到了支持。 第三类：存在于元素树中的伪元素：树中伪元素这类伪元素会一直存在于元素树中，它们汇集成源元素的任何属性。 1. 内容生成伪元素：::before/::after当::before/::after伪元素的content属性不为&#39;none&#39;时，这两类伪元素就会生成一个元素，作为源元素的子元素，可以和DOM树中的元素一样定义样式。 ::before是在源元素的实际内容前添加伪元素。::after是在源元素的实际内容后添加伪元素。 正如上文提到的，与常规的元素一样，::before和::after两个伪元素可以包含::first-line和::first-letter。 2. 列表项标记伪元素：::marker::markder可以用于定义列表项标记的样式。 如下，我们可以分开定义列表项及其内容的颜色。 12345&lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 123456li&#123; color: red;&#125;li::marker &#123; color:green;&#125; 该伪元素暂时只有safari支持，尝试的话请使用safari。可以用于该伪元素的属性也有限，包括所有字体样式、color以及text-combine-upright，有待以后扩充。 3. 输入框占位伪元素：::placeholder::placeholder表示输入框内占位提示文字。可以定义其样式。 如： 123::placeholder &#123; color: blue;&#125; 所有可以应用到::first-line伪元素的样式都可以用于::placeholder上。可以参考上面的内容。 注意还有一个:placeholder-shown伪类，它主要用于定义显示了占位文字的元元素本身的样式，而不是占位文字的样式。 总结本文列举了CSS Pseudo-Elements Module Level 4中的所有伪元素类型。 首先，详细介绍了排版类伪元素，这一类大家的使用场景较多，支持度也较好。 其次，介绍了突出显示类伪元素，主要可以用于选中样式的修改，其他的尚未得到支持。 最后，介绍了树中伪元素，包括::before/::after/::marker/::placeholder 虽然有些伪元素没有得到支持，或者可以应用的属性优先，但是CSS工作中正在进行一定的扩展。有兴趣的同学们可以持续关注。 CSS Pseudo-Elements Module Level 4：https://www.w3.org/TR/2019/WD-css-pseudo-4-20190225/#window-interface。","categories":[],"tags":[]},{"title":"CSS的“层”峦“叠”翠","slug":"CSS的“层”峦“叠”翠","date":"2019-01-18T09:59:47.000Z","updated":"2019-02-25T03:12:57.910Z","comments":true,"path":"2019/01/18/CSS的“层”峦“叠”翠/","link":"","permalink":"http://verymuch.com/2019/01/18/CSS的“层”峦“叠”翠/","excerpt":"前言提起，z-index大家脑海里可能会立刻浮现这样的知识点：“z-index的值大小控制元素在Z轴上显示的层级，z-index越大显示的层级越高（也就是在最上层，离观察者越近），没有指定的按照出现顺序堆叠，此外z-index不能跨父元素比较。 z-index的使用似乎就是这么简单，对吧？ 我们先看如下例1： 12&lt;div class=\"box box1\"&gt;DIV#1，z-index为2&lt;/div&gt;&lt;div class=\"box box2\"&gt;DIV#2，z-index为auto&lt;/div&gt; HTML中有如下两个元素，DIV#1的z-index为2，DIV#2向右向上偏移。问：它们谁会显示在上面？ 点击 CSS的“层”峦“叠”翠 - 示例1 - 用法导引 进行编辑 (@verymuch) on CodePen. 如上所示，z-index为2的元素并没有显示在第二个元素上面。这似乎很奇怪，那到底是为什么呢？ 如果你也对此存在困扰，那就和我一起往下看吧。笔者将逐步引导大家深入理解z-index的用法。","text":"前言提起，z-index大家脑海里可能会立刻浮现这样的知识点：“z-index的值大小控制元素在Z轴上显示的层级，z-index越大显示的层级越高（也就是在最上层，离观察者越近），没有指定的按照出现顺序堆叠，此外z-index不能跨父元素比较。 z-index的使用似乎就是这么简单，对吧？ 我们先看如下例1： 12&lt;div class=\"box box1\"&gt;DIV#1，z-index为2&lt;/div&gt;&lt;div class=\"box box2\"&gt;DIV#2，z-index为auto&lt;/div&gt; HTML中有如下两个元素，DIV#1的z-index为2，DIV#2向右向上偏移。问：它们谁会显示在上面？ 点击 CSS的“层”峦“叠”翠 - 示例1 - 用法导引 进行编辑 (@verymuch) on CodePen. 如上所示，z-index为2的元素并没有显示在第二个元素上面。这似乎很奇怪，那到底是为什么呢？ 如果你也对此存在困扰，那就和我一起往下看吧。笔者将逐步引导大家深入理解z-index的用法。 一、没有使用z-index时，元素如何堆叠？首先，我们先了解下默认情况下，元素的堆叠，即在没有使用z-index时，元素是如何堆叠的。 如果没有给任何元素指定z-index，则元素按照如下顺序进行堆叠（由下到上，由远及近）。 根元素的背景和边框 非定位的后代块元素，按照在HTML中的出现顺序进行堆叠 定位的后代块元素，按照在HTML中的出现顺序进行堆叠 注：定位的元素即为position的值不是static的元素 点击 CSS的“层”峦“叠”翠 - 示例2 - 无z-index时的默认堆叠 进行编辑 (@verymuch) on CodePen. 如上例2所示，定位的元素（DIV#1、DIV#2、DIV#3与DIV#4）按照出现的顺序堆叠。非定位的元素（DIV#5与DIV#6）虽然出现在后面，但是会被定位的元素遮盖，不过它们本身是按照出现顺序堆叠的。 注意，当使用order属性改变flex元素子元素的出现顺序时，对于堆叠规则也有同样的影响。 如下例3所示，当将DIV#2的order改为-1后，它出现的位置为第一个，其堆叠顺序也被DIV#1所遮盖。 点击 CSS的“层”峦“叠”翠 - 示例3 - flex中order对出现顺序的影响 进行编辑 (@verymuch) on CodePen. 二、浮动块默认如何堆叠如果存在浮动块，浮动块的堆叠顺序会介于无定位元素和定位元素之间。即： 根元素的背景和边框 非定位的后代块元素，按照在HTML中的出现顺序进行堆叠 浮动块 定位的后代块元素，按照在HTML中的出现顺序进行堆叠 我们稍微修改下示例2中的代码，将DIV#1和DIV#3改为浮动元素。可以看到如下例4所示，浮动元素的堆叠顺序高于非定位元素，低于定位元素。 点击 CSS的“层”峦“叠”翠 - 示例4 - 浮动块的堆叠 进行编辑 (@verymuch) on CodePen. 此外，还有一点小改动，不知道你有没有注意到，我们将非定位元素中的文本内容改为了左对齐，但其内容并没有被浮动元素覆盖。这其实是浮动元素的标准效果——环绕效果。这一行为也可以列为堆叠顺序之一。顺序如下： 根元素的背景和边框 非定位的后代块元素，按照在HTML中的出现顺序进行堆叠 浮动块 非定位元素的后代行内元素 定位的后代块元素，按照在HTML中的出现顺序进行堆叠 为了让大家清晰的理解上面所说的非定位元素的后代行内元素。大家可以看下例5。DIV#1为浮动元素，所以其层级高于在其后出现的DIV#2。此时DIV#1向右偏移，可以看见DIV#2中的行内文字元素(可以为纯文字节点)层级高于DIV#1。 点击 CSS的“层”峦“叠”翠 - 示例5 - 非定位元素的后代行内元素 进行编辑 (@verymuch) on CodePen. 三、使用z-index自定义堆叠顺序以上是CSS中对于各类元素的默认排序，那我们能否自定义排序呢？答案显然是肯定的。使用z-index可以自定义堆叠顺序。 z-index的值可以为整数（正数、负数、0均可）。使用方法很简单。 需要注意以下三点： 未指定z-index，默认为auto 如果z-index相同，则按照默认规则比较 z-index只能用于定位了的元素(暂时这么说，下文会追加解释)。这也解释了本文开头的例1为什么不生效了。因为z-index对普通元素没有效果。 如下例6，我们修改了例2中元素的z-index。 我们会发现DIV#5和DIV#6并不受z-index的影响。主要体现在两个方面，首先DIV#5的z-index大于DIV#6，但是显示却低于#DIV#6；其次是DIV#5的z-index小于DIV#4，但是仍显示在其上面。 而对于定位的元素，z-index对其有影响，堆叠顺序与数字大小符合。 点击 CSS的“层”峦“叠”翠 - 示例6 - 使用z-index自定义堆叠顺序 进行编辑 (@verymuch) on CodePen. 好了，相信通过上述内容，大家对于z-index应该有了一定的了解，但是以上仅仅是基本知识，关于堆叠远远没有这么简单。 想要彻底了解z-index，我们还要了解一下CSS堆叠的一个重要概念————堆叠上下文。 四、堆叠上下文堆叠上下文是HTML中的三维概念，它抽象出了一个z轴，z轴垂直于显示器，指向用户（假设用户面朝显示区域）。 在前面的内容中，之所以有些元素的渲染顺序会受到z-index影响，是因为它们都因为某种原因产生了一个堆叠上下文，而不仅仅是上文提到的定位的元素。 那么到底什么情况下会产生堆叠上下文呢？其实堆叠上下文的生成主要受到元素的属性所影响。 如果任何一个元素满足一下条件之一，就会生成一个堆叠上下文。 文档的根元素（HTML）默认为一个堆叠上下文 position值为”absolute”或”relative”，且z-index指定了除了auto以外值的元素 position值为”fixed”或”sticky” 弹性布局的子元素，且z-index指定了除了auto以外值的元素 opacity的值小于的元素 mix-blend-mode的值不是normal的元素 以下属性值不为”none”的元素 transform filter perspective clip-path mask / mask-image / mask-border isolation值为”isolate”的元素 -webkit-overflow-scrolling值为”touch”的元素 will-change指定了除初始值以外的任何属性的元素 contain值为”layout”/“paint”及含义其中之一的组合值的元素 如上所述，有11种情况会生成堆叠上下文，对于堆叠上下文可以通过z-index指定其堆叠的顺序（注意这里不是上面说的只对定位元素生效了）。 对于堆叠上下文我们需要知道以下几点： 在每个堆叠上下文内部，子元素的堆叠规则遵循上面所讲的基本规则。 堆叠上下文可以包含在其他堆叠上下文内部，它们会创建一个堆叠上下文层级结构。 堆叠上下文的层级结构与HTML的元素不同，因为对于没有创建堆叠上下文的元素会被父元素同化。堆叠上下文的层级只包括创建了堆叠上下文的元素。 堆叠上下文独立于其兄弟元素，在处理自身内部堆叠时，只考虑其后代元素。内部堆叠完成后，将当前堆叠上下文当成一个整体，考虑在父堆叠上下文中的堆叠顺序。通俗的说，子堆叠上下文的z-index值只在父堆叠上下文中有意义。 注意，第四条和文章开头提到的“z-index不能跨父元素比较”是不等价的，因为其限制了必须是堆叠上下文。 针对这几点，我们看一下例7。大家可以先看一下是否理解。然后我们再讲解一下。 点击 CSS的“层”峦“叠”翠 - 示例7 - 存在多级堆叠上下文时，元素的堆叠 进行编辑 (@verymuch) on CodePen. 示例7中，堆叠上下文的层级结构如下： root DIV#1 DIV#2 DIV#4 DIV#5 DIV#6 DIV#3 DIV#8 其中DIV#4, DIV#5, DIV#6是DIV#2的子元素，可见其堆叠顺序被限制在DIV#2中，z-index的值只在DIV#2内部有效，然后DIV#2又作为一个整体与DIV#1，DIV#3按照上述规则进行堆叠。 DIV#7被根元素同化，DIV#8与DIV#1, DIV#2, DIV#3按照上述规则进行堆叠。在其三之上。 其实有个小方法能够帮助大家更好地判断如何堆叠，那就是把堆叠上下文的层级结构类比为版本号。如下： root DIV#1 (V3) DIV#2 (V2) DIV#4 (V2.1) DIV#5 (V2.3) DIV#6 (V2.4) DIV#3 (V1) DIV#8 (V4) 如上，类比成版本号之后，我们就能很方便的判断出谁上谁下啦。 五、注意事项1. z-index: 0与z-index: auto并不相同。通常情况下，相邻的两个元素，如果其z-index值分别为0和auto，看上去没什么区别的。如下例8所示。 DIV#1的z-index值为0，其堆叠顺序并没有高于DIV#2，而是和出现顺序相同。 点击 CSS的“层”峦“叠”翠 - 示例8 - zindex: 0 和 auto 的区别 进行编辑 (@verymuch) on CodePen. 但是实际上，这两种情况并不相同。上面提到，当元素“position值为”absolute”或”relative”，且z-index指定了除了auto以外值”时，元素会产生一个堆叠上下文，虽然元素本身堆叠顺序没有影响，但是其子元素的堆叠顺序会有影响。如下例9所示。 因为DIV#1的z-index值不为auto，其产生了堆叠上下文，所以其子元素被限制在其内部，低于DIV#2(如果z-index是auto的话，DIV#3会高与DIV#2)。 点击 CSS的“层”峦“叠”翠 - 示例9 - zindex: 0 和 auto 的区别（2） 进行编辑 (@verymuch) on CodePen. 2. 不要滥用z-index，将堆叠上下文的层级结构打平笔者之所以这样建议，是因为当堆叠上下文的层级结构比较复杂时，简单的修改某个元素的z-index或者其他属性，会导致一些无法预知的影响。 如下例时所示，DIV#2是DIV#1的子元素，DIV#4是DIV#3的子元素，DIV#1和DIV#3不是堆叠上下文，则DIV#2与DIV#4的堆叠顺序与它们的z-index值对应。 点击 CSS的“层”峦“叠”翠 - 示例10 - zindex造成的影响 进行编辑 (@verymuch) on CodePen. 但如果我们在某些时候需要调整DIV#3的z-index，如将其调整成z-index: 4;，那么结果就完全不一样了。如下例11所示，DIV#4高于DIV#2了。 See the Pen CSS的“层”峦“叠”翠 - 示例11 - zindex造成的影响（2） by verymuch (@verymuch) on CodePen. 所以笔者建议，大家一定要慎用，基于对堆叠上下文的理解基础上，把握好页面中堆叠上下文的层级结构，尽量保持比较浅的层级结构，最好能与HTML层级结构一致，保证自己能够时刻知道如何进行修改与调整。 总结以上，笔者从元素的默认堆叠顺序，讲到了堆叠上下文的生成。对上述内容了解之后，就能够很好地应对开发中所遇到的层级问题了。不过还是建议大家在开发前，提前规划好z-index的使用。避免最后自己无法掌控。 参考文献 深入理解CSS中的层叠上下文和层叠顺序 Understanding CSS z-index","categories":[],"tags":[]},{"title":"ES模块基础用法及常见使用问题","slug":"ES-Module-And-Questions","date":"2019-01-06T11:18:47.000Z","updated":"2019-01-07T03:35:36.815Z","comments":true,"path":"2019/01/06/ES-Module-And-Questions/","link":"","permalink":"http://verymuch.com/2019/01/06/ES-Module-And-Questions/","excerpt":"ES6中引入了模块（Modules）的概念，相信大家都已经挺熟悉的了，在日常的工作中应该也都有使用。 本文会简单介绍一下ES模块的优点、基本用法以及常见问题。 着重介绍3个使用ES模块的常见问题： 如何在浏览器中下快速使用export/import? 如何在Node下快速使用export/import? 当心，不要修改export输出的对象，尽管你能改","text":"ES6中引入了模块（Modules）的概念，相信大家都已经挺熟悉的了，在日常的工作中应该也都有使用。 本文会简单介绍一下ES模块的优点、基本用法以及常见问题。 着重介绍3个使用ES模块的常见问题： 如何在浏览器中下快速使用export/import? 如何在Node下快速使用export/import? 当心，不要修改export输出的对象，尽管你能改 一、ES模块的优点ES模块的引入主要有以下几个优点： 可以将代码分割成功能独立的更小的文件。 有助于消除命名冲突。 不再需要对象作为命名空间（比如Math对象），不会污染全局变量。 ES6 模块在编译时就能确定模块的依赖关系，以及输入和输出的变量，从而可以进行静态优化。 二、ES模块的基本用法模块功能中主要有以下几个关键词：export、import、as、default、*。 export用于规定输出模块的对外接口 import用于输入模块提供的接口 as用于重命名输出和输入接口 default用于指定模块输出的默认接口 *表示输入模块的所有接口。 2.1 export2.1.1 常规用法export输出规定模块的对外接口，有三种常规用法： 12345678910111213141516171819// 用法1：直接输出一个变量\b声明、函数声明或者类声明export var m = 1;export function m() &#123;&#125;;export class M &#123;&#125;;// 用法2：输出内容为大括号包裹的一组变量，// 注意不要被迷惑，export不能直接输出常规的对象，下面会给出错误示例。var m1 = 1;var m2 = 2;export &#123;m1, m2&#125;;// 用法3：输出指定变量，并重命名，则外部引入时得到的是as后的名称。var n = 1;export &#123;n as m&#125;;// 用法4：使用default输出默认接口，default后可跟值或变量export default 1;var m = 1export default m; 2.1.2 错误用法需要注意的是，在使用export时会经常出现以下错误用法。如下代码所示： 123456789101112// 用法1export 1;export &#123;m: '1'&#125;;// 用法2var m = 1;export m;// 用法3function foo() &#123; export default 'bar' // SyntaxError&#125; 其中错误用法1和用法2相同，export必须输出一个接口，不能输出一个值（哪怕是对象也不行）或者一个已赋值的变量，已赋值的变量对应的也是一个值。上述常规用法中，export default后之所以可以直接跟值是因为default为输出的接口。 错误用法3是因为export只能出现在模块的顶层作用域，不能存在块级作用域中。如果出现在块级作用域的话，就没法做静态优化了，这违背ES6中模块的设计初衷了。 2.2 importimport命令用于引入模块提供的接口，有以下几种常见用法： 1234567891011121314// 用法1：仅执行 my_module 模块，不输入任何值（可能没啥用，但是是合法的）import 'my_module';// 用法2：输入 my_module 的默认接口, 默认接口重命名为 mimport m from 'my_module';// 用法3：输入 my_module 的 m 接口import &#123; m &#125; from 'my_module';// 用法4：输入 my_module 的 m 接口，使用as重命名m接口import &#123; m as my_m&#125; from 'my_module';// 用法5：导入所有接口import * as all from 'my_module'; 需要注意的是，如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。如下两种均不会多次执行。 1234567// 用法1：重复引入 my_module，只执行一次import 'my_module';import 'my_module';// 用法2：多次引入不同的接口，只执行一次import &#123; m1 &#125; from 'my_module';import &#123; m2 &#125; from 'my_module'; 此外，import命令输入的变量都是只读的，加载后不能修改接口。 12import &#123; m &#125; from 'my_module';m = 1; // SyntaxError: \"m\" is read-only 如果m是一个对象，改写m的属性是可以的。但是笔者不建议这么做，具体内容第三部分会详细说。 错误用法需要注意的是，import也必须在顶级作用域内，并且其中不能使用表达式和变量。其常见的错误用法示例如下： 12345678910111213// 用法1：不能使用表达式import &#123; 'm' + '1' &#125; from 'my_module';// 用法2：不能使用变量let module = 'my_module';import &#123; m &#125; from module;// 用法3：不能用于条件表达式if (x === 1) &#123; import &#123; m &#125; from 'module1';&#125; else &#123; import &#123; m &#125; from 'module2';&#125; 三、常见的使用问题3.1 如何在浏览器中下快速使用import?各大浏览器已经开始逐步支持ES模块了，如果我们想在浏览器中使用模块，可以在script标签上添加一个type=&quot;module&quot;的属性来表示这个文件是以module的方式来运行的。如下： 1234567891011// myModule.jsexport default &#123; name: 'my-module'&#125;// script脚本引入&lt;script type=\"module\"&gt; import myModule from './myModule.js' console.log(myModule.name) // my-module&lt;/script&gt; 不过，由于ES的模块功能还没有完全支持，在不支持的浏览器下，我们需要一些回退方案，可以通过nomodule属性来指定某脚本为回退方案。如下，在支持的浏览器中进行提示。 1234567&lt;script type=\"module\"&gt; import myModule from './myModule.js'&lt;/script&gt;&lt;script nomodule&gt; alert('你的浏览器不支持ES模块，请先升级！')&lt;/script&gt; 如上，当浏览器支持type=module时，会忽略带有nomodule的script；如果不支持，则忽略带有type=module的脚本，执行带有nomodule的脚本。 在使用type=module引入模块时还有一点需要注意的，module的文件默认为defer，也就是说该文件不会阻塞页面的渲染，会在页面加载完成后按顺序执行。 3.2 如何在Node下快速使用export/import?相信大家都遇到过如下错误： 当我们直接在node下执行包含ES模块的的代码时，就会看到如上报错，这是因为Node还没有原生支持ES模块。但有的时候我们又想在Node下使用，那么该如何做呢？ 下面介绍两种快捷的方法，一种是Node原生支持的，一种需要借助Babel进行编译。 3.2.1 Node原生支持Node从9.0版本开始支持ES模块，可以在flag模式下使用ES模块，不过这还处于试验阶段（Stability: 1 - Experimental）。其用法也比较简单，执行脚本或者启动时加上--experimental-modules即可。不过这一用法要求import/export的文件后缀名必须为*.mjs。 123456node --experimental-modules test-my-module.mjs// test-my-module.mjsimport myModule from './myModule.mjs'console.log(myModule.name) // my-module 这是Node原生支持的方法，但是对文件的后缀名有限制，但是现阶段，我们在项目中的代码应该还是以.js为后缀居多，所以大多数情况下我们还是会通过编译使用ES模块。 下面我们就介绍下如何快速编译并使用ES模块。 3.2.2 借助babel-node执行包含ES模块代码的文件平时我们可能会借助构建工具对ES模块，可能是借助Webpack/Rollup等构建工具进行编译，这些工具配置起来都相对繁琐。 有时，我们只想简单的执行某些代码，而其中又包含ES模块代码，就会发生问题，因为node默认不支持。这时候如果进行一堆配置来使其支持的话，又太过麻烦。 下面我给大家介绍一种看起来更加快捷的方法。 安装babel-cli和babel-preset-env，并将其保存为开发依赖。 在根目录创建.babelrc文件，在其中添加如下配置。 123&#123; \"presets\": [\"env\"]&#125; 通过./node_modules/.bin/babel-node index.js或npx babel-node index.js执行脚本。其中babel-node为babel-cli自带。 怎么样，是不是相当快捷了，而且近乎于0配置。 3.3 当心，不要修改export输出的对象，尽管你能改前面有提到如果export输出的接口是一个对象，那么是可以修改这个对象的属性的。 而我的建议是，尽管你能改，也不要修改。 大家可能都会有这样一个常规的用法，即在编写某个组件时，可能会存在包含基础配置的代码，我们姑且称其为options.js，其输出一堆配置文件。 12345678// options.jsexport default &#123; // 默认样式 style: &#123; color: 'green', fontSize: 14, &#125;&#125; 如果你没有类似需求，你可以想象下，你现在要把EChart的某个图表抽象成自己代码库里的组件，那么这时候应该就有一大堆基础配置文件了。 既然称其为基础配置，那么言外之意就是，根据组件的用法不同，会一定程度上对配置进行修改。比如我们会在引入后将颜色改为红色。 123456// use-options.jsimport options from \"./options.js\";console.log(options); // &#123; style: &#123; color: 'green', fontSize: 14 &#125; &#125;options.style.color = \"red\"; 这时候就需要格外注意了，如果我们直接对输入的默认配置对象进行修改，就可能会导致一些bug。 因为export输出的值是动态绑定的，如果我们修改了其中的值，就会导致其他地方再次引入该值时会发生变化，此时的默认配置就不是我们所设想的默认配置了。如上例，我们再次引入基础配置后，就会发现颜色的默认值已经变成红色了。 12345// use-options-again.jsimport useOptions from \"./use-options.jsimport options from \"./options.js\";console.log(options); // &#123; style: &#123; color: 'red', fontSize: 14 &#125; &#125; 所以，笔者建议，当我们有需求对输入的对象接口进行改变时，可以先对其进行深度复制，然后在进行修改，这样就不会导致上述所说的问题了。如下所示： 1234567// use-options.jsimport _ from \"./lodash.js\";import options from \"./options.js\";const myOptions = _.cloneDeep(options);console.log(myOptions); // &#123; style: &#123; color: 'green', fontSize: 14 &#125; &#125;myOptions.style.color = \"red\"; 四、总结本文只是简单点的介绍了下ES模块的基本用法，还有一些用法，如import和export的结合使用等，这些大家可以结合MDN或者其他网站进行了解。本文主要是介绍了以下笔者及身边的同事在使用ES模块时会存在的一些疑问，希望对大家有一点帮助。 参考内容 Export | MDN Import | MDN 7 Different Ways to Use ES Modules Today! Import, Export, Babel, and Node","categories":[],"tags":[]},{"title":"浏览器缓存策略之扫盲篇","slug":"web-browser-cache-strategy","date":"2018-10-09T07:45:32.000Z","updated":"2018-10-15T03:22:18.115Z","comments":true,"path":"2018/10/09/web-browser-cache-strategy/","link":"","permalink":"http://verymuch.com/2018/10/09/web-browser-cache-strategy/","excerpt":"前言众所周知，在Web开发中，缓存很重要、很有用。但同时其也很复杂。 本文将从以下5个方面全面地介绍下缓存相关的内容。 缓存的判断策略 必知必会的缓存基础 各类缓存的优缺点 缓存的最佳实践 小试牛刀，看看你掌握了没有？","text":"前言众所周知，在Web开发中，缓存很重要、很有用。但同时其也很复杂。 本文将从以下5个方面全面地介绍下缓存相关的内容。 缓存的判断策略 必知必会的缓存基础 各类缓存的优缺点 缓存的最佳实践 小试牛刀，看看你掌握了没有？ 一、缓存的判断策略浏览器对于所请求资源的缓存处理有一套完整的机制，主要包含以下三个策略：存储策略、过期策略、协商策略。 其中，存储策略发生在收到请求响应后，用于决定是否缓存相应资源；过期策略发生在请求前，用于判断缓存是否过期；协商策略发生在请求中，用于判断缓存资源是否更新。 浏览器在应用缓存策略时，具体的判断流程如下： 上图中的缓存判断流程是浏览器在应用缓存时完整的判断流程。但是在浏览器中访问资源的方式不同也会导致判断流程的不同。判断流程会根据不同方式跳过一些流程。 浏览器下访问资源的方式主要有以下7种： (新标签)地址栏回车 链接跳转 前进、后退 从收藏栏打开链接 (window.open)新开窗口 刷新（Command + R / F5） 强制刷新（Command + Shift + R / Ctrl + F5） 使用这7种方式访问资源时，应用缓存的策略会有一些不同。如下图所示。通过上述7种方式访问资源，会从不同的缓存应用判断步骤开始。此处不做验证，相信大家看了后面的内容，能够自行验证的。 需要注意的是，Chrome中在当前地址栏，不改变内容，直接回车，等同于刷新当前页，而在Firefox下与其他在地址栏回车一样。这一点比较特殊，需要适当区分下。 本文配有测试脚本，代码在github上。下文会按照测试脚本进行述说，使用说明见下载链接。验证上述内容，可以执行node cache-ETag+max-age.js，会同时开启ETag和max-age，然后触发相应的动作，通过Network面板和node日志即可验证，此处篇幅有限先不赘述。 此外，这里提一个概念，webkit资源分为主资源和派生资源。主资源是地址栏输入的URL请求返回的资源，派生资源是主资源中所引用的JS、CSS、图片等资源。 在Chrome下刷新时，只有主资源的缓存应用方式如上图所示，派生资源的缓存应用方式与新标签打开类似，会判断缓存是否过期。强缓存生效时的区别在于新标签打开为from disk cache，而当前页刷新派生资源是from memory cache。 而在Firefox下，当前页面刷新，所有资源都会如上图所示。下文也会利用Chrome的这一特点在当前页刷新，派生资源会使用缓存进行测试。不然每次都需要打开新标签较为繁琐。 二、必知必会的缓存基础HTTP中与缓存有关的字段主要有以下10个，如下表所示。为明确表示其功能及用法，下表中分别区分了存储策略、过期策略、协商策略、请求头、响应头。 Key 描述 存储策略 过期策略 协商策略 请求头 响应头 Expires 指定缓存的过期时间，值为某一时刻（绝对时间）。在指定时刻后过期 ✓ ✓ ✓ Cache-Control 指定缓存机制 ✓ ✓ ✓ ✓ Pragma 指定缓存机制(http1.0字段) ✓ Last-Modified 资源最后修改时间 乄 ✓ ✓ If-Modified-Since 缓存协商校验字段，为上次请求收到的Last-Modified的值。处理方式见下文。 ✓ ✓ If-Unmodified-Since 缓存协商校验字段，为上次请求收到的Last-Modified的值。处理方式与If-Modified-Since相反，见下文。 ✓ ✓ ETag 请求资源的唯一标识字符串 ✓ ✓ If-Match 缓存协商校验字段，请求资源的唯一标识字符串，为上次请求收到的ETag的值。处理方式见下文。 ✓ ✓ If-None-Match 缓存协商校验字段，请求资源的唯一标识字符串，为上次请求收到的ETag的值。处理方式与If-Match相反，见下文。 ✓ ✓ 注：乄表示半对，Last-Modified之所以是半对，是因为有可能会触发启发式缓存，也会缓存文件。具体见下文。 缓存又分为强缓存和弱缓存（又称为协商缓存）。其中强缓存包括Expires和Cache-Control，主要是在过期策略生效时应用的缓存。弱缓存包括Last-Modified和ETag，是在协商策略后应用的缓存。强弱缓存之间的主要区别在于获取资源时是否会发送请求。 2.1 Expires如上所述，Expires指定缓存的过期时间，为绝对时间，即某一时刻。参考本地时间进行比对，在指定时刻后过期。RFC 2616建议最大值不要超过1年。 Expire头字段是响应头字段，格式如下：Expires: Sat Oct 20 2018 00:00:00 GMT+0800 (CST)。 可以尝试以下步骤进行验证： \b执行node cache-Expires.js，该脚本会给请求的资源设定Expires，值为：”2018-10-20 00:00:00”。 访问地址http://localhost:1030/，开启Network Tab，查看avatar.jpg图片，Expires值如下所示。 再次刷新会看到该资源已经被缓存，size栏显示为(from memory cache)。此时修改本地时间，将时间修改为“2018-10-15 00:00:00”，再刷新，会发现缓存仍然有效。 如果将本地时间修改为“2018-10-25 00:00:00”，再刷新，会发现图片不再使用缓存，而是重新获取了，因为本地时间超过了设定值。 2.2 Cache-ControlCache-Control用于指定资源的缓存机制，可以同时在请求头和响应头中设定，涉及上述三个策略中的两个策略：存储策略、过期策略。 Cache-Control的语法如下：Cache-Control: cache-directive[,cache-directive]。cache-directive为缓存指令，大小写不敏感，共有12个与HTTP缓存标准相关，如下表所示。其中请求指令7种，响应指令9种。Cache-Control可以设置多个缓存指令，以逗号,分隔。 Key 描述 存储策略 过期策略 请求字段 响应字段 可缓存性相关 public 资源在客户端和代理服务器缓存 ✓ ✓ private 资源仅在在客户端缓存，\b代理服务器不缓存 ✓ ✓ no-cache 资源被缓存，但立即过期，下次访问时强制向服务器验证资源有效性。相当于max-age:0,must-revalidate ✓ ✓ ✓ ✓ 过期相关 max-age=&lt;seconds&gt; 在请求头中：指出客户端不接受有效时间大于指定时间的缓存。 在响应头中：规定资源的最大新鲜时间，指定时间后过期，单位为秒。 ✓ ✓ ✓ ✓ s-maxage=&lt;seconds&gt; 同上，但只对代理服务器生效，如果是private缓存，会忽略该字段。会覆盖max-age或Expires头字段 ✓ ✓ ✓ max-stale=&lt;seconds&gt; 指定时间内, 即使缓存过时, 资源依然有效 ✓ ✓ min-fresh=&lt;seconds&gt; 缓存的资源至少要保持指定时间的新鲜期 ✓ ✓ 验证与重载相关 must-revalidate 使用缓存资源之前，必须先验证状态，并且过期资源不应该再使用。 ✓ ✓ proxy-revalidate 同上，但只对代理服务器生效，如果是private缓存，会忽略该字段。 ✓ ✓ 其他 no-store 请求和响应都不缓存 ✓ ✓ ✓ only-if-cached 仅返回已经缓存的资源，不再向服务器获取新的内容。若无缓存则返回504 ✓ no-transform 强制要求代理服务器不要对资源进行转换, 禁止代理服务器对 Content-Encoding, Content-Range, Content-Type字段的修改(因此代理的gzip压缩将不被允许) ✓ ✓ 2.3.1 cache-directive大小写不敏感如上，cache-directive指令大小写不敏感，所以在设置Cache-Control时，指令可以不区分大小写。不过建议统一使用小写。验证如下： 执行node cache-directive-case-insensitive.js，会服务端会将max-age写成大写，如下Cache-Control: MAX-AGE=86400。 再次请求浏览器会发现缓存同样会生效。 2.3.2 在请求头中的max-agemax-age在请求头中的主要应用为max-age=0表示不使用缓存。Chrome和Firefox浏览器下的刷新操作（Command+ R / F5）均是在请求头上添加了max-age=0\u001d指令，表示不使用强缓存，但允许协商缓存（在介绍了协商缓存的Last-Modified和ETag之后，可以自行验证下这一点）。\b 刷新时Cache-Control为max-age=0验证如下： 单独访问图片资源http://localhost:1030/avatar.jpg，开启Network 刷新，可在响应头中看到上述内容。如下图所示。（Firefox下相同，不单独验证，主要最开始提到的主资源和派生资源在两个浏览器中表现形式的不同）。 此外，经验证，Chrome和\bFirefox均对max-age&gt;0的情况支持不好。 在Chrome下，通过Modify Headers插件（Chrome和Firefox下均有类似插件）给请求添加max-age=7200。 \b执行node cache-max-age.js，访问http://localhost:1030，先强刷保证资源更新。 打开NetWork，查看avatar.jpg，刷新，会发现，资源访问仍然走的是缓存。如果按照规范的定义应该是不生效。 2.3.3 max-age与ExpiresCache-Control中的max-age指令用于指定缓存过期的相对时间。\b资源达到指定时间后过期。该功能与Expires类似。但其优先级高于Expires，如果同时设置max-age和Expires，max-age生效，忽略Expires。验证如下： 执行node cache-max-age+Expires.js，会同时设置Cache-Control: max-age=86400 / Expires: Mon Oct 20 2018 00:00:00 GMT+0800 (CST)，如下所示。 刷新，\b然后再把本地时间改成当前时间延后2小时(不超过20号)，会发现缓存生效。\b(以下两步不再附截图，与上述示例类似)。 如果将时间改为两天后（假设20号离现在大于两天，否则结果相反），会发现缓存不再生效，因为超出了max-age的限制。 相反，可以再试一下，max-age的有效时间大于Expires的情况，会发现依然是max-age生效。 2.3.4 no-cache和no-store还有一点需要注意的是，no-cache并不是指不缓存文件，no-store才是指不缓存文件。no-cache仅仅是表明跳过强缓存，强制进入协商策略。 2.3 Pragmahttp1.0字段, 通常设置为Pragma:no-cache, 作用与Cache-Control:no-cache相同。当在浏览器进行强刷（Comand + Shift + R / Ctrl + F5）或在NetWork面板内勾选禁用缓存（Disable Caches）时，会自动带上Pragma:no-cache和Cache-Control:no-cache，并且不会带上协商策略中所涉及的信息（下面介绍的If-Modified-Since/If-None-Match）。这是不会使用任何缓存，重新获取资源。如下图所示。 2.4 Last-Modified/If-Modified-Since/If-Unmodified-SinceLast-Modified用于标记请求资源的最后一次修改时间。语法格式为：Last-Modified: &lt;day-name&gt;，&lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT，即GMT(格林尼治标准时间)。可用 new Date().toGMTString()获取当前GMT时间。由于Last-Modified只能精确到秒，因此不适合在一秒内多次改变的资源。 如果Expires，Cache-Control: max-age，或 Cache-Control:s-maxage都没有在响应头中出现，并且设置了Last-Modified时，那么浏览器默认会采用一个启发式的算法，即启发式缓存。通常会取响应头的Date_value - Last-Modified_value值的10%作为缓存时间。验证如下： 执行node cache-Last-Modified.js，服务器会获取资源的最后修改时间，设置为Last-Modified的值。访问localhost:1030，查看avatar.jpg，如下图所示： 刷新浏览器，会发现图片会从缓存获取。 通过启发式缓存的公司可以计算出缓存的时间，修改本地时间超过缓存时间后，再刷新，会发现缓存失效。 2.4.1 If-Modified-Since返回的资源带有Last-Modified标识时，再次请求该资源，浏览器会自动带上If-Modified-Since，值为返回的Last-Modified值。请求到达服务器后，服务器进行判断，如果从上次更新后没有再更新，则返回304。如果更新了则重新返回。验证如下： 执行node cache-Last-Modified.js，服务器会获取资源的最后修改时间，设置为Last-Modified的值。如下图所示，并且注意看一下资源的大小。 \b刷新页面，再次查看NetWork。会发现请求头中带上了If-Modified-Since。如果服务器判断资源未改变，则返回304，此外由于服务器返回304，资源会从缓存获取，所以资源大小也减少了，如下所示。 修改index.html文件的内容，再次刷新。会发现返回变成200，html内容更新了，并且返回了新的\bLast-Modified的值，资源大小也相应地改变了。 304请求也可以触发存储策略，如文章开头的流程判断图所示，可自行验证，返回时添加相应header即可。 注意，If-Modified-Since只能用于GET、HEAD请求。 2.4.2 If-Unmodified-SinceIf-Unmodified-Since表示资源未修改则正常执行更新，否则返回412(Precondition Failed)状态码的响应。主要有如下两种场景。 用于不安全的请求中从而是请求具备条件性（如POST或者其他不安全的方法），如请求更新wiki文档，文档未修改时才执行更新。 与If-Range字段同时使用时，可以用来保证新的片段请求来自一个未修改的文档。 2.5 ETag/If-Match/If-None-MatchETag是请求资源在服务器的唯一标识，浏览器可以根据ETag值缓存数据。在再次请求时通过If-None-Match携带上次的ETag值，如果值不变，则返回304，如果改变你则返回新的内容。 需要注意的是，ETag和If-None-Match的值均为双引号包裹的。 验证步骤与Last-Modified相似。执行node cache-ETag.js即可。此处不再详述。 If-Match判断逻辑逻辑与If-None-Match相反。 最后，ETag的优先级高于Last-Modified。当ETag和Last-Modified，ETag优先级更高\b，但不会忽略Last-Modified，需要服务端实现。验证如下，其中服务端判断优先级： 执行node cache-ETag+Last-Modified.js。服务端会在资源的响应头中，同时设置ETag和Last-Modified。如下图： 刷新浏览器，会发现index.html请求时304。查看node日志，会看到ETag生效。如下： 三、缓存的优缺点好了，通过长长的第二部分，我们\b简单介绍了一下HTTP Cache的基础知识。下面我再汇总一下各类缓存之间的优缺点吧。如下表所示： 缓存头部 优点 缺点 Expires 1. HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用。 2. 简单易用，通过绝对时间标识失效时间。 1. 时间为服务器返回的时间，如果本地时间与服务器时间不一致，则可能会出现问题。（如上述我们通过修改本地时间是缓存失效。） 2. 存在版本问题，在资源过期之前如果\b对资源进行修改，客户端都是无法获知的。 Cache-Control 1. \bHTTP 1.1的内容，以相对时间标识失效时间，解决了Expires服务器和客户端相对时间的问题。 2. 支持的指令较多，可以根据需要进行相应的配置。 1. HTTP 1.1 才有的内容，不适用于HTTP 1.0 。 2. 与Expires类似，存在版本问题，在资源过期之前如果\b对资源进行修改，客户端都是无法获知的。 Last-Modified 1. 不存在版本问题，每次都会跟服务器进行校验，符合则304不返回资源，不符合则重新返回资源。 1. 以时刻作为标识，精确到秒，无法识别一秒内进行多次修改的情况。 2. 只要资源\b被修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。 ETag 1. 不存在版本问题，每次都会跟服务器进行校验，符合则304不返回资源，不符合则重新返回资源。 2. \b可以更加精确的判断资源是否被修改。 3. 可以识别一秒内多次修改的情况。 1. 计算ETag\b值会对性能造成一定消耗。 2. 分布式服务器存储的情况下，需要保证计算ETag的算法一致。如果不一致，会导致资源在不同服务器上验证不通过。 四、最佳实践从上面各类缓存的优缺点可以看出，每一种缓存都不是完美的。所以建议像下面这样做： 不要缓存HTML，避免缓存后用户无法及时获取到更新内容。 使用Cache-Control和ETag来控制HTML中所使用的静态资源的缓存。一般是将Cache-Control的max-age设成一个比较大的值，然后用ETag进行验证。 使用签名或者版本来区分静态资源。\b这样静态资源会生成不同的资源访问链接，不会产生修改之后无法感知的情况。 还有两个本文没有介绍的内容，但是不建议大家使用： 使用\bHTML的meta标签来指定缓存行为 使用查询字符串来避免缓存。因为缓存有一些已知的问题，使用查询字符串会导致有些代理服务器不缓存资源。 五、小试牛刀，看看你掌握了没有？看了这么多内容，是时候来看看成果了。那么一起看下下面的问题吧。 如果首次访问localhost:1030时，页面中 avatar.png 响应头信息如下： 123456HTTP/1.1 200 OKCache-Control: no-cacheContent-Type: image/pngLast-Modified: Tue, 16 Oct 2018 11:42:28 GMTAccept-Ranges: bytesDate: Tue, 16 Oct 2018 15:57:21 GMT 问题1：请问当刷新该页面后，avatar.png如何二次加载？ 问题2：如果将上述信息中的Cache-Control设置为 private，那么结果又会如何呢？ 大家先回忆下上面的内容，思考一下。 试题来源：彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法。在此致谢。 好了公布答案。 问题1：会带着If-Modified-Since和服务端进行验证。未改变返回304，改变返回200。 问题2：Cache-Control设置为 private，这时候会触发启发式缓存，则再次刷新时，avatar.png命中强缓存，从缓存中换取。 总结好了，文章到此结束，希望能对大家有帮助。 致谢感谢《深入浅出Vue.js》作者刘博文对本文提出的宝贵建议。 参考链接 MDN | Cache-Control 彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法 由memoryCache和diskCache产生的浏览器缓存机制的思考 A Web Developer’s Guide to Browser Caching 浏览器缓存机制剖析 HTTP 缓存 Are Your Cache-Control Directives Doing What They Are Supposed to Do? Hypertext Transfer Protocol","categories":[],"tags":[]},{"title":"从撒狗粮带你了解WoT连接场景","slug":"从撒狗粮带你了解WoT连接场景","date":"2018-08-29T02:56:56.000Z","updated":"2018-09-20T07:23:56.514Z","comments":true,"path":"2018/08/29/从撒狗粮带你了解WoT连接场景/","link":"","permalink":"http://verymuch.com/2018/08/29/从撒狗粮带你了解WoT连接场景/","excerpt":"歪马是一名IT男，30岁，单身，之前每年的情人节、七夕节、圣诞节…可以说是没少被“撒狗粮”。这不，歪马今年决定要改变这一现状。而故事就是从这里开始的。 为了避免跑题，笔者表示要强势切入，下面我们先简单介绍下物联网和万维物联网。 一、物联网和万维物联网在最近几年里，物联网（Internet of Things，简称IoT）已经成为了在技术和商业上最有前途、最激动人心的发展领域之一。相信大家对于物联网已经或多或少有些了解。大家也一定使用过类似的产品，如可以远程实时查看录像、同步进行语音通话的360智能摄像机；可以远程控制家用电器开关的智能插座；可以智能检测心率和睡眠的智能手表以及其他一系列智能产品。 物联网是一个物理对象系统，其中的电子设备通过各种各样的网络接口进行通信，从而可以被发现、监控、控制交互，最终可以连接到更大的网络。上面所提到的几种产品即可以认为是其中的电子设备。 万维物联网（Web of Things，简称WoT）是物联网的一种实现方式，它主要致力于建立一种通用的语言，从而让不同厂商的智能产品具有彼此实现互相操作的可能。","text":"歪马是一名IT男，30岁，单身，之前每年的情人节、七夕节、圣诞节…可以说是没少被“撒狗粮”。这不，歪马今年决定要改变这一现状。而故事就是从这里开始的。 为了避免跑题，笔者表示要强势切入，下面我们先简单介绍下物联网和万维物联网。 一、物联网和万维物联网在最近几年里，物联网（Internet of Things，简称IoT）已经成为了在技术和商业上最有前途、最激动人心的发展领域之一。相信大家对于物联网已经或多或少有些了解。大家也一定使用过类似的产品，如可以远程实时查看录像、同步进行语音通话的360智能摄像机；可以远程控制家用电器开关的智能插座；可以智能检测心率和睡眠的智能手表以及其他一系列智能产品。 物联网是一个物理对象系统，其中的电子设备通过各种各样的网络接口进行通信，从而可以被发现、监控、控制交互，最终可以连接到更大的网络。上面所提到的几种产品即可以认为是其中的电子设备。 万维物联网（Web of Things，简称WoT）是物联网的一种实现方式，它主要致力于建立一种通用的语言，从而让不同厂商的智能产品具有彼此实现互相操作的可能。 Web比较适合用来建立这样一种通用的语言，它具备以下4个优点： 更容易编程：万维网协议可以很容易地用来读写设备数据，而且特别简单易用，比复杂的物联网协议学起来更快。 更加开放和可扩展：万维网标准如此流行的原因即因为它们是完全开放和免费的。使用它们能够确保数据可以被快速、方便地跨系统转移，可扩展性更高。 能够快速简单部署、维护与集成。 安全和隐私机制使用的更加广泛。 好了，关于\b物联网和万维物联网的基本介绍就到这里了，本文将主要以一种生动有趣的方式着重介绍下WoT的6种连接场景。 二、WoT的连接场景故事继续，为了改变每年都被别人“撒狗粮”情况，歪马决定改变现状。歪马从小比较喜欢小动物，尤其是聪明温顺的狗狗，这回歪马决定养一只狗狗陪伴自己。这样每次被“撒狗粮”时，可以真真切切的撒回去（不管你觉不觉得这逻辑可爱，笔者觉得挺可爱的）。 歪马养了一只短腿小柯基，并为其起名为大屁，因为柯基一扭一扭的屁股甚是可爱。下面我将带着歪马和大屁一起先介绍下WoT的第一种连接场景。 2.1 场景1：通过Web服务进行设备的控制第一个要说的连接场景是通过Web服务进行设备的控制。 身为IT男的歪马和我们大家一样常常从早忙到晚，不能按时回家，这可苦了他的爱犬大屁，因为大屁经常是吃了上顿没下顿。但歪马又不能不限量地给大屁留狗粮，因为这有可能导致大屁进食过量，健康产生问题。 为了解决大屁吃的既准时又不会过量的问题，歪马花费了不少精力，专门开发了一套基于微信的程序，这样无论身在地球上哪个角落，只要能上网，就不会饿着大屁了。 歪马给大屁注册了一个微信号，需要喂食时，歪马会给大屁发送一条“@大屁 过来吃饭啦”的消息。家中的电脑收到后，就会启动一个扬声器。扬声器中会播放歪马呼唤大屁进食的录音，这样大屁听到声音后就会跑过来，坐在狗粮盆前面等着。此时，一个马达启动，打开粮箱上的活门，里面的狗粮会顺着管子落到大屁的盆里。并且在程序内可以设定每次投放的狗粮量，这样也能保证大屁不会变成一条肥狗啦。 说了这么多，大家可能很懵？故事还不错，但这和IoT/WoT有啥关系呢？又该如何理解这一场景呢？ 现在让我们一起来抽象下。 首先，我们考虑下在歪马家里用于喂狗的这个装置包括哪些东西，我们将其想象成一个整体——自动喂狗装置。 自动化喂狗装置组成部分： 电脑：具有Web服务器功能，可以连接到互联网，可以监听事件，用于接受指令。 \b扬声器：用于播放歪马呼唤大屁进食的录音。 狗粮倾倒装置：启动后可以漏出狗粮，并且可以定量投放，\b投放完毕后关闭。 好了，如上，已经有了一个自动化喂狗装置。这个喂狗装置具有Web服务器功能，能够直接连接到互联网，歪马可以通过连接到互联网的设备（如手机或电脑设备上的浏览器或原生应用）向喂狗装置发送命令，喂狗装置收到后就可以自动喂狗啦。 这一场景就是WoT的第一种连接场景：一个具有Web服务器功能的电子设备可以直接连接到互联网，这时，我们可以通过手机或电脑设备上的浏览器或原生应用，借助互联网（如蜂窝网，运营商网络）对\b电子设备进行控制。 连接场景图示如下： 2.2 场景2：通过本地Web服务进行设备的控制上面的连接场景应该很容易理解。下面我们再考虑下\b下面这个场景： 作为IT男的歪马非常喜爱足球，每逢世界杯比赛时，总免不了全神贯注地观看比赛直播。他为自己在卧室里准备了一个大大的液晶电视，这样每当有球赛的时候就能舒舒服服地观看比赛了。如果看比赛的时候，大屁饿了，他又不想错过直播去给大屁倒狗粮，那么很简单他可以打开电脑或者拿出手机，和在公司上班时一样，远程投放狗粮。 但是，\b事情总会有例外，正值世界杯比赛的某个周末，歪马所在小区的网络故障，没法正常使用了。那么大家觉得歪马的喂狗装置还能不能用呢？ 答案当然是肯定的，作为程序员的歪马深知代码鲁棒性的重要性。所以他设计这套系统已经考虑到这种情况了。在没有联网的情况下，也可以支持本地局域网运行，所以只要家里还有电，喂狗装置和他的手机/电脑处于同一个本地网络，那么他依然可以通过手机/电脑进行喂狗装置的控制。这也就是我们所要介绍的第二种连接场景：一个具有Web服务器功能的电子设备，在没有连接到互联网的情况下，我们可以使用手机或者电脑，通过本地网络对电子设备进行控制。 连接场景图示如下： 2.3 场景3：使用蓝牙遥控器进行设备的控制有点时候拿出手机/电脑再进行控制多少有些麻烦，相对而言我们使用的电视遥控器反而更加简单。但是电视之类的遥控器，因为是红外设备，需要对准，而歪马又不能保证能够随时对准喂狗装置的所在。 于是歪马想到了一个点子，他给喂狗装置添加了蓝牙设备，并且使用蓝牙设备制作了一款遥控器，这样只要两个蓝牙设备配对后，在房间内的任意位置（一定范围内）都可以进行设备的控制了。 怎么样，歪马是不是很厉害，他上面所做的这一改变就是\bWoT的第三种连接场景：如果设备存在某种限制不能连接到互联网，那么其可以通过蓝牙等设备进行连接，这样即可通过遥控器对设备进行控制。（当然，红外设备也是可以的，下面我们要介绍的场景与其类似）。 连接场景图示如下： 2.4 场景4：使用感应器进行设备的控制解决了大屁吃饭的问题后，\b还有一个同样重要的问题，那就是喝水的问题。 夏天天气热，狗狗又非常怕热，歪马每天上班都会给大屁倒满满一盆的水，但是回家之后，总会被喝的精光。换个能盛更多水的大盆又怕夏天容易滋生细菌。 为了解决大屁喝水的问题，歪马想到了一个好点子，\b他买了一个水位感应器安装在了水盆内，当大屁把水喝的精光时，水位感应器感应到没有水后，会向水箱发送一个没水的信号，水箱中的控制代理接收到信号后，会打开水箱自动向水盆注入3/4的水。如此一来，歪马只要定期向水箱中添加纯净水就行了，大屁也能放心地喝水啦。 使用感应器进行设备的控制即为WoT的第四种连接场景：利用感应器探测到某一条件到达指定值时，\b设备检测到这一变化后，可以做出相应的动作。 连接场景图示如下： 2.5 场景5：使用网关进行中转场景4中的智能水箱中使用的控制代理属于比较旧的设备，而感应器有时候又不是那么灵敏，可能要等水没有一段时间后才会加水。 于是歪马在想，如果也能够远程进行水箱的控制就好了。由于\b水箱的控制代理和感应器没法直接连接到互联网，于是他在本地网络和互联网之间加入了网关，通过网关来进行中转。这样即使是感应器这样的设备也也能够通过网关连接到互联网，能够实时将水箱中的剩余水量上报到服务器中。歪马可以直接远程查看，当歪马远程喂食的时候\b，如果发现水盆中水量不多时，可以直接定量加满即可。 上面这种使用网关进行中转的方式即为WoT的第五种连接场景：如果存在不能直接连接到互联网的设备或者使用其他协议的设备时，可以通过在本地网络和互联网之间添加网关，借助网关来进行中转。本地设备有状态发生变化时，可以通过网关转换后进行上报。远程有新的指令达到时，也可以通过网关转换后下达给指定设备。 连接场景图示如下： 2.6 场景6：使用云来管理设备机会总是会降临到有准备的人头上。 虽然歪马从来没有想过为大屁开发的这款智能喂狗装置会给自己带来什么。但这款喂狗装置被商界人士得知后，有人联系歪马，想要进行投资量产。歪马当然欣然接受了合作。于是和合作公司开始讨论喂狗装置如何量产，还有哪些功能需要优化。 其中就有这样一个问题，如果设备被量产的话，不可能每个人的喂狗装置都和自己的控制设备直接连接，这时候就需要有一个云服务器来进行云端存储。每个人的喂狗装置通过用户自己的账号，连接到云端，喂狗装置的各部件会实时将自身的状态同步到云端。用户打开控制设备后，会同步各部件的状态。用户可以通过控制设备下发指令，指令通过云端进行中转，然后下发到喂狗装置。这样做还有一个好处，如果喂狗装置出现临时断线等情况时，控制设备所发送的指令也会在云端临时存储，在装置接入后继续下达指令。 上面这种情况即为WoT的第六种连接场景：云端就绪的设备直接连接到云端，其自身的状态会在云端做个镜像，这个镜像会充当一个代理，用于接收远程控制设备的指令。 连接场景图示如下： 三、多场景共存上面分别介绍了WoT的6种独立连接场景，\b其实这些连接场景是可以共存的，汇总到一起后如下图所示： 好了，WoT的连接场景介绍完毕了。最后问一句\b，你觉得歪马这狗粮撒的如何？ 致谢感谢奇舞团小伙伴李冬杰对本文的审校与意见。 参考文献 英国IT男因工作繁忙写程序远程喂狗 WoT技术架构（草案） [书]从物联到万联","categories":[],"tags":[{"name":"WoT","slug":"WoT","permalink":"http://verymuch.com/tags/WoT/"}]},{"title":"W3C标准导读之【标准化过程】","slug":"W3C标准导读之标准化过程","date":"2018-08-19T13:40:37.000Z","updated":"2018-08-27T13:07:01.950Z","comments":true,"path":"2018/08/19/W3C标准导读之标准化过程/","link":"","permalink":"http://verymuch.com/2018/08/19/W3C标准导读之标准化过程/","excerpt":"本文作者：高峰，360奇舞团前端工程师，W3C性能工作组成员，同时参与WOT工作组的学习。 一、引言W3C的标准很多，你看或不看，它都在那，有增无减。既然如此，那我们为什么要读标准呢？笔者认为可能有以下4点原因：","text":"本文作者：高峰，360奇舞团前端工程师，W3C性能工作组成员，同时参与WOT工作组的学习。 一、引言W3C的标准很多，你看或不看，它都在那，有增无减。既然如此，那我们为什么要读标准呢？笔者认为可能有以下4点原因： 有一颗贡献标准的心，想要通过自己的努力为标准作出贡献； 对知识内容有执着的追求，想通过标准来彻底了解某些知识点； 熟悉标准已经成为我们应聘时的加分项甚至是基本项，我们不得不学； 当然，我们还可以通过学习W3C标准来提升英语阅读能力以及写作缜密性。 或许你阅读标准的理由不是上面之一，但我们总归是要开始读标准了，不是吗？开始之前，我们准确地了解下W3C是什么。 万维网联盟（World Wide Web Consortium，以下简称W3C）创建于1994年，是Web技术领域最具权威和影响力的国际中立性技术标准机构。它的使命是开发促进万维网发展、确保万维网互操作性的通用协议，从而尽展万维网的全部潜能。 W3C一共有36个工作组（截止至2018年8月21日，本文书写时间），已经制定了200多个标准。如此多的工作组是如何有序而又保证质量地完成如此多的标准制定的呢？正所谓没有规矩不成方圆，如此庞大的工作必然需要一个准则，所以W3C制定了流程文档1。该文档描述了W3C的组织结构以及为完成W3C自身使命而履行的职责和职能相关的流程。 流程文档的主要受众是标准制定相关成员，但是其中也有一部分内容有助于作为读者的我们理清阅读的思路，笔者即将这一部分提取出来，以供大家阅读。 那么，我们先从简单了解Web技术标准化的过程概览开始吧。 二、Web技术标准化过程概览通常情况下，W3C标准的标准化过程包括以下几步： 首先，有人开始对某个特定的话题产生兴趣。 当这个特定话题的关注度越来越高时，W3C主任会宣布为一个或多个兴趣组以及工作组开发提案章程。W3C成员审查提案章程。 当W3C内部有人支持在某个被关注的主题上投入资源时，W3C主任会批准成立工作组，该小组正式开始工作。 工作组章程包含了每个小组期望的可交付成果，工作组会按照这一期望建立标准和指南。 这些标准和指南需要经过反复的修订和审核，要接受W3C成员和大众的审核，且要满足实现和互操作性方面的要求。 最后，顾问委员会审查成熟的技术报告，如果通过则发布为标准 上述是标准产生的一个简要过程，具体的过程包括标准化过程中所涉及的组以及标准所经历的版本（或成熟度等级）下面会详细介绍。我们先从标准化过程中所涉及的组开始。 三、W3C中的组上面的标准化流程概览中提到了很多参与者，下面我们来具体介绍下，W3C标准制作过程中所涉及的各个组，主要包括以下5个。 顾问委员会 顾问委员会（Advisory Committee，简称AC）由来自各个成员组织2的代表组成，每个组织一个代表（参见AC列表3）。 他们主要负责以下工作： 在每次的顾问委员会会议上审查W3C的计划; 审查W3C主任（W3C Director）给出的正式提案，包括章程提案、提案标准以及提案的流程文档。 推选董事会（Advisory Board）成员而非董事会主席 推选技术架构组的大多数参与者 董事会 董事会（Advisory Board，简称AB）创建于1998年3月，它会就战略、管理、法律事务、流程和冲突解决等问题向团队提供持续指导。也通过记录顾问委员会会议之间提出的问题，征求成员们对此类问题的意见以及提出解决这些问题的行动，为成员们提供服务。 与顾问委员会的主要不同在于董事会在W3C内没有决策权，它的作用是仅限于咨询。 技术架构组 技术架构组（Technical Architecture Group，简称TAG）创建于2001年2月，主要任务是管理Web架构，可以分为以下三个方面： 建立Web架构原则相关共识，并形成文档，在必要的时候对这些原则进行解释和阐明。 解决涉及TAG的通用Web架构问题; 帮助协调W3C内外部跨技术架构的开发。 工作组 工作组（Working Group）是某一Web技术的具体制定者，通常会产生一系列的可交付成果（例如标准跟踪技术报告、软件、测试套件以及其他组可交付成果的审查）。 兴趣组 兴趣小组的主要目标是将有意评估潜在Web技术和策略的人员聚集在一起，便于他们交流想法。 四、技术报告的成熟度等级说完标准化过程中所涉及的组，我们再来了解一下标准所经历的版本，用流程文档中的话说是技术报告的成熟度等级。技术报告即为上述提到的工作组所产生的标准或指南等，可以在技术报告页4查看已发布的技术报告。 W3C的技术报告的成熟度划分为如下6个等级。 工作草案（Working Draft，简称WD） 工作草案是W3C发布的文档，供W3C成员，公众和其他技术组织审查。大多数工作草案都旨在推进成为标准，如果不再想推进成标准，则应当发布为工作组笔记。 值得一提的是，工作组草案不一定代表整个工作组的共识，并且也不代表W3C已经认可，因为现阶段W3C或其成员仅是同意其在某个通用技术领域成立工作组。 候选标准（Candidate Recommendation，简称CR） 如果工作草案满足了对应工作组的技术要求或者没有再进行实质性的修改（#如何区分实质性的改动，见下文#），并且已经通过广泛的审查（工作草案中提到的审查，加粗部分），则可以发布成为候选标准。发布为候选标准则意味着： 告诉广大社区，是时候进行最后的审查了 收集实现方案 由顾问委员会开始正式审查，这时这一标准可能有三个结果：推荐为W3C标准、返回工作组继续完善或者废弃。 注：候选标准已经有望成为标准，这一阶段如果再有改动，需要给出改动的原因。 提案标准（Proposed Recommendation，简称PR） 提案标准表示该文档已经被W3C主任所接受并认为其质量足以成为正式的W3C标准。进入这一阶段后会给顾问委员会设定一个具体的审查截止日期。这一阶段不能再有实质性的改动了，如果有的话只能再发布一个新的工作草案和候选标准。 正式标准（W3C Recommendation，简称REC） W3C正式标准是一份规范、一套指南或要求，已达成广泛的共识，并且获得了W3C成员和主任的认可。W3C会推荐其作为Web标准进行实施。 虽然经过了重重的努力和审查才形成了每一份标准，但是人无完人，标准也可能会有一定的缺陷。随着科技的进步，正式的标准有可能会演变成以下4种： 修订标准：工作组可能会对标准进行编辑或者其他细微的改动，W3C会发布一个新的修订版本。 编辑标准：该标准添加了不包含新特性的实质性改动时，并且该标准已经不属于现有的活跃工作组，由W3C团队完成整个制作过程。 过时标准：当一个标准缺乏足够的市场相关性来推进其实施，但其本身没有本质的问题需要被废弃时，就会变成一个过时标准。如果过时标准重新获得了足够的市场相关性，W3C可以将其恢复到推荐状态。 被取代的标准：当一个标准被W3C推荐用一个更新后的版本取代时，该标准则变为被取代的标准。 废弃标准（Rescinded Recommendation） 废弃标准是W3C不再认可、同时认为其不太可能再恢复到标准状态的标准。 工作组/兴趣组笔记（Working Group Note/Interest Group Note，简称笔记） 工作组/兴趣组笔记主要是为了记录有用但不会成为标准的文档，或者是没能成为标准时所要放弃的工作。 此外，工作组和兴趣小组可能还会提供“编辑草案”。需要知道的是，编辑草案没有任何官方声明，没有在组内达成共识，也没有W3C的认可。这一版本会因为小组成员的讨论而持续变动。 如何区分实质性改动和编辑性改动？前面提到了实质性改以及与其对应的编辑性改动，那么如何区分一个改动究竟是哪种改动呢？ 标准的改动可以分为以下四类。其中前两类是编辑性改动，后两类是实质性改动。 无文字内容改动：包括修复损坏的链接、样式文件或无效标记。 不影响一致性的改动：实现者不会将其理解成架构、互操作性要求或者实现方案更改的改动。 可能影响一致性的改动 符合要求的数据、处理器或者其他代理在新版本中不再符合要求。 不符合要求的数据、处理器或者其他代理在新版本中符合要求。 清除了规范中含糊不清的或不明确的部分。 新特性：添加了一个新功能或者元素等。 五、完整的开发流程上面介绍完了标准化过程中所涉及的组、标准所经历的版本，相信大家从中已经能对标准的开发流程有一定的了解了。下面我们再图文并茂地完整地梳理一遍标准的开发流程。 一份技术报告推进成标准的过程，主要遵循下面这些步骤，可以结合下图查看： 发布初版工作草案 发布0个及以上的修订版工作草案 发布候选标准 发布提案标准 发布W3C标准 可能会发布的编辑标准和修订标准 上面提到正式的标准也会存在一定的变动，对已有标准进行编辑所遵循的过程可以参见下图黑色加粗部分。 从图中可以看出，如果改动不是实质性改动，则直接发布一个修订版本。如果是实质性改动，但没有增加新特性，则可以直接发布一个新的候选标准。如果是新的特性则需要从工作草案阶段进行整个开发流程。 总结至此介绍完了关于W3C标准的标准化流程，本文谨代表笔者对于万维网联盟流程文档的理解，加之流程文档也会不断地进行更新，所以如本文与流程文档有冲突，请以文档为主。 文内链接 https://www.w3.org/2018/Process-20180201/#tag-participation https://www.w3.org/Consortium/Member/List https://www.w3.org/Member/ACList https://www.w3.org/TR/ 参考链接 万维网联盟流程文档","categories":[],"tags":[]},{"title":"CSS性能优化的8个技巧","slug":"CSS性能优化的8个技巧","date":"2018-07-22T15:49:10.000Z","updated":"2018-08-13T10:50:43.241Z","comments":true,"path":"2018/07/22/CSS性能优化的8个技巧/","link":"","permalink":"http://verymuch.com/2018/07/22/CSS性能优化的8个技巧/","excerpt":"本文作者：高峰，360奇舞团前端工程师，W3C性能工作组成员，同时参与WOT工作组的学习。 我们都知道对于网站来说，性能至关重要，CSS作为页面渲染和内容展现的重要环节，影响着用户对整个网站的第一体验。因此，与其相关的性能优化是不容忽视的。 对于性能优化我们常常在项目完成时才去考虑，经常被推迟到项目的末期，甚至到暴露出严重的性能问题时才进行性能优化，相信大多数人对此深有体会。 笔者认为，为了更多地避免这一情况，首先要重视起性能优化相关的工作，将其贯穿到整个产品设计与开发中。其次，就是了解性能相关的内容，在项目开发过程中，自然而然地进行性能优化。最后，也是最最重要的，那就是从现在开始实施优化。 推荐大家阅读下奇舞周刊之前推的《嗨，送你一张Web性能优化地图》1这篇文章，能够帮助大家对性能优化需要做的事以及需要考虑的问题形成一个整体的概念。 本文将会详细介绍CSS性能优化相关的技巧，笔者将它们分为实践型和建议型两类，共8个小技巧。实践型技巧能够快速地应用在项目中，能够很好地提升性能，也是笔者经常使用的，建议大家尽快在项目中实践。建议型技巧中，有的可能对性能影响并不显著，有的平时大家也并不会那么用，所以笔者不会着重讲述，读者们可以根据自身情况了解一下即可。","text":"本文作者：高峰，360奇舞团前端工程师，W3C性能工作组成员，同时参与WOT工作组的学习。 我们都知道对于网站来说，性能至关重要，CSS作为页面渲染和内容展现的重要环节，影响着用户对整个网站的第一体验。因此，与其相关的性能优化是不容忽视的。 对于性能优化我们常常在项目完成时才去考虑，经常被推迟到项目的末期，甚至到暴露出严重的性能问题时才进行性能优化，相信大多数人对此深有体会。 笔者认为，为了更多地避免这一情况，首先要重视起性能优化相关的工作，将其贯穿到整个产品设计与开发中。其次，就是了解性能相关的内容，在项目开发过程中，自然而然地进行性能优化。最后，也是最最重要的，那就是从现在开始实施优化。 推荐大家阅读下奇舞周刊之前推的《嗨，送你一张Web性能优化地图》1这篇文章，能够帮助大家对性能优化需要做的事以及需要考虑的问题形成一个整体的概念。 本文将会详细介绍CSS性能优化相关的技巧，笔者将它们分为实践型和建议型两类，共8个小技巧。实践型技巧能够快速地应用在项目中，能够很好地提升性能，也是笔者经常使用的，建议大家尽快在项目中实践。建议型技巧中，有的可能对性能影响并不显著，有的平时大家也并不会那么用，所以笔者不会着重讲述，读者们可以根据自身情况了解一下即可。 在正式开始之前，需要大家对于浏览器的工作原理2有些一定的了解，需要的小伙伴可以先简单了解下。 下面我们开始介绍实践型的4个优化技巧，先从首屏关键CSS开始。 1. 内联首屏关键CSS（Critical CSS）性能优化中有一个重要的指标——首次有效绘制（First Meaningful Paint，简称FMP）即指页面的首要内容（primary content）出现在屏幕上的时间。这一指标影响用户看到页面前所需等待的时间，而内联首屏关键CSS（即Critical CSS，可以称之为首屏关键CSS）能减少这一时间。 大家应该都习惯于通过link标签引用外部CSS文件。但需要知道的是，将CSS直接内联到HTML文档中能使CSS更快速地下载。而使用外部CSS文件时，需要在HTML文档下载完成后才知道所要引用的CSS文件，然后才下载它们。所以说，内联CSS能够使浏览器开始页面渲染的时间提前，因为在HTML下载完成之后就能渲染了。 既然内联CSS能够使页面渲染的开始时间提前，那么是否可以内联所有的CSS呢？答案显然是否定的，这种方式并不适用于内联较大的CSS文件。因为初始拥塞窗口3存在限制（TCP相关概念，通常是 14.6kB，压缩后大小），如果内联CSS后的文件超出了这一限制，系统就需要在服务器和浏览器之间进行更多次的往返，这样并不能提前页面渲染时间。因此，我们应当只将渲染首屏内容所需的关键CSS内联到HTML中。 既然已经知道内联首屏关键CSS能够优化性能了，那下一步就是如何确定首屏关键CSS了。显然，我们不需要手动确定哪些内容是首屏关键CSS。Github上有一个项目Critical CSS4，可以将属于首屏的关键样式提取出来，大家可以看一下该项目，结合自己的构建工具进行使用。当然为了保证正确，大家最好再亲自确认下提取出的内容是否有缺失。 不过内联CSS有一个缺点，内联之后的CSS不会进行缓存，每次都会重新下载。不过如上所说，如果我们将内联后的文件大小控制在了14.6kb以内，这似乎并不是什么大问题。 如上，我们已经介绍了为什么要内联关键CSS以及如何内联，那么剩下的CSS我们怎么处理好呢？建议使用外部CSS引入剩余CSS，这样能够启用缓存，除此之外还可以异步加载它们。 2. 异步加载CSSCSS会阻塞渲染，在CSS文件请求、下载、解析完成之前，浏览器将不会渲染任何已处理的内容。有时，这种阻塞是必须的，因为我们并不希望在所需的CSS加载之前，浏览器就开始渲染页面。那么将首屏关键CSS内联后，剩余的CSS内容的阻塞渲染就不是必需的了，可以使用外部CSS，并且异步加载。 那么如何实现CSS的异步加载呢？有以下四种方式可以实现浏览器异步加载CSS。 第一种方式是使用JavaScript动态创建样式表link元素，并插入到DOM中。 123456// 创建link标签const myCSS = document.createElement( \"link\" );myCSS.rel = \"stylesheet\";myCSS.href = \"mystyles.css\";// 插入到header的最后位置document.head.insertBefore( myCSS, document.head.childNodes[ document.head.childNodes.length - 1 ].nextSibling ); 第二种方式是将link元素的media属性设置为用户浏览器不匹配的媒体类型（或媒体查询），如media=&quot;print&quot;，甚至可以是完全不存在的类型media=&quot;noexist&quot;。对浏览器来说，如果样式表不适用于当前媒体类型，其优先级会被放低，会在不阻塞页面渲染的情况下再进行下载。 当然，这么做\b只是为了实现CSS的异步加载，\b别忘了在文件加载完成之后，将media的值设为screen或all，从而让浏览器开始解析CSS。 1&lt;link rel=\"stylesheet\" href=\"mystyles.css\" media=\"noexist\" onload=\"this.media='all'\"&gt; 与第二种方式相似，我们还可以通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将rel改回去。 1&lt;link rel=\"alternate stylesheet\" href=\"mystyles.css\" onload=\"this.rel='stylesheet'\"&gt; 上述的三种方法都较为古老。现在，rel=”preload”5这一Web标准指出了如何异步加载资源，包括CSS类资源。 1&lt;link rel=\"preload\" href=\"mystyles.css\" as=\"style\" onload=\"this.rel='stylesheet'\"&gt; 注意，as是必须的。忽略as属性，或者错误的as属性会使preload等同于XHR请求，浏览器不知道加载的是什么内容，因此此类资源加载优先级会非常低。as的可选值可以参考上述标准文档。 看起来，rel=&quot;preload&quot;\u001d的用法和上面两种没什么区别，都是通过更改某些属性，使得浏览器异步加载CSS文件但不解析，直到加载完成并将修改还原，然后开始解析。 但是它们之间其实有一个很重要的不同点，那就是使用preload，比使用不匹配的media方法能够更早地开始加载CSS。所以尽管这一标准的支持度还不完善，仍建议优先使用该方法。 该标准现在已经是候选标准，相信浏览器会逐渐支持该标准。\b在各浏览器的支持度如下图所示。 从上图可以看出这一方法\b在现在的浏览器中支持度不算乐观，不过我们可以通过loadCSS6进行polyfill，所以支持不支持，这都不是事儿。 3. 文件压缩性能优化时有一个最容易想到，也最常使用的方法，那就是文件压缩，这一方案往往效果显著。 文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现地尤为明显。相信大家都早已习惯对CSS进行压缩，现在的构建工具，如webpack、gulp/grunt、rollup等也都支持CSS压缩功能。压缩后的文件能够明显减小，可以大大降低了浏览器的加载时间。 4. 去除无用CSS虽然文件压缩能够降低文件大小。但CSS文件压缩通常只会去除无用的空格，这样就限制了CSS文件的压缩比例。那是否还有其他手段来精简CSS呢？答案显然是肯定的，如果压缩后的文件仍然超出了预期的大小，我们可以试着找到并删除代码中无用的CSS。 一般情况下，会存在这两种无用的CSS代码：一种是不同元素或者其他情况下的重复代码，一种是整个页面内没有生效的CSS代码。对于前者，在编写的代码时候，我们应该尽可能地提取公共类，减少重复。对于后者，在不同开发者进行代码维护的过程中，总会产生不再使用的CSS的代码，当然一个人编写时也有可能出现这一问题。而这些无用的CSS代码不仅会增加浏览器的下载量，还会增加浏览器的解析时间，这对性能来说是很大的消耗。所以我们需要找到并去除这些无用代码。 当然，如果手动删除这些无用CSS是很低效的。我们可以借助Uncss7库来进行。Uncss可以用来移除样式表中的无用CSS，并且支持多文件和JavaScript注入的CSS。 前面已经说完了实践型的4个优化技巧，下面我们介绍下建议型的4个技巧。 1. 有选择地使用选择器大多数朋友应该都知道CSS选择器的匹配是从右向左进行的，这一策略导致了不同种类的选择器之间的性能也存在差异。相比于#markdown-content-h3，显然使用#markdown .content h3时，浏览器生成渲染树（render-tree）所要花费的时间更多。因为后者需要先找到DOM中的所有h3元素，再过滤掉祖先元素不是.content的，最后过滤掉.content的祖先不是#markdown的。试想，如果嵌套的层级更多，页面中的元素更多，那么匹配所要花费的时间代价自然更高。 不过现代浏览器在这一方面做了很多优化，不同选择器的性能差别并不明显，甚至可以说差别甚微。此外不同选择器在不同浏览器中的性能表现8也不完全统一，在编写CSS的时候无法兼顾每种浏览器。鉴于这两点原因，我们在使用选择器时，只需要记住以下几点，其他的可以全凭喜好。 保持简单，不要使用嵌套过多过于复杂的选择器。 通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。 不要使用类选择器和ID选择器修饰元素标签，如h3#markdown-content，这样多此一举，还会降低效率。 不要为了追求速度而放弃可读性与可维护性。 如果大家对于上面这几点还存在疑问，笔者建议大家选择以下几种CSS方法论之一（BEM9，OOCSS10，SUIT11，SMACSS12，ITCSS13，Enduring CSS14等）作为CSS编写规范。使用统一的方法论能够帮助大家形成统一的风格，减少命名冲突，也能避免上述的问题，总之好处多多，如果你还没有使用，就赶快用起来吧。 Tips：为什么CSS选择器是从右向左匹配的？CSS中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器不匹配时提升效率。从右向左匹配就是为了达成这一目的的，通过这一策略能够使得CSS选择器在不匹配的时候效率更高。这样想来，在匹配时多耗费一些性能也能够想的通了。 2. 减少使用昂贵的属性在浏览器绘制屏幕时，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价。当页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写CSS时，我们应该尽量减少使用昂贵属性，如box-shadow/border-radius/filter/透明度/:nth-child等。 当然，并不是让大家不要使用这些属性，因为这些应该都是我们经常使用的属性。之所以提这一点，是让大家对此有一个了解。当有两种方案可以选择的时候，可以优先选择没有昂贵属性或昂贵属性更少的方案，如果每次都这样的选择，网站的性能会在不知不觉中得到一定的提升。 3. 优化重排与重绘在网站的使用过程中，某些操作会导致样式的改变，这时浏览器需要检测这些改变并重新渲染，其中有些操作所耗费的性能更多。我们都知道，当FPS为60时，用户使用网站时才会感到流畅。这也就是说，我们需要在16.67ms内完成每次渲染相关的所有操作，所以我们要尽量减少耗费更多的操作。 3.1 减少重排重排会导致浏览器重新计算整个文档，重新构建渲染树，这一过程会降低浏览器的渲染速度。如下所示，有很多操作会触发重排，我们应该避免频繁触发这些操作。 改变font-size和font-family 改变元素的内外边距 通过JS改变CSS类 通过JS获取DOM元素的位置相关属性（如width/height/left等） CSS伪类激活 滚动滚动条或者改变窗口大小 此外，我们还可以通过CSS Trigger15查询哪些属性会触发重排与重绘。 值得一提的是，某些CSS属性具有更好的重排性能。如使用Flex时，比使用inline-block和float时重排更快，所以在布局时可以优先考虑Flex。 3.2 避免不必要的重绘当元素的外观（如color，background，visibility等属性）发生改变时，会触发重绘。在网站的使用过程中，重绘是无法避免的。不过，浏览器对此做了优化，它会将多次的重排、重绘操作合并为一次执行。不过我们仍需要避免不必要的重绘，如页面滚动时触发的hover事件，可以在滚动的时候禁用hover事件，这样页面在滚动时会更加流畅。 此外，我们编写的CSS中动画相关的代码越来越多，我们已经习惯于使用动画来提升用户体验。我们在编写动画时，也应当参考上述内容，减少重绘重排的触发。除此之外我们还可以通过硬件加速16和will-change17来提升动画性能，本文不对此展开详细介绍，感兴趣的小伙伴可以点击链接进行查看。 最后需要注意的是，用户的设备可能并没有想象中的那么好，至少不会有我们的开发机器那么好。我们可以借助Chrome的开发者工具进行CPU降速，然后再进行相关的测试，降速方法如下图所示。 如果需要在移动端访问的，最好将速度限制更低，因为移动端的性能往往更差。 4. 不要使用@import最后提一下，不要使用@import引入CSS，相信大家也很少使用。 不建议使用@import主要有以下两点原因。 首先，使用@import引入CSS会影响浏览器的并行下载。使用@import引用的CSS文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。这就导致浏览器无法并行下载所需的样式文件。 其次，多个@import会导致下载顺序紊乱。在IE中，@import会引发资源文件的下载顺序被打乱，即排列在@import后面的js文件先于@import下载，并且打乱甚至破坏@import自身的并行下载。 所以不要使用这一方法，使用link标签就行了。 总结至此，我们介绍完了CSS性能优化的4个实践型技巧和4个建议型技巧，在了解这些技巧之后，CSS的性能优化从现在就可以开始了。不要犹豫了，尽快开始吧。 致谢特别感谢@anjia(安佳)、@刘宇晨、@hxl(黄小璐)、@刘观宇的辛苦审校，感谢你们对于文章结构和内容提出的宝贵建议。 文内链接 https://mp.weixin.qq.com/s/C2Zx3KPNPkgj-aHnOY43Iw https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/ https://tylercipriani.com/blog/2016/09/25/the-14kb-in-the-tcp-initial-window/ https://github.com/filamentgroup/criticalCSS https://www.w3.org/TR/preload/ https://github.com/filamentgroup/loadCSS/tree/v2.0.1#loadcss https://github.com/uncss/uncss https://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/#h-H1_1 https://en.bem.info/methodology/quick-start/ http://oocss.org/ https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md https://smacss.com/ https://www.xfive.co/blog/itcss-scalable-maintainable-css-architecture/ http://ecss.io/ https://csstriggers.com/ https://www.sitepoint.com/introduction-to-hardware-acceleration-css-animations/ https://drafts.csswg.org/css-will-change/ 参考文章 Efficiently Rendering CSS How to write CSS for a great performance web application CSS performance revisited: selectors, bloat and expensive styles Avoiding Unnecessary Paints Five CSS Performance Tools to Speed up Your Website How and Why You Should Inline Your Critical CSS Render blocking css Modern Asynchronous CSS Loading Preload","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://verymuch.com/tags/CSS/"}]},{"title":"如何清除行内元素之间的HTML空白","slug":"如何清除行内元素之间的HTML空白","date":"2018-05-23T10:00:48.000Z","updated":"2018-11-12T00:36:45.214Z","comments":true,"path":"2018/05/23/如何清除行内元素之间的HTML空白/","link":"","permalink":"http://verymuch.com/2018/05/23/如何清除行内元素之间的HTML空白/","excerpt":".Resolve { width: 90%; border: 1px solid #dd4b39; color: white; } .Resolve span { display:inline-block; width: 50%; } .Resolve span:first-child { height: 40px; background: #37b8ea; } .Resolve span:last-child { height: 30px; background: #5cb767; } /* 解决方案2 */ .Resolve2 { font-size: 0; } .Resolve2 span { font-size: 14px; } /* 解决方案3 */ .Resolve3 span:last-child { margin-left: -0.333333em; } /* 解决方案4 */ .Resolve4 { letter-spacing: -0.333333em; } .Resolve4 span { letter-spacing: 0; } 前言相信大家应该都遇到过下面这个问题：“HTML源码中行内元素之间的空白显示在了屏幕上”。可能大家都有自己的小技巧来消除这些意料之外的空白。但是方法有很多，有时候不能满足于一种方法，不同的方法适合于不同的场景。就像我之前一直用的方法，今天总结了之后才发现还有更好的方法。废话不多说，接下来我给大家总结一下消除行内元素HTML源码空白的小技巧。 下文中以一个div中的两个span标签为例。我们将两个div内的两个span设为display:inline-block;width:50%;，会发现两个span元素并没有在同一行，这就是源码中的空白导致的。 示例图与代码如下： 左侧行内元素 右侧行内元素","text":".Resolve { width: 90%; border: 1px solid #dd4b39; color: white; } .Resolve span { display:inline-block; width: 50%; } .Resolve span:first-child { height: 40px; background: #37b8ea; } .Resolve span:last-child { height: 30px; background: #5cb767; } /* 解决方案2 */ .Resolve2 { font-size: 0; } .Resolve2 span { font-size: 14px; } /* 解决方案3 */ .Resolve3 span:last-child { margin-left: -0.333333em; } /* 解决方案4 */ .Resolve4 { letter-spacing: -0.333333em; } .Resolve4 span { letter-spacing: 0; } 前言相信大家应该都遇到过下面这个问题：“HTML源码中行内元素之间的空白显示在了屏幕上”。可能大家都有自己的小技巧来消除这些意料之外的空白。但是方法有很多，有时候不能满足于一种方法，不同的方法适合于不同的场景。就像我之前一直用的方法，今天总结了之后才发现还有更好的方法。废话不多说，接下来我给大家总结一下消除行内元素HTML源码空白的小技巧。 下文中以一个div中的两个span标签为例。我们将两个div内的两个span设为display:inline-block;width:50%;，会发现两个span元素并没有在同一行，这就是源码中的空白导致的。 示例图与代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 1234567891011121314151617.Resolve &#123; width: 90%; border: 1px solid #dd4b39; color: white;&#125;.Resolve span &#123; display:inline-block; width: 50%;&#125;.Resolve span:first-child &#123; height: 40px; background: #37b8ea;&#125;.Resolve span:last-child &#123; height: 30px; background: #5cb767;&#125; 解决方案1：源码中直接就写成一行相信大家看到这个解决方案的时候，会想这不是废话嘛。有时候我们就是为了代码的美观，才将两个span标签分两行显示的，写在一行根本就没解决问题好不好？ 不过，我觉得这并不是废话，之所以将其列为一种解决方案，是防止有的人不知道是什么原因导致的空白的显示。知道了这个原因，如果两个行内元素的横向宽度(此处指代码宽度)不大，写在一行也算是最快最直接的解决方法。 示例图与代码如下： 左侧行内元素右侧行内元素 HTML： 123&lt;div class=\"Resolve Resolve1\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt;&lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; 解决方案2：font-size: 0; （笔者一直使用的方法）问题中span标签之间的空白是因为换行符/Tab制表符/空格等产生的间隔，并且据笔者测试，得出这个距离是字体大小的1/3倍（请先记住这个值）。那么既然空格和字体大小font-size相关。那么也可以通过字体大小来消除这个空隙。 在父级元素上设置font-size: 0;，然后再在内部的span设置需要的字体大小即可。 示例图与代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve2\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 123456.Resolve2 &#123; font-size: 0;&#125;.Resolve2 span &#123; font-size: 14px;&#125; 这种情况在内部的行内元素字体大小比较统一时，处理起来较为方便，但如果包含的行内元素中存在多种字体大小，需要一一指定，较为繁琐。不过往往这种时候内部的多种字体大小也是单独指定。可以根据具体场景决定是否使用该方案。 解决方案3：margin-left设为负值如果行内元素为块级行内元素，则可以使用margin属性来抵消空白。在【解决方案2】中有提到行内元素之间的距离是字体大小的1/3倍。所以我们只需要将第二个span元素的margin-left设置为-0.333333em即可。 示例图与代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve3\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 123.Resolve3 span:last-child &#123; margin-left: -0.333333em;&#125; 不过从上面可以看出，最右边还会存在一点点的白边误差。这是由于margin-left的计算精度导致的。所以为避免效果误差，不建议使用该方法。 解决方案4：letter-spacing消除文字间距离同方案2、方案3，我们还可以通过letter-spacing改变行内元素之间空隙的大小，将letter-spacing设为-0.333333em即可。但是与font-size一样，改变letter-spacing时会改变内部子元素的间隙，需要在子元素内手动进行矫正。 示例图与代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve4\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 123456.Resolve4 &#123; letter-spacing: -0.333333em;&#125;.Resolve4 span &#123; letter-spacing: 0;&#125; 解决方案5：HTML注释（推荐使用）除了调整css样式之外，我们可以使用html注释来抵消空格，这种情况下不用额外进行css处理。此外笔者觉得还有一个好处，可以加上文字注释，告知为什么会加入注释。 推荐使用该方式，能够有效保持代码整齐，并且不用额外添加css样式。 示例图与代码如下： 左侧行内元素右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve5\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt;&lt;!-- 消除行内元素换行导致的空白--&gt;&lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; 总结以上就是消除行内元素间HTML空白的5种方案，虽然这些方案都不是很理想，但是有时候在特定的情况下，我们往往需要其中之一作为解决方案。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://verymuch.com/tags/CSS/"}]},{"title":"跳出forEach","slug":"跳出forEach","date":"2018-02-09T01:39:23.000Z","updated":"2018-12-10T03:43:01.737Z","comments":true,"path":"2018/02/09/跳出forEach/","link":"","permalink":"http://verymuch.com/2018/02/09/跳出forEach/","excerpt":"使用for...in遍历对象时，会遍历原型链上的可枚举属性，这可能会导致一些意想不到的问题。所以你一定收到过这样的建议，使用数组的forEach来代替for...in循环。","text":"使用for...in遍历对象时，会遍历原型链上的可枚举属性，这可能会导致一些意想不到的问题。所以你一定收到过这样的建议，使用数组的forEach来代替for...in循环。 一、常规试错在使用for...in的时候，在适当的时机终止循环是很常用的功能。那么问题来了，当我们有此需求时，我们可能会像下面这么做。 或许我们会尝试如下代码： 1234[1, 2, 3, 4, 5].forEach(function(v) &#123; console.log(v); //期望只输出1,2 if (v === 2) return false;&#125;); 但是，运行之后你会发现，其实return false并没有起作用。 然后又尝试了下面这个方法： 1234[1, 2, 3, 4, 5].forEach(function(v) &#123; console.log(v); //期望只输出1,2 if (v === 2) break;&#125;); 发现仍然不行，并且得到了如下的错误提示： 1Uncaught SyntaxError: Illegal break statement at Array.forEach (&lt;anonymous&gt;) 其实，\bMDN上有说明： There is no way to stop or break a forEach() loop other than by throwing an exception. If you need such behavior, the forEach() method is the wrong tool. 在forEach()方法中除了抛出异常以外，无法终止或者跳出循环。如果你需要该操作，那说明你用错了方法。 好吧，看来在forEach中确实不能终止或者跳出循环，那么为什么呢？ 二、为什么不行？首先我们先想一下第一种方法为啥不行。 其实forEach类似等价于如下的方法： 1234567const arr = [1, 2, 3, 4, 5];for (let i = 0; i &lt; arr.length; i++) &#123; const ret = (function(element) &#123; console.log(element); if (element === 2) return false; &#125;)(arr[i])&#125; 这样就很好理解了，我们在内部使用的return只是相当于将结果输出到ret变量中，并不能跳出循环。 至于第二种方法的报错，是因为break不允许出现在函数体内。 现在我们也知道了为啥在forEach不能跳出或者终止了。那么在遇到开始所说的使用场景时，有没有方法能跳出forEach呢？ 当然是有的，下面给大家总结了5个变通之法。 三、跳出forEach的5个变通之法1. 重回for…in上面提到我们是因为某些原因才推荐使用forEach来代替for...in的。但是如果有break的需求，而你又不知道其他方法时，可以重拾for...in。 2. throw法前面提到了，在forEach()方法中除了抛出异常以外，无法终止或者跳出循环。那么就看看如何使用\bthrow来跳出循环。 12345678910var BreakErr = &#123;&#125;;try &#123; [1, 2, 3, 4, 5].forEach(function(v) &#123; console.log(v); //只输出1,2 if (v === 2) throw BreakErr; &#125;);&#125; catch (e) &#123; if (e !== BreakErr) throw e;&#125; 这样其实也挺好的，如果循环遍历中的操作比较复杂，可以通过try...catch捕获\b异常。这样的话，跳出循环的错误就需要特别区开，避免不会干扰代码抛出的其他错误。 3. 空跑循环第3种方法是空跑循环。 在外层加一个标识，在特定\b情况下改变此标识的值，然后通过if语句判断，空跑后续的循环，如下： 12345678910111213var breakFlag = false;[1, 2, 3, 4, 5].forEach(function(v) &#123; if (breakFlag === true) &#123; return false; &#125; if (v === 2) &#123; breakFlag = true &#125; console.log(v) //只输出1,2&#125;) 这个方法比较简单也比较容易想到，但是该方法在外层加了一个变量，这样会污染外层的环境。所以我们\b可以使用forEach的第二个参数context来替代外层变量，把标识放在context里，这样就避免污染外层环境了。 12345678910[1, 2, 3, 4, 5].forEach(function(v) &#123; if (this.breakFlag === true) &#123; return false; &#125; if (v === 2) &#123; this.breakFlag = true &#125; console.log(v) //只输出1,2&#125;, &#123;&#125;); // 这里指定context 需要注意的是，forEach的第二个参数context，只有在使用非箭头函数时有效，因为箭头函数，无法改变context的指向。如果不注意的话，会污染了父级上下文。 1234567891011[1, 2, 3, 4, 5].forEach((v) =&gt; &#123; if (this.breakFlag === true) &#123; return false; &#125; if (v === 2) &#123; console.log(this) // 运行会发现，结果并不是&#123;test: 'test'&#125; this.breakFlag = true &#125; console.log(v) //只输出1,2&#125;, &#123;test: 'test'&#125;); 当然，上述这种方法\b会有一些不必要的运行，\b因为会空跑整个循环，显得不太优雅。 4. 神奇改数组大法下面出场的这位选手，稍微有点技术含量，笔者还是问了大佬才知道的，一定是我太过愚钝了。 所以你可以先别急着往下看解释，先看看你能理解不。 1234567var array = [1, 2, 3, 4, 5];array.forEach(function(item, index) &#123; if (item === 2) &#123; array = array.concat(array.splice(index, array.length - index)); &#125; console.log(item); //只输出1,2&#125;); 其实，这种方法相当于在item === 2的时候，改变了原数组引用的值，因为原数组改变了，则forEach进行到第二项就没了，但是该方法又机智地用concat后的新数组赋值给了array，所以array的值看上去并没有变，不信你可以试一下。 5. 最应该使用的every/some在需要break的场景下，我们可以使用every或者some，也比较推荐这种方式。 every和some的用法如下，它们会根据返回值来判断是否继续迭代，能够完美满足我们的需求。every在碰到return false的时候，中止循环。some在碰到return ture的时候，中止循环。 两者的代码分别如下： 123456789var a = [1, 2, 3, 4, 5]a.every(function(item, index, arry) &#123; console.log(item); //输出：1,2 if (item === 2) &#123; return false &#125; else &#123; return true &#125;&#125;) 123456789var a = [1, 2, 3, 4, 5]a.some(function(item, index, arry) &#123; console.log(item); //输出：1,2 if (item === 2) &#123; return true &#125; else &#123; return false &#125;&#125;) 总结本文给大家总结了5种在forEach中跳出循环的变通之法，其实这些方法在网上都能很容易地找到，笔者只是把在遇到该问题时的想法和解决方案进行了一下总结。希望能够对大家有帮助。 参考内容 https://medium.com/@tiboprea/3-things-you-didnt-know-about-the-foreach-loop-in-js-ff02cec465b1 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach http://jser.me/2014/04/02/%E5%A6%82%E4%BD%95%E5%9C%A8Array.forEach%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%87%8Cbreak.html","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://verymuch.com/tags/Javascript/"}]},{"title":"Node路径解析浅析","slug":"Node路径解析浅析","date":"2018-01-10T09:08:05.000Z","updated":"2019-05-29T07:08:30.202Z","comments":true,"path":"2018/01/10/Node路径解析浅析/","link":"","permalink":"http://verymuch.com/2018/01/10/Node路径解析浅析/","excerpt":"1. 疑惑这两天看了下之前项目里的webpack配置，想将之前的alias命名统一起来，遂在alias命名前统一使用_开头，这样在项目中看到这样的引用一眼就能知道是通过别名查找的。如下图所示，css目录在fesrc目录下，webpack配置所在目录与fesrc平级，在配置中如果使用相对路径，应该使用_css: path.resolve(&#39;../fesrc/css&#39;)，但是试一下就会发现这么做webpack无法找到指定目录。相反如下图用法，使用_css: path.resolve(&#39;./fesrc/css&#39;)则能够找到。因此，我猜想可能是相对于运行该文件的目录，就了解并总结了一下相关的内容。","text":"1. 疑惑这两天看了下之前项目里的webpack配置，想将之前的alias命名统一起来，遂在alias命名前统一使用_开头，这样在项目中看到这样的引用一眼就能知道是通过别名查找的。如下图所示，css目录在fesrc目录下，webpack配置所在目录与fesrc平级，在配置中如果使用相对路径，应该使用_css: path.resolve(&#39;../fesrc/css&#39;)，但是试一下就会发现这么做webpack无法找到指定目录。相反如下图用法，使用_css: path.resolve(&#39;./fesrc/css&#39;)则能够找到。因此，我猜想可能是相对于运行该文件的目录，就了解并总结了一下相关的内容。 2. 五类路径__dirname、__filename、process.cwd()、./、../Node中的文件路径大概有__dirname、__filename、process.cwd()、./或者../五类，前三个都是绝对路径，为了便于比较，我们将通过path.resolve(&#39;./&#39;)将./和../转换为绝对路径。 先看一个简单的例子。 假设有以下文件结构： 12345test-path├── js│ └── test.js└── lib └── common.js 在test.js下编写一下代码： 123456var path = require('path');console.log(__dirname);console.log(__filename);console.log(process.cwd());console.log(path.resolve('./')); 在js目录下运行node test.js会输出以下内容： 1234/Users/verymuch/devspace/test-path/js/Users/verymuch/devspace/test-path/js/test.js/Users/verymuch/devspace/test-path/js/Users/verymuch/devspace/test-path/js 而在test-path目录下，执行node js/test.js会输出以下内容： 1234/Users/verymuch/devspace/test-path/js/Users/verymuch/devspace/test-path/js/test.js/Users/verymuch/devspace/test-path/Users/verymuch/devspace/test-path 由上述内容，我们可以先做出以下假设： __dirname: 总是返回被执行的js所在文件夹的绝对路径 __filename: 总是返回被执行的js的绝对路径 process.cwd(): 总是返回运行node命令时所在的文件夹的绝对路径 ./: 似乎与process.cwd()一样。 值得注意的是，在require(&#39;../lib/common&#39;)里使用相对路径似乎并没有问题，参考下例，将’js/test.js’ 里的代码改成： 123456789var fs = require('fs');var common = require('../lib/common');console.log('require is OK!');fs.readFile('../lib/common.js', function (err, data) &#123; if (err) return console.log(err); console.log(data.toString());&#125;); 在js目录下运行node test.js，会发现并没有问题。但是在test-path目录下运行node js/test.js，就会报错，运行结果如下： 123456require is OK!&#123; Error: ENOENT: no such file or directory, open '../lib/common.js' errno: -2, code: 'ENOENT', syscall: 'open', path: '../lib/common.js' &#125; 按照上面暂定的理论，在test-path下运行时，../lib/common.js会被转成/Users/verymuch/devspace/lib/common.js，显然，这个路径是不存在的，但是从运行结果可以看出require(&#39;../lib/common&#39;)并没有问题，只是readFile报错了。 因此关于./正确的结论是： 在require()中使用是跟__dirname的效果相同，相对于文件所在目录，不会因为启动脚本的目录不一样而改变 在其他情况下跟process.cwd()效果相同，相对于启动脚本所在目录。 3. 总结鉴于相对路径(./, ../)的特殊，建议只在require()中使用相对路径的写法，其他地方一律使用绝对路径，如下： 1234// 当前目录下path.resolve(__dirname, './lib/common.js');// 相邻目录下path.resolve(__dirname, '../lib/common.js'); 4. 参考链接 浅析 NodeJs 的几种文件路径","categories":[],"tags":[{"name":"沉淀","slug":"沉淀","permalink":"http://verymuch.com/tags/沉淀/"}]},{"title":"Data URL简介与使用","slug":"Data-URL简介与使用","date":"2017-12-14T00:34:41.000Z","updated":"2019-05-29T07:23:50.531Z","comments":true,"path":"2017/12/14/Data-URL简介与使用/","link":"","permalink":"http://verymuch.com/2017/12/14/Data-URL简介与使用/","excerpt":"相信大家在前端开发的过程中，都应该处理过图片，其中有一项就是我们会在loader中将小的图片转为base64。那么这个base64是什么呢？我们为什么要将其转为base64呢？ 其实这是格式的图片，我们可以称为Data URL，下面让我们一起来简单了解下。 1. 简介Data URL，是以data:模式为前缀的URL，允许内容的创建者将较小的文件嵌入到文档中。与常规的URL使用场合类似，下面会具体介绍可以将Data URL用在哪些地方。 Data URL由data:前缀、MIME类型（表明数据类型）、base64标志位（如果是文本，则可选）以及数据本身四部分组成。 语法格式如下： 1data:[&lt;mediatype&gt;][;base64],data mediatype是一个MIME（Multipurpose Internet Mail Extension）类型字符串，如image/jpeg表示一个JPEG图片文件。如果省略，默认值为text/plain;charset=US-ASCII。","text":"相信大家在前端开发的过程中，都应该处理过图片，其中有一项就是我们会在loader中将小的图片转为base64。那么这个base64是什么呢？我们为什么要将其转为base64呢？ 其实这是格式的图片，我们可以称为Data URL，下面让我们一起来简单了解下。 1. 简介Data URL，是以data:模式为前缀的URL，允许内容的创建者将较小的文件嵌入到文档中。与常规的URL使用场合类似，下面会具体介绍可以将Data URL用在哪些地方。 Data URL由data:前缀、MIME类型（表明数据类型）、base64标志位（如果是文本，则可选）以及数据本身四部分组成。 语法格式如下： 1data:[&lt;mediatype&gt;][;base64],data mediatype是一个MIME（Multipurpose Internet Mail Extension）类型字符串，如image/jpeg表示一个JPEG图片文件。如果省略，默认值为text/plain;charset=US-ASCII。 2. Data URL的优缺点 Data URL的优势 和传统的外部资源引用，Data URL有着以下优势： 当访问外部资源很麻烦或受限时，可以将外部资源转为Data URL引用(这个比较鸡肋) 当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时，这是需要返回一个可用的URL（场景较少） 当图片的体积太小，占用一个HTTP会话不是很值得时（雪碧图可以出场了） Data URL的缺点 虽然Data URL允许使用者将文件嵌入到文档中，这在某些场景下较为合适，但是Data URL也有一些缺点： 体积更大：Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3 不会缓存：Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样的页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。 3. 如何获取base64编码 Linux/Mac OS X下可以使用uuencode命令 1uuencode -m &lt;源文件&gt; &lt;转码后标识&gt; 如执行uuencode -m hello-base64 hello，会得到如下结果： 123begin-base64 644 helloaGVsbG8gYmFzZTY0 // 此处为base64编码，对应文本内容为 'hello base64'==== 使用原生Web API编码/解码 Javascript中有两个函数负责编码和解码base64字符串，分别是atob和btoa。 atob(): 负责解码已经使用base64编码了的字符串。 btoa(): 将二进制字符串转为base64编码的ASCII字符串。 两者都只针对Data URL中的data进行处理。 12btoa('hello base64') // \"aGVsbG8gYmFzZTY0\"atob('aGVsbG8gYmFzZTY0') // \"hello base64\" Canvas的toDataURL方法 Canvas提供了toDataURL方法，用于获取canvas绘制内容，将其转为base64格式。 如下所示，文本框中的内容即为canvas中绘制内容的base64格式。 var canvas = document.getElementById('testCanvas'); if (canvas.getContext) { var ctx = canvas.getContext('2d'); // 设置字体 ctx.font = \"Bold 20px Arial\"; // 设置对齐方式 ctx.textAlign = \"left\"; // 设置填充颜色 ctx.fillStyle = \"#0f0\"; // 设置字体内容，以及在画布上的位置 ctx.fillText(\"hello base64\", 10, 30); // 描边颜色 ctx.strokeStyle = \"#0f0\"; // 绘制空心字 ctx.strokeText(\"hello base64\", 10, 80); // 获取 Data URL document.getElementById('testCanvas-content').value = canvas.toDataURL(); } Html: 12&lt;canvas id=\"testCanvas\" width=\"200\" height=\"100\"&gt;&lt;/canvas&gt;&lt;textarea id=\"testCanvas-content\"&gt;&lt;/textarea&gt; JS: 123456789101112131415161718var canvas = document.getElementById('testCanvas');if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); // 设置字体 ctx.font = \"Bold 20px Arial\"; // 设置对齐方式 ctx.textAlign = \"left\"; // 设置填充颜色 ctx.fillStyle = \"#0f0\"; // 设置字体内容，以及在画布上的位置 ctx.fillText(\"hello base64\", 10, 30); // 描边颜色 ctx.strokeStyle = \"#0f0\"; // 绘制空心字 ctx.strokeText(\"hello base64\", 10, 80); // 获取 Data URL document.getElementById('testCanvas-content').value = canvas.toDataURL();&#125; 使用FileReader API的readAsDataURL方法 FileReader API提供的readAsDataURL方法能够返回一个基于base64编码的Data URL。 如下所示，选择文件后返回Data URL。 注意，别选大的文件，选个小的试试就行，LOL。 var reader = new FileReader() reader.onload = function(e) { var textarea = document.getElementById('testReadAsDataURL-content'); textarea.value = reader.result } document.getElementById('testReadAsDataURL').onchange = function(e) { var file = e.target.files[0] reader.readAsDataURL(file) } Html: 1234&lt;div class=\"demo-area\"&gt; &lt;input type=\"file\" id=\"testReadAsDataURL\"&gt; &lt;textarea id=\"testReadAsDataURL-content\"&gt;&lt;/textarea&gt;&lt;/div&gt; JS: 123456789var reader = new FileReader()reader.onload = function(e) &#123; var textarea = document.getElementById('testReadAsDataURL-content'); textarea.value = reader.result&#125;document.getElementById('testReadAsDataURL').onchange = function(e) &#123; var file = e.target.files[0] reader.readAsDataURL(file)&#125; 4. Data URL能用在何处呢？最开始已经说了Data URL，是以data:模式为前缀的URL，使用场合与常规URL相同，即常规URL能够使用的场合，Data URL也可以使用。如：浏览器地址栏、link中引入css文件、script中引入js文件、img src中引入图片、video中引入视频、iframe中引入网页、css background url引入背景。 在浏览器地址栏中使用Data URL 在浏览器地址栏中使用Data URL，打开上述canvas中绘制的内容 注意：chrome 从56开始将Data URL标记为“不安全”，从60开始屏蔽从页面打开的 Data URI 网址，可以右键新标签打开。详情 document.getElementById('setDataURLInHref').href = document.getElementById('testCanvas-content').value Html: 1&lt;a href=\"base64内容\" target=\"_blank\" id=\"setDataURLInHref\"&gt;&lt;/a&gt; 在script/img/video/iframe等标签的src属性内使用Data URL 以在script中使用Data URL为例： 点击加入script标签 var scriptDataURL = `data:text/javascript;base64,YWxlcnQoJ+WcqHNjcmlwdOS4reS9v+eUqERhdGEgVVJMJykK` // 对应文本为：alert('在script中使用Data URL') $('#setDataURLInScriptBtn').click(function() { $('').attr('src', scriptDataURL).appendTo($('body')) }) JS: 12345var scriptDataURL = `data:text/javascript;base64,YWxlcnQoJ+WcqHNjcmlwdOS4reS9v+eUqERhdGEgVVJMJykK`// 对应文本为：alert('在script中使用Data URL')$('#setDataURLInScriptBtn').click(function() &#123; $('&lt;script&gt;').attr('src', scriptDataURL).appendTo($('body'))&#125;) 在&lt;link&gt;标签的href中使用Data URL 点击将文字的颜色设为红色 var linkDataURL = `data:text/css;base64,I3NldERhdGFVUkxJbkxpbmtCdG57Y29sb3I6IHJlZDt9Cg==` // 对应内容为：setDataURLInLinkBtn{color: red;} $('#setDataURLInLinkBtn').click(function() { $('').attr('href', linkDataURL).appendTo($('head')) }) JS: 12345var linkDataURL = `data:text/css;base64,I3NldERhdGFVUkxJbkxpbmtCdG57Y29sb3I6IHJlZDt9Cg==`// 对应内容为：setDataURLInLinkBtn&#123;color: red;&#125;$('#setDataURLInLinkBtn').click(function() &#123; $('&lt;link rel=\"stylesheet\" type =\"text/css\"&gt;').attr('href', linkDataURL).appendTo($('head'))&#125;) 在css样式background的url中使用Data URL const bgDataURL = $('#testCanvas-content')[0].value $('#setDataURLInBG').css('background-image', `url(${bgDataURL})`) JS: 12const bgDataURL = $('#testCanvas-content')[0].value$('#setDataURLInBG').css('background-image', `url($&#123;bgDataURL&#125;)`) 5. 参考链接 MDN Data URLs","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"http://verymuch.com/tags/Web/"}]},{"title":"escape、encodeURI和encodeURIComponent的区别与使用","slug":"escape、encodeURI和encodeURIComponent的区别与使用","date":"2017-12-12T14:51:18.000Z","updated":"2019-05-29T07:08:26.270Z","comments":true,"path":"2017/12/12/escape、encodeURI和encodeURIComponent的区别与使用/","link":"","permalink":"http://verymuch.com/2017/12/12/escape、encodeURI和encodeURIComponent的区别与使用/","excerpt":"1. escapeescape是对字符串(string)进行编码(而另外两种是对URL)，作用是让它们在所有电脑上可读。编码之后的效果是%XX或者%uXXXX这种形式。其 ASCII字母、数字、@*/+，这几个字符不会被编码，其余的都会。 注意，当需要对URL编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于URL。 在实际工作中使用较少，可以先了解功能，待有需求时再使用。 2. encodeURI 和 encodeURIComponent对URL编码是常见的事，所以这两个方法应该是实际中要特别注意的。 它们都是编码URL，唯一区别就是编码的字符范围： encodeURI方法不会对下列字符编码ASCII字母、数字、~!@#$&amp;*()=:/,;?+&#39; encodeURIComponent方法不会对下列字符编码ASCII字母、数字、~!*()&#39; 由此可见encodeURIComponent比encodeURI编码范围更大。如，encodeURIComponent会把http://编码 http%3A%2F%2F而encodeURI却不会。","text":"1. escapeescape是对字符串(string)进行编码(而另外两种是对URL)，作用是让它们在所有电脑上可读。编码之后的效果是%XX或者%uXXXX这种形式。其 ASCII字母、数字、@*/+，这几个字符不会被编码，其余的都会。 注意，当需要对URL编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于URL。 在实际工作中使用较少，可以先了解功能，待有需求时再使用。 2. encodeURI 和 encodeURIComponent对URL编码是常见的事，所以这两个方法应该是实际中要特别注意的。 它们都是编码URL，唯一区别就是编码的字符范围： encodeURI方法不会对下列字符编码ASCII字母、数字、~!@#$&amp;*()=:/,;?+&#39; encodeURIComponent方法不会对下列字符编码ASCII字母、数字、~!*()&#39; 由此可见encodeURIComponent比encodeURI编码范围更大。如，encodeURIComponent会把http://编码 http%3A%2F%2F而encodeURI却不会。 3. 总结：适用场合三个方法的区别从上面已经能够看出，但是说实话，估计具体哪些字符会被编码没人能记得住，所以化简为繁，只要记住三种方法的使用场合就行了。 如果只是编码字符串，不和URL有半毛钱关系，那么用escape。 如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。 比如encodeURI(&quot;http://www.cnblogs.com/season-huang/some other thing&quot;); 编码后会变为&quot;http://www.cnblogs.com/season-huang/some%20other%20thing&quot;; 其中，空格被编码成了%20。但是如果你用了encodeURIComponent，那么结果变为 &quot;http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2Fsome%20other%20thing&quot; 看到了区别吗，连/都被编码了，整个URL已经没法用了。 当你需要编码URL中的参数（如rdurl）的时候，那么encodeURIComponent是最好方法。 12345var param = \"http://www.cnblogs.com/season-huang/\"; //param为参数param = encodeURIComponent(param);var url = \"http://www.cnblogs.com?next=\" + param;console.log(url) // \"http://www.cnblogs.com?next=http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2F\" 从上例可以看出，参数中的/被编码了，如果用encodeURI肯定要出问题，因为后面的/是需要编码的。","categories":[],"tags":[{"name":"沉淀","slug":"沉淀","permalink":"http://verymuch.com/tags/沉淀/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-01-07T00:40:48.000Z","updated":"2017-01-10T11:04:50.000Z","comments":true,"path":"2017/01/07/hello-world/","link":"","permalink":"http://verymuch.com/2017/01/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}