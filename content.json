{"meta":{"title":"歪马行空","subtitle":"做一只默默奋斗的程序猿~！","description":null,"author":"verymuch","url":"http://verymuch.com"},"pages":[{"title":"About","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"about/index.html","permalink":"http://verymuch.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://verymuch.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-07-29T13:58:10.492Z","updated":"2018-07-29T13:58:10.492Z","comments":true,"path":"css/custom.css","permalink":"http://verymuch.com/css/custom.css","excerpt":"","text":"@import './custom-toc.css'; #container { font-size: 16px; } .text-highlight { color: red; } .text-hint { color: #999; } button { padding: 5px 10px; background: #38b7ea; color: #fff; border: none; border-radius: 2px; cursor: pointer; } /* 示例区域 */ .demo-area { border: 1px solid #f8f8f8; padding: 10px; } .demo-area textarea { display: block; margin-top: 5px; width: 100%; height: 120px; } .demo-area canvas { width: 200px; height: 100px; } /* 重置样式 */ .article-entry td { padding: 0; }"},{"title":"","date":"2018-02-10T02:46:30.313Z","updated":"2018-02-10T02:46:30.000Z","comments":true,"path":"css/custom-toc.css","permalink":"http://verymuch.com/css/custom-toc.css","excerpt":"","text":".article { position: relative; } .custom-toc-container { position: absolute; top: 5px; right: 5px; width: 36px; height: 36px; border-radius: 50%; background: #f6f8f9; z-index: 2; cursor: pointer; border: 15px solid white; } .custom-toc-container:hover { background: #edf4ef; } /* .custom-toc-container:before { position: absolute; display: block; width: 10px; height: 10px; background: white; content: \"\"; top: 20px; left: -12px; z-index: 3; transform: translate(0, -50%) rotate(45deg); box-shadow: 0.5px -0.5px 1px 0 rgba(0, 0, 0, 0.12), 0.5px -0.5px 1.5px 0 rgba(0, 0, 0, 0.04); } */ .custom-toc-container img { width: 18px; height: 18px; line-height: 36px; display: block; margin: 10px auto; } .custom-toc-container:hover .custom-toc { display: block; } .custom-toc { display: none; position: absolute; max-height: 400px; overflow-y: scroll; top: 0; right: 40px; background: white; padding: 15px 20px 15px 15px; border-radius: 3px; line-height: 2; box-shadow: 0px 2px 2px 0px rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); border: 1px solid #eee; } .custom-toc li { cursor: pointer; min-width: 160px; max-width: 600px; white-space: nowrap; } .custom-toc .custom-toc--h3 { padding: 0 0 0 20px; } .custom-toc li a { transition: all 0.3s ease; color: #333; } .custom-toc li:hover a { color: #38b7ea; } .custom-toc--h2 { font-size: 13px; } .custom-toc--h3 { font-size: 12px; }"},{"title":"","date":"2018-02-10T02:50:50.189Z","updated":"2018-02-10T02:50:50.000Z","comments":true,"path":"js/generate-toc.js","permalink":"http://verymuch.com/js/generate-toc.js","excerpt":"","text":"$(window).ready(() => { // 生成目录容器 const $article = $(\".article\"); const $tocContainer = $(\"\").addClass(\"custom-toc-container\"); const $img = $(\"\").attr({ src: \"https://p0.ssl.qhimg.com/t01b4b55a270cdc08a6.png\" }); $img.appendTo($tocContainer); $tocContainer.appendTo($article); // 根据文章内容，为二级标题生成目录 const headers = $(\"h2,h3\", $article); const headersArr = [...headers]; const $toc = $(\"\").addClass(\"custom-toc\"); headersArr.forEach(header => { const headerText = $(header).text(); const hash = $(\"span\", header).attr(\"id\"); const className = header.tagName === \"H2\" ? \"custom-toc--h2\" : \"custom-toc--h3\"; const $newLink = $(\"\") .attr(\"href\", `#${hash}`) .html($(header).text()); const $newLi = $(\"\").addClass(className); $newLink.appendTo($newLi); $newLi.appendTo($toc); }); $toc.appendTo($tocContainer); });"},{"title":"Tags","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"tags/index.html","permalink":"http://verymuch.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"W3C标准导读之【标准化过程】","slug":"W3C标准导读之标准化过程","date":"2018-08-19T13:40:37.000Z","updated":"2018-08-27T13:07:01.950Z","comments":true,"path":"2018/08/19/W3C标准导读之标准化过程/","link":"","permalink":"http://verymuch.com/2018/08/19/W3C标准导读之标准化过程/","excerpt":"本文作者：高峰，360奇舞团前端工程师，W3C性能工作组成员，同时参与WOT工作组的学习。 一、引言W3C的标准很多，你看或不看，它都在那，有增无减。既然如此，那我们为什么要读标准呢？笔者认为可能有以下4点原因：","text":"本文作者：高峰，360奇舞团前端工程师，W3C性能工作组成员，同时参与WOT工作组的学习。 一、引言W3C的标准很多，你看或不看，它都在那，有增无减。既然如此，那我们为什么要读标准呢？笔者认为可能有以下4点原因： 有一颗贡献标准的心，想要通过自己的努力为标准作出贡献； 对知识内容有执着的追求，想通过标准来彻底了解某些知识点； 熟悉标准已经成为我们应聘时的加分项甚至是基本项，我们不得不学； 当然，我们还可以通过学习W3C标准来提升英语阅读能力以及写作缜密性。 或许你阅读标准的理由不是上面之一，但我们总归是要开始读标准了，不是吗？开始之前，我们准确地了解下W3C是什么。 万维网联盟（World Wide Web Consortium，以下简称W3C）创建于1994年，是Web技术领域最具权威和影响力的国际中立性技术标准机构。它的使命是开发促进万维网发展、确保万维网互操作性的通用协议，从而尽展万维网的全部潜能。 W3C一共有36个工作组（截止至2018年8月21日，本文书写时间），已经制定了200多个标准。如此多的工作组是如何有序而又保证质量地完成如此多的标准制定的呢？正所谓没有规矩不成方圆，如此庞大的工作必然需要一个准则，所以W3C制定了流程文档1。该文档描述了W3C的组织结构以及为完成W3C自身使命而履行的职责和职能相关的流程。 流程文档的主要受众是标准制定相关成员，但是其中也有一部分内容有助于作为读者的我们理清阅读的思路，笔者即将这一部分提取出来，以供大家阅读。 那么，我们先从简单了解Web技术标准化的过程概览开始吧。 二、Web技术标准化过程概览通常情况下，W3C标准的标准化过程包括以下几步： 首先，有人开始对某个特定的话题产生兴趣。 当这个特定话题的关注度越来越高时，W3C主任会宣布为一个或多个兴趣组以及工作组开发提案章程。W3C成员审查提案章程。 当W3C内部有人支持在某个被关注的主题上投入资源时，W3C主任会批准成立工作组，该小组正式开始工作。 工作组章程包含了每个小组期望的可交付成果，工作组会按照这一期望建立标准和指南。 这些标准和指南需要经过反复的修订和审核，要接受W3C成员和大众的审核，且要满足实现和互操作性方面的要求。 最后，顾问委员会审查成熟的技术报告，如果通过则发布为标准 上述是标准产生的一个简要过程，具体的过程包括标准化过程中所涉及的组以及标准所经历的版本（或成熟度等级）下面会详细介绍。我们先从标准化过程中所涉及的组开始。 三、W3C中的组上面的标准化流程概览中提到了很多参与者，下面我们来具体介绍下，W3C标准制作过程中所涉及的各个组，主要包括以下5个。 顾问委员会 顾问委员会（Advisory Committee，简称AC）由来自各个成员组织2的代表组成，每个组织一个代表（参见AC列表3）。 他们主要负责以下工作： 在每次的顾问委员会会议上审查W3C的计划; 审查W3C主任（W3C Director）给出的正式提案，包括章程提案、提案标准以及提案的流程文档。 推选董事会（Advisory Board）成员而非董事会主席 推选技术架构组的大多数参与者 董事会 董事会（Advisory Board，简称AB）创建于1998年3月，它会就战略、管理、法律事务、流程和冲突解决等问题向团队提供持续指导。也通过记录顾问委员会会议之间提出的问题，征求成员们对此类问题的意见以及提出解决这些问题的行动，为成员们提供服务。 与顾问委员会的主要不同在于董事会在W3C内没有决策权，它的作用是仅限于咨询。 技术架构组 技术架构组（Technical Architecture Group，简称TAG）创建于2001年2月，主要任务是管理Web架构，可以分为以下三个方面： 建立Web架构原则相关共识，并形成文档，在必要的时候对这些原则进行解释和阐明。 解决涉及TAG的通用Web架构问题; 帮助协调W3C内外部跨技术架构的开发。 工作组 工作组（Working Group）是某一Web技术的具体制定者，通常会产生一系列的可交付成果（例如标准跟踪技术报告、软件、测试套件以及其他组可交付成果的审查）。 兴趣组 兴趣小组的主要目标是将有意评估潜在Web技术和策略的人员聚集在一起，便于他们交流想法。 四、技术报告的成熟度等级说完标准化过程中所涉及的组，我们再来了解一下标准所经历的版本，用流程文档中的话说是技术报告的成熟度等级。技术报告即为上述提到的工作组所产生的标准或指南等，可以在技术报告页4查看已发布的技术报告。 W3C的技术报告的成熟度划分为如下6个等级。 工作草案（Working Draft，简称WD） 工作草案是W3C发布的文档，供W3C成员，公众和其他技术组织审查。大多数工作草案都旨在推进成为标准，如果不再想推进成标准，则应当发布为工作组笔记。 值得一提的是，工作组草案不一定代表整个工作组的共识，并且也不代表W3C已经认可，因为现阶段W3C或其成员仅是同意其在某个通用技术领域成立工作组。 候选标准（Candidate Recommendation，简称CR） 如果工作草案满足了对应工作组的技术要求或者没有再进行实质性的修改（#如何区分实质性的改动，见下文#），并且已经通过广泛的审查（工作草案中提到的审查，加粗部分），则可以发布成为候选标准。发布为候选标准则意味着： 告诉广大社区，是时候进行最后的审查了 收集实现方案 由顾问委员会开始正式审查，这时这一标准可能有三个结果：推荐为W3C标准、返回工作组继续完善或者废弃。 注：候选标准已经有望成为标准，这一阶段如果再有改动，需要给出改动的原因。 提案标准（Proposed Recommendation，简称PR） 提案标准表示该文档已经被W3C主任所接受并认为其质量足以成为正式的W3C标准。进入这一阶段后会给顾问委员会设定一个具体的审查截止日期。这一阶段不能再有实质性的改动了，如果有的话只能再发布一个新的工作草案和候选标准。 正式标准（W3C Recommendation，简称REC） W3C正式标准是一份规范、一套指南或要求，已达成广泛的共识，并且获得了W3C成员和主任的认可。W3C会推荐其作为Web标准进行实施。 虽然经过了重重的努力和审查才形成了每一份标准，但是人无完人，标准也可能会有一定的缺陷。随着科技的进步，正式的标准有可能会演变成以下4种： 修订标准：工作组可能会对标准进行编辑或者其他细微的改动，W3C会发布一个新的修订版本。 编辑标准：该标准添加了不包含新特性的实质性改动时，并且该标准已经不属于现有的活跃工作组，由W3C团队完成整个制作过程。 过时标准：当一个标准缺乏足够的市场相关性来推进其实施，但其本身没有本质的问题需要被废弃时，就会变成一个过时标准。如果过时标准重新获得了足够的市场相关性，W3C可以将其恢复到推荐状态。 被取代的标准：当一个标准被W3C推荐用一个更新后的版本取代时，该标准则变为被取代的标准。 废弃标准（Rescinded Recommendation） 废弃标准是W3C不再认可、同时认为其不太可能再恢复到标准状态的标准。 工作组/兴趣组笔记（Working Group Note/Interest Group Note，简称笔记） 工作组/兴趣组笔记主要是为了记录有用但不会成为标准的文档，或者是没能成为标准时所要放弃的工作。 此外，工作组和兴趣小组可能还会提供“编辑草案”。需要知道的是，编辑草案没有任何官方声明，没有在组内达成共识，也没有W3C的认可。这一版本会因为小组成员的讨论而持续变动。 如何区分实质性改动和编辑性改动？前面提到了实质性改以及与其对应的编辑性改动，那么如何区分一个改动究竟是哪种改动呢？ 标准的改动可以分为以下四类。其中前两类是编辑性改动，后两类是实质性改动。 无文字内容改动：包括修复损坏的链接、样式文件或无效标记。 不影响一致性的改动：实现者不会将其理解成架构、互操作性要求或者实现方案更改的改动。 可能影响一致性的改动 符合要求的数据、处理器或者其他代理在新版本中不再符合要求。 不符合要求的数据、处理器或者其他代理在新版本中符合要求。 清除了规范中含糊不清的或不明确的部分。 新特性：添加了一个新功能或者元素等。 五、完整的开发流程上面介绍完了标准化过程中所涉及的组、标准所经历的版本，相信大家从中已经能对标准的开发流程有一定的了解了。下面我们再图文并茂地完整地梳理一遍标准的开发流程。 一份技术报告推进成标准的过程，主要遵循下面这些步骤，可以结合下图查看： 发布初版工作草案 发布0个及以上的修订版工作草案 发布候选标准 发布提案标准 发布W3C标准 可能会发布的编辑标准和修订标准 上面提到正式的标准也会存在一定的变动，对已有标准进行编辑所遵循的过程可以参见下图黑色加粗部分。 从图中可以看出，如果改动不是实质性改动，则直接发布一个修订版本。如果是实质性改动，但没有增加新特性，则可以直接发布一个新的候选标准。如果是新的特性则需要从工作草案阶段进行整个开发流程。 总结至此介绍完了关于W3C标准的标准化流程，本文谨代表笔者对于万维网联盟流程文档的理解，加之流程文档也会不断地进行更新，所以如本文与流程文档有冲突，请以文档为主。 文内链接 https://www.w3.org/2018/Process-20180201/#tag-participation https://www.w3.org/Consortium/Member/List https://www.w3.org/Member/ACList https://www.w3.org/TR/ 参考链接 万维网联盟流程文档","categories":[],"tags":[]},{"title":"CSS性能优化的8个技巧","slug":"CSS性能优化的8个技巧","date":"2018-07-22T15:49:10.000Z","updated":"2018-08-13T10:50:43.241Z","comments":true,"path":"2018/07/22/CSS性能优化的8个技巧/","link":"","permalink":"http://verymuch.com/2018/07/22/CSS性能优化的8个技巧/","excerpt":"本文作者：高峰，360奇舞团前端工程师，W3C性能工作组成员，同时参与WOT工作组的学习。 我们都知道对于网站来说，性能至关重要，CSS作为页面渲染和内容展现的重要环节，影响着用户对整个网站的第一体验。因此，与其相关的性能优化是不容忽视的。 对于性能优化我们常常在项目完成时才去考虑，经常被推迟到项目的末期，甚至到暴露出严重的性能问题时才进行性能优化，相信大多数人对此深有体会。 笔者认为，为了更多地避免这一情况，首先要重视起性能优化相关的工作，将其贯穿到整个产品设计与开发中。其次，就是了解性能相关的内容，在项目开发过程中，自然而然地进行性能优化。最后，也是最最重要的，那就是从现在开始实施优化。 推荐大家阅读下奇舞周刊之前推的《嗨，送你一张Web性能优化地图》1这篇文章，能够帮助大家对性能优化需要做的事以及需要考虑的问题形成一个整体的概念。 本文将会详细介绍CSS性能优化相关的技巧，笔者将它们分为实践型和建议型两类，共8个小技巧。实践型技巧能够快速地应用在项目中，能够很好地提升性能，也是笔者经常使用的，建议大家尽快在项目中实践。建议型技巧中，有的可能对性能影响并不显著，有的平时大家也并不会那么用，所以笔者不会着重讲述，读者们可以根据自身情况了解一下即可。","text":"本文作者：高峰，360奇舞团前端工程师，W3C性能工作组成员，同时参与WOT工作组的学习。 我们都知道对于网站来说，性能至关重要，CSS作为页面渲染和内容展现的重要环节，影响着用户对整个网站的第一体验。因此，与其相关的性能优化是不容忽视的。 对于性能优化我们常常在项目完成时才去考虑，经常被推迟到项目的末期，甚至到暴露出严重的性能问题时才进行性能优化，相信大多数人对此深有体会。 笔者认为，为了更多地避免这一情况，首先要重视起性能优化相关的工作，将其贯穿到整个产品设计与开发中。其次，就是了解性能相关的内容，在项目开发过程中，自然而然地进行性能优化。最后，也是最最重要的，那就是从现在开始实施优化。 推荐大家阅读下奇舞周刊之前推的《嗨，送你一张Web性能优化地图》1这篇文章，能够帮助大家对性能优化需要做的事以及需要考虑的问题形成一个整体的概念。 本文将会详细介绍CSS性能优化相关的技巧，笔者将它们分为实践型和建议型两类，共8个小技巧。实践型技巧能够快速地应用在项目中，能够很好地提升性能，也是笔者经常使用的，建议大家尽快在项目中实践。建议型技巧中，有的可能对性能影响并不显著，有的平时大家也并不会那么用，所以笔者不会着重讲述，读者们可以根据自身情况了解一下即可。 在正式开始之前，需要大家对于浏览器的工作原理2有些一定的了解，需要的小伙伴可以先简单了解下。 下面我们开始介绍实践型的4个优化技巧，先从首屏关键CSS开始。 1. 内联首屏关键CSS（Critical CSS）性能优化中有一个重要的指标——首次有效绘制（First Meaningful Paint，简称FMP）即指页面的首要内容（primary content）出现在屏幕上的时间。这一指标影响用户看到页面前所需等待的时间，而内联首屏关键CSS（即Critical CSS，可以称之为首屏关键CSS）能减少这一时间。 大家应该都习惯于通过link标签引用外部CSS文件。但需要知道的是，将CSS直接内联到HTML文档中能使CSS更快速地下载。而使用外部CSS文件时，需要在HTML文档下载完成后才知道所要引用的CSS文件，然后才下载它们。所以说，内联CSS能够使浏览器开始页面渲染的时间提前，因为在HTML下载完成之后就能渲染了。 既然内联CSS能够使页面渲染的开始时间提前，那么是否可以内联所有的CSS呢？答案显然是否定的，这种方式并不适用于内联较大的CSS文件。因为初始拥塞窗口3存在限制（TCP相关概念，通常是 14.6kB，压缩后大小），如果内联CSS后的文件超出了这一限制，系统就需要在服务器和浏览器之间进行更多次的往返，这样并不能提前页面渲染时间。因此，我们应当只将渲染首屏内容所需的关键CSS内联到HTML中。 既然已经知道内联首屏关键CSS能够优化性能了，那下一步就是如何确定首屏关键CSS了。显然，我们不需要手动确定哪些内容是首屏关键CSS。Github上有一个项目Critical CSS4，可以将属于首屏的关键样式提取出来，大家可以看一下该项目，结合自己的构建工具进行使用。当然为了保证正确，大家最好再亲自确认下提取出的内容是否有缺失。 不过内联CSS有一个缺点，内联之后的CSS不会进行缓存，每次都会重新下载。不过如上所说，如果我们将内联后的文件大小控制在了14.6kb以内，这似乎并不是什么大问题。 如上，我们已经介绍了为什么要内联关键CSS以及如何内联，那么剩下的CSS我们怎么处理好呢？建议使用外部CSS引入剩余CSS，这样能够启用缓存，除此之外还可以异步加载它们。 2. 异步加载CSSCSS会阻塞渲染，在CSS文件请求、下载、解析完成之前，浏览器将不会渲染任何已处理的内容。有时，这种阻塞是必须的，因为我们并不希望在所需的CSS加载之前，浏览器就开始渲染页面。那么将首屏关键CSS内联后，剩余的CSS内容的阻塞渲染就不是必需的了，可以使用外部CSS，并且异步加载。 那么如何实现CSS的异步加载呢？有以下四种方式可以实现浏览器异步加载CSS。 第一种方式是使用JavaScript动态创建样式表link元素，并插入到DOM中。 123456// 创建link标签const myCSS = document.createElement( \"link\" );myCSS.rel = \"stylesheet\";myCSS.href = \"mystyles.css\";// 插入到header的最后位置document.head.insertBefore( myCSS, document.head.childNodes[ document.head.childNodes.length - 1 ].nextSibling ); 第二种方式是将link元素的media属性设置为用户浏览器不匹配的媒体类型（或媒体查询），如media=&quot;print&quot;，甚至可以是完全不存在的类型media=&quot;noexist&quot;。对浏览器来说，如果样式表不适用于当前媒体类型，其优先级会被放低，会在不阻塞页面渲染的情况下再进行下载。 当然，这么做\b只是为了实现CSS的异步加载，\b别忘了在文件加载完成之后，将media的值设为screen或all，从而让浏览器开始解析CSS。 1&lt;link rel=\"stylesheet\" href=\"mystyles.css\" media=\"noexist\" onload=\"this.media='all'\"&gt; 与第二种方式相似，我们还可以通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将rel改回去。 1&lt;link rel=\"alternate stylesheet\" href=\"mystyles.css\" onload=\"this.rel='stylesheet'\"&gt; 上述的三种方法都较为古老。现在，rel=”preload”5这一Web标准指出了如何异步加载资源，包括CSS类资源。 1&lt;link rel=\"preload\" href=\"mystyles.css\" as=\"style\" onload=\"this.rel='stylesheet'\"&gt; 注意，as是必须的。忽略as属性，或者错误的as属性会使preload等同于XHR请求，浏览器不知道加载的是什么内容，因此此类资源加载优先级会非常低。as的可选值可以参考上述标准文档。 看起来，rel=&quot;preload&quot;\u001d的用法和上面两种没什么区别，都是通过更改某些属性，使得浏览器异步加载CSS文件但不解析，直到加载完成并将修改还原，然后开始解析。 但是它们之间其实有一个很重要的不同点，那就是使用preload，比使用不匹配的media方法能够更早地开始加载CSS。所以尽管这一标准的支持度还不完善，仍建议优先使用该方法。 该标准现在已经是候选标准，相信浏览器会逐渐支持该标准。\b在各浏览器的支持度如下图所示。 从上图可以看出这一方法\b在现在的浏览器中支持度不算乐观，不过我们可以通过loadCSS6进行polyfill，所以支持不支持，这都不是事儿。 3. 文件压缩性能优化时有一个最容易想到，也最常使用的方法，那就是文件压缩，这一方案往往效果显著。 文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现地尤为明显。相信大家都早已习惯对CSS进行压缩，现在的构建工具，如webpack、gulp/grunt、rollup等也都支持CSS压缩功能。压缩后的文件能够明显减小，可以大大降低了浏览器的加载时间。 4. 去除无用CSS虽然文件压缩能够降低文件大小。但CSS文件压缩通常只会去除无用的空格，这样就限制了CSS文件的压缩比例。那是否还有其他手段来精简CSS呢？答案显然是肯定的，如果压缩后的文件仍然超出了预期的大小，我们可以试着找到并删除代码中无用的CSS。 一般情况下，会存在这两种无用的CSS代码：一种是不同元素或者其他情况下的重复代码，一种是整个页面内没有生效的CSS代码。对于前者，在编写的代码时候，我们应该尽可能地提取公共类，减少重复。对于后者，在不同开发者进行代码维护的过程中，总会产生不再使用的CSS的代码，当然一个人编写时也有可能出现这一问题。而这些无用的CSS代码不仅会增加浏览器的下载量，还会增加浏览器的解析时间，这对性能来说是很大的消耗。所以我们需要找到并去除这些无用代码。 当然，如果手动删除这些无用CSS是很低效的。我们可以借助Uncss7库来进行。Uncss可以用来移除样式表中的无用CSS，并且支持多文件和JavaScript注入的CSS。 前面已经说完了实践型的4个优化技巧，下面我们介绍下建议型的4个技巧。 1. 有选择地使用选择器大多数朋友应该都知道CSS选择器的匹配是从右向左进行的，这一策略导致了不同种类的选择器之间的性能也存在差异。相比于#markdown-content-h3，显然使用#markdown .content h3时，浏览器生成渲染树（render-tree）所要花费的时间更多。因为后者需要先找到DOM中的所有h3元素，再过滤掉祖先元素不是.content的，最后过滤掉.content的祖先不是#markdown的。试想，如果嵌套的层级更多，页面中的元素更多，那么匹配所要花费的时间代价自然更高。 不过现代浏览器在这一方面做了很多优化，不同选择器的性能差别并不明显，甚至可以说差别甚微。此外不同选择器在不同浏览器中的性能表现8也不完全统一，在编写CSS的时候无法兼顾每种浏览器。鉴于这两点原因，我们在使用选择器时，只需要记住以下几点，其他的可以全凭喜好。 保持简单，不要使用嵌套过多过于复杂的选择器。 通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。 不要使用类选择器和ID选择器修饰元素标签，如h3#markdown-content，这样多此一举，还会降低效率。 不要为了追求速度而放弃可读性与可维护性。 如果大家对于上面这几点还存在疑问，笔者建议大家选择以下几种CSS方法论之一（BEM9，OOCSS10，SUIT11，SMACSS12，ITCSS13，Enduring CSS14等）作为CSS编写规范。使用统一的方法论能够帮助大家形成统一的风格，减少命名冲突，也能避免上述的问题，总之好处多多，如果你还没有使用，就赶快用起来吧。 Tips：为什么CSS选择器是从右向左匹配的？CSS中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器不匹配时提升效率。从右向左匹配就是为了达成这一目的的，通过这一策略能够使得CSS选择器在不匹配的时候效率更高。这样想来，在匹配时多耗费一些性能也能够想的通了。 2. 减少使用昂贵的属性在浏览器绘制屏幕时，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价。当页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写CSS时，我们应该尽量减少使用昂贵属性，如box-shadow/border-radius/filter/透明度/:nth-child等。 当然，并不是让大家不要使用这些属性，因为这些应该都是我们经常使用的属性。之所以提这一点，是让大家对此有一个了解。当有两种方案可以选择的时候，可以优先选择没有昂贵属性或昂贵属性更少的方案，如果每次都这样的选择，网站的性能会在不知不觉中得到一定的提升。 3. 优化重排与重绘在网站的使用过程中，某些操作会导致样式的改变，这时浏览器需要检测这些改变并重新渲染，其中有些操作所耗费的性能更多。我们都知道，当FPS为60时，用户使用网站时才会感到流畅。这也就是说，我们需要在16.67ms内完成每次渲染相关的所有操作，所以我们要尽量减少耗费更多的操作。 3.1 减少重排重排会导致浏览器重新计算整个文档，重新构建渲染树，这一过程会降低浏览器的渲染速度。如下所示，有很多操作会触发重排，我们应该避免频繁触发这些操作。 改变font-size和font-family 改变元素的内外边距 通过JS改变CSS类 通过JS获取DOM元素的位置相关属性（如width/height/left等） CSS伪类激活 滚动滚动条或者改变窗口大小 此外，我们还可以通过CSS Trigger15查询哪些属性会触发重排与重绘。 值得一提的是，某些CSS属性具有更好的重排性能。如使用Flex时，比使用inline-block和float时重排更快，所以在布局时可以优先考虑Flex。 3.2 避免不必要的重绘当元素的外观（如color，background，visibility等属性）发生改变时，会触发重绘。在网站的使用过程中，重绘是无法避免的。不过，浏览器对此做了优化，它会将多次的重排、重绘操作合并为一次执行。不过我们仍需要避免不必要的重绘，如页面滚动时触发的hover事件，可以在滚动的时候禁用hover事件，这样页面在滚动时会更加流畅。 此外，我们编写的CSS中动画相关的代码越来越多，我们已经习惯于使用动画来提升用户体验。我们在编写动画时，也应当参考上述内容，减少重绘重排的触发。除此之外我们还可以通过硬件加速16和will-change17来提升动画性能，本文不对此展开详细介绍，感兴趣的小伙伴可以点击链接进行查看。 最后需要注意的是，用户的设备可能并没有想象中的那么好，至少不会有我们的开发机器那么好。我们可以借助Chrome的开发者工具进行CPU降速，然后再进行相关的测试，降速方法如下图所示。 如果需要在移动端访问的，最好将速度限制更低，因为移动端的性能往往更差。 4. 不要使用@import最后提一下，不要使用@import引入CSS，相信大家也很少使用。 不建议使用@import主要有以下两点原因。 首先，使用@import引入CSS会影响浏览器的并行下载。使用@import引用的CSS文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。这就导致浏览器无法并行下载所需的样式文件。 其次，多个@import会导致下载顺序紊乱。在IE中，@import会引发资源文件的下载顺序被打乱，即排列在@import后面的js文件先于@import下载，并且打乱甚至破坏@import自身的并行下载。 所以不要使用这一方法，使用link标签就行了。 总结至此，我们介绍完了CSS性能优化的4个实践型技巧和4个建议型技巧，在了解这些技巧之后，CSS的性能优化从现在就可以开始了。不要犹豫了，尽快开始吧。 致谢特别感谢@anjia(安佳)、@刘宇晨、@hxl(黄小璐)、@刘观宇的辛苦审校，感谢你们对于文章结构和内容提出的宝贵建议。 文内链接 https://mp.weixin.qq.com/s/C2Zx3KPNPkgj-aHnOY43Iw https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/ https://tylercipriani.com/blog/2016/09/25/the-14kb-in-the-tcp-initial-window/ https://github.com/filamentgroup/criticalCSS https://www.w3.org/TR/preload/ https://github.com/filamentgroup/loadCSS/tree/v2.0.1#loadcss https://github.com/uncss/uncss https://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/#h-H1_1 https://en.bem.info/methodology/quick-start/ http://oocss.org/ https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md https://smacss.com/ https://www.xfive.co/blog/itcss-scalable-maintainable-css-architecture/ http://ecss.io/ https://csstriggers.com/ https://www.sitepoint.com/introduction-to-hardware-acceleration-css-animations/ https://drafts.csswg.org/css-will-change/ 参考文章 Efficiently Rendering CSS How to write CSS for a great performance web application CSS performance revisited: selectors, bloat and expensive styles Avoiding Unnecessary Paints Five CSS Performance Tools to Speed up Your Website How and Why You Should Inline Your Critical CSS Render blocking css Modern Asynchronous CSS Loading Preload","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://verymuch.com/tags/CSS/"}]},{"title":"如何清除行内元素之间的HTML空白","slug":"如何清除行内元素之间的HTML空白","date":"2018-05-23T10:00:48.000Z","updated":"2018-08-13T10:50:37.603Z","comments":true,"path":"2018/05/23/如何清除行内元素之间的HTML空白/","link":"","permalink":"http://verymuch.com/2018/05/23/如何清除行内元素之间的HTML空白/","excerpt":".Resolve { width: 90%; border: 1px solid #dd4b39; color: white; } .Resolve span { display:inline-block; width: 50%; } .Resolve span:first-child { height: 40px; background: #37b8ea; } .Resolve span:last-child { height: 30px; background: #5cb767; } /* 解决方案2 */ .Resolve2 { font-size: 0; } .Resolve2 span { font-size: 14px; } /* 解决方案3 */ .Resolve3 span:last-child { margin-left: -0.333333em; } /* 解决方案4 */ .Resolve4 { letter-spacing: -0.333333em; } .Resolve4 span { letter-spacing: 0; } 前言相信大家应该都遇到过下面这个问题：“HTML源码中行内元素之间的空白显示在了屏幕上”。可能大家都有自己的小技巧来消除这些意料之外的空白。但是方法有很多，有时候不能满足于一种解法，毕竟不同的方法是有优劣的。就像我之前一直用的方法，今天总结了之后才发现还有更好的方法。废话不多说，接下来我给大家总结一下消除行内元素HTML源码空白的小技巧。 下文中以一个div中的两个span标签为例。我们将两个div内的两个span设为display:inline-block;width:50%;，会发现两个span元素并没有在同一行，这就是源码中的空白导致的。 示例代码如下： 左侧行内元素 右侧行内元素","text":".Resolve { width: 90%; border: 1px solid #dd4b39; color: white; } .Resolve span { display:inline-block; width: 50%; } .Resolve span:first-child { height: 40px; background: #37b8ea; } .Resolve span:last-child { height: 30px; background: #5cb767; } /* 解决方案2 */ .Resolve2 { font-size: 0; } .Resolve2 span { font-size: 14px; } /* 解决方案3 */ .Resolve3 span:last-child { margin-left: -0.333333em; } /* 解决方案4 */ .Resolve4 { letter-spacing: -0.333333em; } .Resolve4 span { letter-spacing: 0; } 前言相信大家应该都遇到过下面这个问题：“HTML源码中行内元素之间的空白显示在了屏幕上”。可能大家都有自己的小技巧来消除这些意料之外的空白。但是方法有很多，有时候不能满足于一种解法，毕竟不同的方法是有优劣的。就像我之前一直用的方法，今天总结了之后才发现还有更好的方法。废话不多说，接下来我给大家总结一下消除行内元素HTML源码空白的小技巧。 下文中以一个div中的两个span标签为例。我们将两个div内的两个span设为display:inline-block;width:50%;，会发现两个span元素并没有在同一行，这就是源码中的空白导致的。 示例代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 1234567891011121314151617.Resolve &#123; width: 90%; border: 1px solid #dd4b39; color: white;&#125;.Resolve span &#123; display:inline-block; width: 50%;&#125;.Resolve span:first-child &#123; height: 40px; background: #37b8ea;&#125;.Resolve span:last-child &#123; height: 30px; background: #5cb767;&#125; 解决方案1：源码中直接就写成一行相信大家看到这个解决方案的时候，会想这不是废话嘛。有时候我们就是为了代码的美观，才将两个span标签分两行显示的，写在一行根本就没解决问题好不好？ 不过，我觉得这并不是废话，之所以将其列为一种解决方案，是防止有的人不知道是什么原因导致的空白的显示。知道了这个原因，如果两个行内元素的横向宽度(此处指代码宽度)不大，写在一行也算是最快最直接的解决方法。 示例代码如下： 左侧行内元素右侧行内元素 HTML： 123&lt;div class=\"Resolve Resolve1\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt;&lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; 解决方案2：font-size: 0; （笔者一直使用的方法）问题中span标签之间的空白是因为换行符/Tab制表符/空格等产生的间隔，并且据笔者测试，得出这个距离是字体大小的1/3倍（请先记住这个值）。那么既然空格和字体大小font-size相关。那么也可以通过字体大小来消除这个空隙。 在父级元素上设置font-size: 0;，然后再在内部的span设置需要的字体大小即可。 示例代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve2\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 123456.Resolve2 &#123; font-size: 0;&#125;.Resolve2 span &#123; font-size: 14px;&#125; 这种情况在内部的行内元素字体大小比较统一时，处理起来较为方便，但如果包含的行内元素中存在多种字体大小，需要一一指定，较为繁琐。不过往往这种时候内部的多种字体大小也是单独指定。可以根据具体场景决定是否使用该方案。 解决方案3：margin-left设为负值如果行内元素为块级行内元素，则可以使用margin属性来抵消空白。在【解决方案2】中有提到行内元素之间的距离是字体大小的1/3倍。所以我们只需要将第二个span元素的margin-left设置为-0.333333em即可。 示例代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve3\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 123.Resolve3 span:last-child &#123; margin-left: -0.333333em;&#125; 不过从上面可以看出，最右边还会存在一点点的白边误差。这是由于margin-left的计算精度导致的。 解决方案4：letter-spacing消除文字间距离同方案2、方案3，我们还可以通过letter-spacing改变行内元素之间空隙的大小，将letter-spacing设为-0.333333em即可。但是与font-size一样，改变letter-spacing时会改变内部子元素的间隙，需要手动矫正。 示例代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve4\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 123456.Resolve4 &#123; letter-spacing: -0.333333em;&#125;.Resolve4 span &#123; letter-spacing: 0;&#125; 解决方案5：HTML注释（推荐使用）除了调整css样式之外，我们可以使用html注释来抵消空格，这种情况下不用额外进行css处理。此外笔者觉得还有一个好处，可以加上文字注释，告知为什么会加入注释。 推荐使用该方式，能够有效保持代码整齐，并且不用额外添加css样式。 示例代码如下： 左侧行内元素右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve5\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt;&lt;!-- 消除行内元素换行导致的空白--&gt;&lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; 总结以上就是解决行内元素间HTML空白的5种方案，虽然这些方案都不是很理想，但是有时候在特定的情况下，我们往往需要其中之一作为解决方案。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://verymuch.com/tags/CSS/"}]},{"title":"如何在Array.forEach中实现break","slug":"如何在Array-forEach中实现break","date":"2018-02-09T01:39:23.000Z","updated":"2018-08-13T10:50:34.451Z","comments":true,"path":"2018/02/09/如何在Array-forEach中实现break/","link":"","permalink":"http://verymuch.com/2018/02/09/如何在Array-forEach中实现break/","excerpt":"使用for in遍历对象时，会遍历原型链上的可枚举实行，而这些往往会导致一些意想不到的问题。 鉴于上面这个原因，我们团队在之前的几个项目里，通过eslint禁止在代码中使用for in。虽然在大部分情况，我们都能按照约定不使用for in，但是偶尔仍会需要在forEach中中断循环的情况。 有需求就有解决方案。 遇到这个问题时，笔者最简单的思路就是，在forEach外层设置标志位为false，然后在需要break时，将标志位置为true，循环内判断true则直接返回。这样做虽然能够减少循环内部的逻辑处理，但是还是会空跑整个循环，造成资源浪费。 既然自己想的方法是最简单的，并且存在弊端，那么就搜搜其他大神的有哪些思路吧。于是乎就有了以下的总结：","text":"使用for in遍历对象时，会遍历原型链上的可枚举实行，而这些往往会导致一些意想不到的问题。 鉴于上面这个原因，我们团队在之前的几个项目里，通过eslint禁止在代码中使用for in。虽然在大部分情况，我们都能按照约定不使用for in，但是偶尔仍会需要在forEach中中断循环的情况。 有需求就有解决方案。 遇到这个问题时，笔者最简单的思路就是，在forEach外层设置标志位为false，然后在需要break时，将标志位置为true，循环内判断true则直接返回。这样做虽然能够减少循环内部的逻辑处理，但是还是会空跑整个循环，造成资源浪费。 既然自己想的方法是最简单的，并且存在弊端，那么就搜搜其他大神的有哪些思路吧。于是乎就有了以下的总结： 当需要在for in中使用break时，可以采用以下几种方案： 1. throw法抛出一个错误，但是需要注意的是要抛出一个可以与别的错误区别开的错误，这样不会干扰别的代码抛出的错误 12345678910var BreakException = &#123;&#125;;try &#123; [1, 2, 3].forEach(function(v) &#123; console.log(v); //只输出1,2 if (v === 2) throw BreakException; &#125;);&#125; catch (e) &#123; if (e !== BreakException) throw e;&#125; 此法有点丑陋，加了不少代码 2. 空跑循环在外层加一个标识，如果此标识为true，接下来的循环空跑，如下： （空跑循环，也就是笔者自己想到的思路，不过笔者还是Low一点的。） 12345678910111213var breakFlag = false;[1, 2, 3].forEach(function(v) &#123; if (breakFlag === true) &#123; return false; &#125; if (v === 2) &#123; breakFlag = true &#125; console.log(v) //只输出1,2&#125;) 这个方法在外层加了一个变量，为了不污染外层的环境，我们可以使用forEach的第二个参数context，把标识放在这里（高就高在了这里）。 12345678910[1, 2, 3].forEach(function(v) &#123; if (this.breakFlag === true) &#123; return false; &#125; if (v === 2) &#123; this.breakFlag = true &#125; console.log(v) //只输出1,2&#125;, &#123;&#125;); 注意，forEach的第二个参数context，只有在使用非箭头函数时有效，如果是箭头函数，无法改变context的指向。 1234567891011[1, 2, 3].forEach((v) =&gt; &#123; if (this.breakFlag === true) &#123; return false; &#125; if (v === 2) &#123; console.log(this) // 运行会发现，结果并不是&#123;test: 'test'&#125; this.breakFlag = true &#125; console.log(v) //只输出1,2&#125;, &#123;test: 'test'&#125;); 当然，上述这种方法不可避免的导致了不必要的运行,有点浪费cpu的感觉 3. 神奇改数组大法下面出场的这位选手，稍微有点技术含量，笔者还是问了大佬才知道的，一定是我太过愚钝了。 1234567var array = [1, 2, 3, 4, 5];array.forEach(function(item, index) &#123; if (item === 2) &#123; array = array.concat(array.splice(index, array.length - index)); &#125; console.log(item); //只输出1,2&#125;); 这种方法相当于在item === 2的时候，改变了原数组引用的值，但是将array指向了一个新的引用，值保持不变。 4. 最应该使用的every前面啰嗦了这么多，真正的主角登场，*最推荐的方式是在需要break的场景下，使用every或者some every: 碰到return false的时候，循环中止 some: 碰到return ture的时候，循环中止 两者的代码分别如下： 123456789var a = [1, 2, 3, 4, 5]a.every(function(item, index, arry) &#123; console.log(item); //返回1,2 if (item === 2) &#123; return false &#125; else &#123; return true &#125;&#125;) 123456789var a = [1, 2, 3, 4, 5]a.some(function(item, index, arry) &#123; console.log(item); //返回1,2 if (item === 2) &#123; return true &#125; else &#123; return false &#125;&#125;) 5. 参考内容 http://jser.me/2014/04/02/%E5%A6%82%E4%BD%95%E5%9C%A8Array.forEach%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%87%8Cbreak.html","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://verymuch.com/tags/Javascript/"}]},{"title":"Data URL简介与使用","slug":"Data-URL简介与使用","date":"2017-12-14T00:34:41.000Z","updated":"2018-08-13T10:50:27.008Z","comments":true,"path":"2017/12/14/Data-URL简介与使用/","link":"","permalink":"http://verymuch.com/2017/12/14/Data-URL简介与使用/","excerpt":"1. 简介Data URL，是以data:模式为前缀的URL，允许内容的创建者将较小的文件嵌入到文档中。与常规的URL使用场合类似（下面会具体介绍可以将Data URL用在哪些地方）。 Data URL由data:前缀、MIME类型（表明数据类型）、base64标志位（如果是文本，则可选）以及数据本身四部分组成。 语法格式如下： 1data:[&lt;mediatype&gt;][;base64],data mediatype是一个MIME（Multipurpose Internet Mail Extension）类型字符串，如image/jpeg表示一个JPEG图片文件。如果省略，默认值为text/plain;charset=US-ASCII。","text":"1. 简介Data URL，是以data:模式为前缀的URL，允许内容的创建者将较小的文件嵌入到文档中。与常规的URL使用场合类似（下面会具体介绍可以将Data URL用在哪些地方）。 Data URL由data:前缀、MIME类型（表明数据类型）、base64标志位（如果是文本，则可选）以及数据本身四部分组成。 语法格式如下： 1data:[&lt;mediatype&gt;][;base64],data mediatype是一个MIME（Multipurpose Internet Mail Extension）类型字符串，如image/jpeg表示一个JPEG图片文件。如果省略，默认值为text/plain;charset=US-ASCII。 2. Data URL的优缺点 Data URL的优势 和传统的外部资源引用，Data URL有着以下优势： 当访问外部资源很麻烦或受限时，可以将外部资源转为Data URL引用(这个比较鸡肋) 当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时，这是需要返回一个可用的URL（场景较少） 当图片的体积太小，占用一个HTTP会话不是很值得时（雪碧图可以出场了） Data URL的缺点 虽然Data URL允许使用者将文件嵌入到文档中，这在某些场景下较为合适，但是Data URL也有一些缺点： 体积更大：Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3 不会缓存：Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。 3. 如何获取base64编码 Linux/Mac OS X下可以使用uuencode命令 1uuencode -m &lt;源文件&gt; &lt;转码后标识&gt; 如执行uuencode -m hello-base64 hello，会得到如下结果： 123begin-base64 644 helloaGVsbG8gYmFzZTY0 // 此处为base64编码，对应文本内容为 'hello base64'==== 使用原生Web API编码/解码 Javascript中有两个函数负责编码和解码base64字符串，分别是atob和btoa。 atob(): 负责解码已经使用base64编码了的字符串。 btoa(): 将二进制字符串转为base64编码的ASCII字符串。 两者都只针对Data URL中的data进行处理。 12btoa('hello base64') // \"aGVsbG8gYmFzZTY0\"atob('aGVsbG8gYmFzZTY0') // \"hello base64\" Canvas的toDataURL方法 Canvas提供了toDataURL方法，用于获取canvas绘制内容，将其转为base64格式。 如下所示，文本框中的内容即为canvas中绘制内容的base64格式。 var canvas = document.getElementById('testCanvas'); if (canvas.getContext) { var ctx = canvas.getContext('2d'); // 设置字体 ctx.font = \"Bold 20px Arial\"; // 设置对齐方式 ctx.textAlign = \"left\"; // 设置填充颜色 ctx.fillStyle = \"#000\"; // 设置字体内容，以及在画布上的位置 ctx.fillText(\"hello base64\", 10, 30); // 绘制空心字 ctx.strokeText(\"hello base64\", 10, 80); // 获取 Data URL document.getElementById('testCanvas-content').value = canvas.toDataURL(); } Html: 12&lt;canvas id=\"testCanvas\" width=\"200\" height=\"100\"&gt;&lt;/canvas&gt;&lt;textarea id=\"testCanvas-content\"&gt;&lt;/textarea&gt; JS: 12345678910111213141516var canvas = document.getElementById('testCanvas');if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); // 设置字体 ctx.font = \"Bold 20px Arial\"; // 设置对齐方式 ctx.textAlign = \"left\"; // 设置填充颜色 ctx.fillStyle = \"#000\"; // 设置字体内容，以及在画布上的位置 ctx.fillText(\"hello base64\", 10, 30); // 绘制空心字 ctx.strokeText(\"hello base64\", 10, 80); // 获取 Data URL document.getElementById('testCanvas-content').value = canvas.toDataURL();&#125; 使用FileReader API的readAsDataURL方法 FileReader API提供的readAsDataURL方法能够返回一个基于base64编码的Data URL。 如下所示，选择文件后返回Data URL。 var reader = new FileReader() reader.onload = function(e) { var textarea = document.getElementById('testReadAsDataURL-content'); textarea.value = reader.result } document.getElementById('testReadAsDataURL').onchange = function(e) { var file = e.target.files[0] reader.readAsDataURL(file) } Html: 1234&lt;div class=\"demo-area\"&gt; &lt;input type=\"file\" id=\"testReadAsDataURL\"&gt; &lt;textarea id=\"testReadAsDataURL-content\"&gt;&lt;/textarea&gt;&lt;/div&gt; JS: 123456789var reader = new FileReader()reader.onload = function(e) &#123; var textarea = document.getElementById('testReadAsDataURL-content'); textarea.value = reader.result&#125;document.getElementById('testReadAsDataURL').onchange = function(e) &#123; var file = e.target.files[0] reader.readAsDataURL(file)&#125; 4. Data URL能用在何处呢？最开始已经说了Data URL，是以data:模式为前缀的URL，使用场合与常规URL相同，即常规URL能够使用的场合，Data URL也可以使用。如：浏览器地址栏、link中引入css文件、script中引入js文件、img src中引入图片、video中引入视频、iframe中引入网页、css background url引入背景。 在浏览器地址栏中使用Data URL 在浏览器地址栏中使用Data URL，打开上述canvas中绘制的内容 注意：chrome 从56开始将Data URL标记为“不安全”，从60开始屏蔽从页面打开的 Data URI 网址，可以右键新标签打开。详情 document.getElementById('setDataURLInHref').href = document.getElementById('testCanvas-content').value Html: 1&lt;a href=\"base64内容\" target=\"_blank\" id=\"setDataURLInHref\"&gt;&lt;/a&gt; 在script/img/video/iframe等标签的src属性内使用Data URL 以在script中使用Data URL为例： 点击加入script标签 var scriptDataURL = `data:text/javascript;base64,YWxlcnQoJ+WcqHNjcmlwdOS4reS9v+eUqERhdGEgVVJMJykK` // 对应文本为：alert('在script中使用Data URL') $('#setDataURLInScriptBtn').click(function() { $('').attr('src', scriptDataURL).appendTo($('body')) }) JS: 12345var scriptDataURL = `data:text/javascript;base64,YWxlcnQoJ+WcqHNjcmlwdOS4reS9v+eUqERhdGEgVVJMJykK`// 对应文本为：alert('在script中使用Data URL')$('#setDataURLInScriptBtn').click(function() &#123; $('&lt;script&gt;').attr('src', scriptDataURL).appendTo($('body'))&#125;) 在&lt;link&gt;标签的href中使用Data URL 点击将文字的颜色设为红色 var linkDataURL = `data:text/css;base64,I3NldERhdGFVUkxJbkxpbmtCdG57Y29sb3I6IHJlZDt9Cg==` // 对应内容为：setDataURLInLinkBtn{color: red;} $('#setDataURLInLinkBtn').click(function() { $('').attr('href', linkDataURL).appendTo($('head')) }) JS: 12345var linkDataURL = `data:text/css;base64,I3NldERhdGFVUkxJbkxpbmtCdG57Y29sb3I6IHJlZDt9Cg==`// 对应内容为：setDataURLInLinkBtn&#123;color: red;&#125;$('#setDataURLInLinkBtn').click(function() &#123; $('&lt;link rel=\"stylesheet\" type =\"text/css\"&gt;').attr('href', linkDataURL).appendTo($('head'))&#125;) 在css样式background的url中使用Data URL const bgDataURL = $('#testCanvas-content')[0].value $('#setDataURLInBG').css('background-image', `url(${bgDataURL})`) JS: 12const bgDataURL = $('#testCanvas-content')[0].value$('#setDataURLInBG').css('background-image', `url($&#123;bgDataURL&#125;)`) 5. 参考链接 MDN Data URLs","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"http://verymuch.com/tags/Web/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-01-07T00:40:48.000Z","updated":"2017-01-10T11:04:50.000Z","comments":true,"path":"2017/01/07/hello-world/","link":"","permalink":"http://verymuch.com/2017/01/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}