{"meta":{"title":"歪马行空","subtitle":"做一只默默奋斗的程序猿~！","description":null,"author":"verymuch","url":"http://verymuch.com"},"pages":[{"title":"Categories","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://verymuch.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"about/index.html","permalink":"http://verymuch.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2018-10-09T08:37:07.740Z","updated":"2018-10-09T08:37:07.740Z","comments":true,"path":"css/custom.css","permalink":"http://verymuch.com/css/custom.css","excerpt":"","text":"@import './custom-toc.css'; #container { font-size: 16px; } .text-highlight { color: red; } .text-hint { color: #999; } button { padding: 5px 10px; background: #38b7ea; color: #fff; border: none; border-radius: 2px; cursor: pointer; } /* 示例区域 */ .demo-area { border: 1px solid #f8f8f8; padding: 10px; } .demo-area textarea { display: block; margin-top: 5px; width: 100%; height: 120px; } .demo-area canvas { width: 200px; height: 100px; } /* 重置样式 */ .article-entry td { /* padding: 0; */ } .article-entry--center th, .article-entry--center td { text-align: center; }"},{"title":"","date":"2018-02-10T02:50:50.189Z","updated":"2018-02-10T02:50:50.000Z","comments":true,"path":"js/generate-toc.js","permalink":"http://verymuch.com/js/generate-toc.js","excerpt":"","text":"$(window).ready(() => { // 生成目录容器 const $article = $(\".article\"); const $tocContainer = $(\"\").addClass(\"custom-toc-container\"); const $img = $(\"\").attr({ src: \"https://p0.ssl.qhimg.com/t01b4b55a270cdc08a6.png\" }); $img.appendTo($tocContainer); $tocContainer.appendTo($article); // 根据文章内容，为二级标题生成目录 const headers = $(\"h2,h3\", $article); const headersArr = [...headers]; const $toc = $(\"\").addClass(\"custom-toc\"); headersArr.forEach(header => { const headerText = $(header).text(); const hash = $(\"span\", header).attr(\"id\"); const className = header.tagName === \"H2\" ? \"custom-toc--h2\" : \"custom-toc--h3\"; const $newLink = $(\"\") .attr(\"href\", `#${hash}`) .html($(header).text()); const $newLi = $(\"\").addClass(className); $newLink.appendTo($newLi); $newLi.appendTo($toc); }); $toc.appendTo($tocContainer); });"},{"title":"Tags","date":"2017-10-19T15:02:41.000Z","updated":"2017-01-07T13:10:54.000Z","comments":true,"path":"tags/index.html","permalink":"http://verymuch.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-10T02:46:30.313Z","updated":"2018-02-10T02:46:30.000Z","comments":true,"path":"css/custom-toc.css","permalink":"http://verymuch.com/css/custom-toc.css","excerpt":"","text":".article { position: relative; } .custom-toc-container { position: absolute; top: 5px; right: 5px; width: 36px; height: 36px; border-radius: 50%; background: #f6f8f9; z-index: 2; cursor: pointer; border: 15px solid white; } .custom-toc-container:hover { background: #edf4ef; } /* .custom-toc-container:before { position: absolute; display: block; width: 10px; height: 10px; background: white; content: \"\"; top: 20px; left: -12px; z-index: 3; transform: translate(0, -50%) rotate(45deg); box-shadow: 0.5px -0.5px 1px 0 rgba(0, 0, 0, 0.12), 0.5px -0.5px 1.5px 0 rgba(0, 0, 0, 0.04); } */ .custom-toc-container img { width: 18px; height: 18px; line-height: 36px; display: block; margin: 10px auto; } .custom-toc-container:hover .custom-toc { display: block; } .custom-toc { display: none; position: absolute; max-height: 400px; overflow-y: scroll; top: 0; right: 40px; background: white; padding: 15px 20px 15px 15px; border-radius: 3px; line-height: 2; box-shadow: 0px 2px 2px 0px rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); border: 1px solid #eee; } .custom-toc li { cursor: pointer; min-width: 160px; max-width: 600px; white-space: nowrap; } .custom-toc .custom-toc--h3 { padding: 0 0 0 20px; } .custom-toc li a { transition: all 0.3s ease; color: #333; } .custom-toc li:hover a { color: #38b7ea; } .custom-toc--h2 { font-size: 13px; } .custom-toc--h3 { font-size: 12px; }"}],"posts":[{"title":"浏览器缓存策略","slug":"web-browser-cache-strategy","date":"2018-10-09T07:45:32.000Z","updated":"2018-10-16T16:33:12.800Z","comments":true,"path":"2018/10/09/web-browser-cache-strategy/","link":"","permalink":"http://verymuch.com/2018/10/09/web-browser-cache-strategy/","excerpt":"前言众所周知，在Web开发中，缓存很重要、很有用。但同时其也很复杂。 本文将从以下5个方面全面地介绍下缓存相关的内容。 缓存的判断策略 必知必会的缓存基础 各类缓存的优缺点 缓存的最佳实践 小试牛刀，看看你掌握了没有？","text":"前言众所周知，在Web开发中，缓存很重要、很有用。但同时其也很复杂。 本文将从以下5个方面全面地介绍下缓存相关的内容。 缓存的判断策略 必知必会的缓存基础 各类缓存的优缺点 缓存的最佳实践 小试牛刀，看看你掌握了没有？ 一、缓存的判断策略浏览器对于所请求资源的缓存处理有一套完整的机制，主要包含以下三个策略：存储策略、过期策略、协商策略。 其中，存储策略发生在收到请求响应后，用于决定是否缓存相应资源；过期策略发生在请求前，用于判断缓存是否过期；协商策略发生在请求中，用于判断缓存资源是否更新。 浏览器在应用缓存策略时，具体的判断流程如下： 上图中的缓存判断流程是浏览器在应用缓存时完整的判断流程。但是在浏览器中访问资源的方式不同也会导致判断流程的不同。判断流程会根据不同方式跳过一些流程。 浏览器下访问资源的方式主要有以下7种： (新标签)地址栏回车 链接跳转 前进、后退 从收藏栏打开链接 (window.open)新开窗口 刷新（Command + R / F5） 强制刷新（Command + Shift + R / Ctrl + F5） 使用这7种方式访问资源时，应用缓存的策略会有一些不同。 需要注意的是，除此之外，还有一种特殊情况。即在当前地址栏，不改变内容，直接回车，等同于刷新当前页。但是在当前页点击跳转到自身，和链接跳转一致，并不会等同于刷新。 如下图所示。通过上述8种方式访问资源，会从不同的缓存应用判断步骤开始。此处不做验证，相信大家看了后面的内容，能够自行验证的。 本文配有测试脚本，代码在github上。下文会按照测试脚本进行述说，使用说明见下载链接。验证上述内容，可以执行node cache-ETag+max-age.js，会同时开启ETag和max-age，然后触发相应的动作，通过Network面板和node日志即可验证，此处篇幅有限先不赘述。 此外，这里提一个概念，webkit资源分为主资源和派生资源。主资源是地址栏输入的URL请求返回的资源，派生资源是主资源中所引用的JS、CSS、图片等资源。 在Chrome下刷新时，只有主资源的缓存应用方式如上图所示，派生资源的缓存应用方式与新标签打开类似，会判断缓存是否过期。强缓存生效时的区别在于新标签打开为from disk cache，而当前页刷新派生资源是from memory cache。 而在Firefox下，当前页面刷新，所有资源都会如上图所示。下文也会利用Chrome的这一特点在当前页刷新，派生资源会使用缓存进行测试。不然每次都需要打开新标签较为繁琐。 二、必知必会的缓存基础HTTP中与缓存有关的字段主要有以下10个，如下表所示。为明确表示其功能及用法，下表中分别区分了存储策略、过期策略、协商策略、请求头、响应头。 Key 描述 存储策略 过期策略 协商策略 请求头 响应头 Expires 指定缓存的过期时间，值为某一时刻（绝对时间）。在指定时刻后过期 ✓ ✓ ✓ Cache-Control 指定缓存机制 ✓ ✓ ✓ ✓ Pragma 指定缓存机制(http1.0字段) ✓ Last-Modified 资源最后修改时间 乄 ✓ ✓ If-Modified-Since 缓存协商校验字段，为上次请求收到的Last-Modified的值。处理方式见下文。 ✓ ✓ If-Unmodified-Since 缓存协商校验字段，为上次请求收到的Last-Modified的值。处理方式与If-Modified-Since相反，见下文。 ✓ ✓ ETag 请求资源的唯一标识字符串 ✓ ✓ If-Match 缓存协商校验字段，请求资源的唯一标识字符串，为上次请求收到的ETag的值。处理方式见下文。 ✓ ✓ If-None-Match 缓存协商校验字段，请求资源的唯一标识字符串，为上次请求收到的ETag的值。处理方式与If-Match相反，见下文。 ✓ ✓ 注：乄表示半对，Last-Modified之所以是半对，是因为有可能会触发启发式缓存，也会缓存文件。具体见下文。 缓存又分为强缓存和弱缓存（又称为协商缓存）。其中强缓存包括Expires和Cache-Control，主要是在过期策略生效时应用的缓存。弱缓存包括Last-Modified和ETag，是在协商策略后应用的缓存。强弱缓存之间的主要区别在于获取资源时是否会发送请求。 2.1 Expires如上所述，Expires指定缓存的过期时间，为绝对时间，即某一时刻。参考本地时间进行比对，在指定时刻后过期。RFC 2616建议最大值不要超过1年。 Expire头字段是响应头字段，格式如下：Expires: Sat Oct 20 2018 00:00:00 GMT+0800 (CST)。 可以尝试以下步骤进行验证： \b执行node cache-Expires.js，该脚本会给请求的资源设定Expires，值为：”2018-10-20 00:00:00”。 访问地址http://localhost:1030/，开启Network Tab，查看avatar.jpg图片，Expires值如下所示。 再次刷新会看到该资源已经被缓存，size栏显示为(from memory cache)。此时修改本地时间，将时间修改为“2018-10-15 00:00:00”，再刷新，会发现缓存仍然有效。 如果将本地时间修改为“2018-10-25 00:00:00”，再刷新，会发现图片不再使用缓存，而是重新获取了，因为本地时间超过了设定值。 2.2 Cache-ControlCache-Control用于指定资源的缓存机制，可以同时在请求头和响应头中设定，涉及上述三个策略中的两个策略：存储策略、过期策略。 Cache-Control的语法如下：Cache-Control: cache-directive[,cache-directive]。cache-directive为缓存指令，大小写不敏感，共有12个与HTTP缓存标准相关，如下表所示。其中请求指令7种，响应指令9种。Cache-Control可以设置多个缓存指令，以逗号,分隔。 Key 描述 存储策略 过期策略 请求字段 响应字段 可缓存性相关 public 资源在客户端和代理服务器缓存 ✓ ✓ private 资源仅在在客户端缓存，\b代理服务器不缓存 ✓ ✓ no-cache 资源被缓存，但立即过期，下次访问时强制向服务器验证资源有效性。相当于max-age:0,must-revalidate ✓ ✓ ✓ ✓ 过期相关 max-age=&lt;seconds&gt; 在请求头中：指出客户端不接受有效时间大于指定时间的缓存。 在响应头中：规定资源的最大新鲜时间，指定时间后过期，单位为秒。 ✓ ✓ ✓ ✓ s-maxage=&lt;seconds&gt; 同上，但只对代理服务器生效，如果是private缓存，会忽略该字段。会覆盖max-age或Expires头字段 ✓ ✓ ✓ max-stale=&lt;seconds&gt; 指定时间内, 即使缓存过时, 资源依然有效 ✓ ✓ min-fresh=&lt;seconds&gt; 缓存的资源至少要保持指定时间的新鲜期 ✓ ✓ 验证与重载相关 must-revalidate 使用缓存资源之前，必须先验证状态，并且过期资源不应该再使用。 ✓ ✓ proxy-revalidate 同上，但只对代理服务器生效，如果是private缓存，会忽略该字段。 ✓ ✓ 其他 no-store 请求和响应都不缓存 ✓ ✓ ✓ only-if-cached 仅返回已经缓存的资源，不再向服务器获取新的内容。若无缓存则返回504 ✓ no-transform 强制要求代理服务器不要对资源进行转换, 禁止代理服务器对 Content-Encoding, Content-Range, Content-Type字段的修改(因此代理的gzip压缩将不被允许) ✓ ✓ 2.3.1 cache-directive大小写不敏感如上，cache-directive指令大小写不敏感，所以在设置Cache-Control时，指令可以不区分大小写。不过建议统一使用小写。验证如下： 执行node cache-directive-case-insensitive.js，会服务端会将max-age写成大写，如下Cache-Control: MAX-AGE=86400。 再次请求浏览器会发现缓存同样会生效。 2.3.2 在请求头中的max-agemax-age在请求头中的主要应用为max-age=0表示不使用缓存。Chrome和Firefox浏览器下的刷新操作（Command+ R / F5）均是在请求头上添加了max-age=0\u001d指令，表示不使用强缓存，但允许协商缓存（在介绍了协商缓存的Last-Modified和ETag之后，可以自行验证下这一点）。\b 刷新时Cache-Control为max-age=0验证如下： 单独访问图片资源http://localhost:1030/avatar.jpg，开启Network 刷新，可在响应头中看到上述内容。如下图所示。（Firefox下相同，不单独验证，主要最开始提到的主资源和派生资源在两个浏览器中表现形式的不同）。 此外，经验证，Chrome和\bFirefox均对max-age&gt;0的情况支持不好。 在Chrome下，通过Modify Headers插件（Chrome和Firefox下均有类似插件）给请求添加max-age=7200。 \b执行node cache-max-age.js，访问http://localhost:1030，先强刷保证资源更新。 打开NetWork，查看avatar.jpg，刷新，会发现，资源访问仍然走的是缓存。如果按照规范的定义应该是不生效。 2.3.3 max-age与ExpiresCache-Control中的max-age指令用于指定缓存过期的相对时间。\b资源达到指定时间后过期。该功能与Expires类似。但其优先级高于Expires，如果同时设置max-age和Expires，max-age生效，忽略Expires。验证如下： 执行node cache-max-age+Expires.js，会同时设置Cache-Control: max-age=86400 / Expires: Mon Oct 20 2018 00:00:00 GMT+0800 (CST)，如下所示。 刷新，\b然后再把本地时间改成当前时间延后2小时(不超过20号)，会发现缓存生效。\b(以下两步不再附截图，与上述示例类似)。 如果将时间改为两天后（假设20号离现在大于两天，否则结果相反），会发现缓存不再生效，因为超出了max-age的限制。 相反，可以再试一下，max-age的有效时间大于Expires的情况，会发现依然是max-age生效。 2.3.4 no-cache和no-store还有一点需要注意的是，no-cache并不是指不缓存文件，no-store才是指不缓存文件。no-cache仅仅是表明跳过强缓存，强制进入协商策略。 2.3 Pragmahttp1.0字段, 通常设置为Pragma:no-cache, 作用与Cache-Control:no-cache相同。当在浏览器进行强刷（Comand + Shift + R / Ctrl + F5）或在NetWork面板内勾选禁用缓存（Disable Caches）时，会自动带上Pragma:no-cache和Cache-Control:no-cache，并且不会带上协商策略中所涉及的信息（下面介绍的If-Modified-Since/If-None-Match）。这是不会使用任何缓存，重新获取资源。如下图所示。 2.4 Last-Modified/If-Modified-Since/If-Unmodified-SinceLast-Modified用于标记请求资源的最后一次修改时间。语法格式为：Last-Modified: &lt;day-name&gt;，&lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT，即GMT(格林尼治标准时间)。可用 new Date().toGMTString()获取当前GMT时间。由于Last-Modified只能精确到秒，因此不适合在一秒内多次改变的资源。 如果Expires，Cache-Control: max-age，或 Cache-Control:s-maxage都没有在响应头中出现，并且设置了Last-Modified时，那么浏览器默认会采用一个启发式的算法，即启发式缓存。通常会取响应头的Date_value - Last-Modified_value值的10%作为缓存时间。验证如下： 执行node cache-Last-Modified.js，服务器会获取资源的最后修改时间，设置为Last-Modified的值。访问localhost:1030，查看avatar.jpg，如下图所示： 刷新浏览器，会发现图片会从缓存获取。 通过启发式缓存的公司可以计算出缓存的时间，修改本地时间超过缓存时间后，再刷新，会发现缓存失效。 2.4.1 If-Modified-Since返回的资源带有Last-Modified标识时，再次请求该资源，浏览器会自动带上If-Modified-Since，值为返回的Last-Modified值。请求到达服务器后，服务器进行判断，如果从上次更新后没有再更新，则返回304。如果更新了则重新返回。验证如下： 执行node cache-Last-Modified.js，服务器会获取资源的最后修改时间，设置为Last-Modified的值。如下图所示，并且注意看一下资源的大小。 \b刷新页面，再次查看NetWork。会发现请求头中带上了If-Modified-Since。如果服务器判断资源未改变，则返回304，此外由于服务器返回304，资源会从缓存获取，所以资源大小也减少了，如下所示。 修改index.html文件的内容，再次刷新。会发现返回变成200，html内容更新了，并且返回了新的\bLast-Modified的值，资源大小也相应地改变了。 304请求也可以触发存储策略，如文章开头的流程判断图所示，可自行验证，返回时添加相应header即可。 注意，If-Modified-Since只能用于GET、HEAD请求。 2.4.2 If-Unmodified-SinceIf-Unmodified-Since表示资源未修改则正常执行更新，否则返回412(Precondition Failed)状态码的响应。主要有如下两种场景。 用于不安全的请求中从而是请求具备条件性（如POST或者其他不安全的方法），如请求更新wiki文档，文档未修改时才执行更新。 与If-Range字段同时使用时，可以用来保证新的片段请求来自一个未修改的文档。 2.5 ETag/If-Match/If-None-MatchETag是请求资源在服务器的唯一标识，浏览器可以根据ETag值缓存数据。在再次请求时通过If-None-Match携带上次的ETag值，如果值不变，则返回304，如果改变你则返回新的内容。 需要注意的是，ETag和If-None-Match的值均为双引号包裹的。 验证步骤与Last-Modified相似。执行node cache-ETag.js即可。此处不再详述。 If-Match判断逻辑逻辑与If-None-Match相反。 最后，ETag的优先级高于Last-Modified。当ETag和Last-Modified，ETag优先级更高\b，但不会忽略Last-Modified，需要服务端实现。验证如下，其中服务端判断优先级： 执行node cache-ETag+Last-Modified.js。服务端会在资源的响应头中，同时设置ETag和Last-Modified。如下图： 刷新浏览器，会发现index.html请求时304。查看node日志，会看到ETag生效。如下： 三、缓存的优缺点好了，通过长长的第二部分，我们\b简单介绍了一下HTTP Cache的基础知识。下面我再汇总一下各类缓存之间的优缺点吧。如下表所示： 缓存头部 优点 缺点 Expires 1. HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用。 2. 简单易用，通过绝对时间标识失效时间。 1. 时间为服务器返回的时间，如果本地时间与服务器时间不一致，则可能会出现问题。（如上述我们通过修改本地时间是缓存失效。） 2. 存在版本问题，在资源过期之前如果\b对资源进行修改，客户端都是无法获知的。 Cache-Control 1. \bHTTP 1.1的内容，以相对时间标识失效时间，解决了Expires服务器和客户端相对时间的问题。 2. 支持的指令较多，可以根据需要进行相应的配置。 1. HTTP 1.1 才有的内容，不适用于HTTP 1.0 。 2. 与Expires类似，存在版本问题，在资源过期之前如果\b对资源进行修改，客户端都是无法获知的。 Last-Modified 1. 不存在版本问题，每次都会跟服务器进行校验，符合则304不返回资源，不符合则重新返回资源。 1. 以时刻作为标识，精确到秒，无法识别一秒内进行多次修改的情况。 2. 只要资源\b被修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。 ETag 1. 不存在版本问题，每次都会跟服务器进行校验，符合则304不返回资源，不符合则重新返回资源。 2. \b可以更加精确的判断资源是否被修改。 3. 可以识别一秒内多次修改的情况。 1. 计算ETag\b值会对性能造成一定消耗。 2. 分布式服务器存储的情况下，需要保证计算ETag的算法一致。如果不一致，会导致资源在不同服务器上验证不通过。 四、最佳实践从上面各类缓存的优缺点可以看出，每一种缓存都不是完美的。所以建议像下面这样做： 不要缓存HTML，避免缓存后用户无法及时获取到更新内容。 使用Cache-Control和ETag来控制HTML中所使用的静态资源的缓存。一般是将Cache-Control的max-age设成一个比较大的值，然后用ETag进行验证。 使用签名或者版本来区分静态资源。\b这样静态资源会生成不同的资源访问链接，不会产生修改之后无法感知的情况。 还有两个本文没有介绍的内容，但是不建议大家使用： 使用\bHTML的meta标签来指定缓存行为 使用查询字符串来避免缓存。因为缓存有一些已知的问题，使用查询字符串会导致有些代理服务器不缓存资源。 五、小试牛刀，看看你掌握了没有？如果首次访问localhost:1030时，页面中 avatar.png 响应头信息如下： 123456HTTP/1.1 200 OKCache-Control: no-cacheContent-Type: image/pngLast-Modified: Tue, 16 Oct 2018 11:42:28 GMTAccept-Ranges: bytesDate: Tue, 16 Oct 2018 15:57:21 GMT 问题1：请问当刷新该页面后，avatar.png如何二次加载？ 问题2：如果将上述信息中的Cache-Control设置为 private，那么结果又会如何呢？ 大家先回忆下上面的内容，思考一下。 好了公布答案。 问题1：会带着If-Modified-Since和服务端进行验证。未改变返回304，改变返回200. 问题2：Cache-Control设置为 private，这时候会触发启发式缓存，则再次刷新时，avatar.png命中强缓存，从缓存中换取。 总结好了，文章到此结束，希望能对大家有帮助。 参考链接 MDN | Cache-Control 彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法 由memoryCache和diskCache产生的浏览器缓存机制的思考 A Web Developer’s Guide to Browser Caching 浏览器缓存机制剖析 HTTP 缓存 Are Your Cache-Control Directives Doing What They Are Supposed to Do? Hypertext Transfer Protocol","categories":[],"tags":[]},{"title":"从撒狗粮带你了解WoT连接场景","slug":"从撒狗粮带你了解WoT连接场景","date":"2018-08-29T02:56:56.000Z","updated":"2018-09-20T07:23:56.514Z","comments":true,"path":"2018/08/29/从撒狗粮带你了解WoT连接场景/","link":"","permalink":"http://verymuch.com/2018/08/29/从撒狗粮带你了解WoT连接场景/","excerpt":"歪马是一名IT男，30岁，单身，之前每年的情人节、七夕节、圣诞节…可以说是没少被“撒狗粮”。这不，歪马今年决定要改变这一现状。而故事就是从这里开始的。 为了避免跑题，笔者表示要强势切入，下面我们先简单介绍下物联网和万维物联网。 一、物联网和万维物联网在最近几年里，物联网（Internet of Things，简称IoT）已经成为了在技术和商业上最有前途、最激动人心的发展领域之一。相信大家对于物联网已经或多或少有些了解。大家也一定使用过类似的产品，如可以远程实时查看录像、同步进行语音通话的360智能摄像机；可以远程控制家用电器开关的智能插座；可以智能检测心率和睡眠的智能手表以及其他一系列智能产品。 物联网是一个物理对象系统，其中的电子设备通过各种各样的网络接口进行通信，从而可以被发现、监控、控制交互，最终可以连接到更大的网络。上面所提到的几种产品即可以认为是其中的电子设备。 万维物联网（Web of Things，简称WoT）是物联网的一种实现方式，它主要致力于建立一种通用的语言，从而让不同厂商的智能产品具有彼此实现互相操作的可能。","text":"歪马是一名IT男，30岁，单身，之前每年的情人节、七夕节、圣诞节…可以说是没少被“撒狗粮”。这不，歪马今年决定要改变这一现状。而故事就是从这里开始的。 为了避免跑题，笔者表示要强势切入，下面我们先简单介绍下物联网和万维物联网。 一、物联网和万维物联网在最近几年里，物联网（Internet of Things，简称IoT）已经成为了在技术和商业上最有前途、最激动人心的发展领域之一。相信大家对于物联网已经或多或少有些了解。大家也一定使用过类似的产品，如可以远程实时查看录像、同步进行语音通话的360智能摄像机；可以远程控制家用电器开关的智能插座；可以智能检测心率和睡眠的智能手表以及其他一系列智能产品。 物联网是一个物理对象系统，其中的电子设备通过各种各样的网络接口进行通信，从而可以被发现、监控、控制交互，最终可以连接到更大的网络。上面所提到的几种产品即可以认为是其中的电子设备。 万维物联网（Web of Things，简称WoT）是物联网的一种实现方式，它主要致力于建立一种通用的语言，从而让不同厂商的智能产品具有彼此实现互相操作的可能。 Web比较适合用来建立这样一种通用的语言，它具备以下4个优点： 更容易编程：万维网协议可以很容易地用来读写设备数据，而且特别简单易用，比复杂的物联网协议学起来更快。 更加开放和可扩展：万维网标准如此流行的原因即因为它们是完全开放和免费的。使用它们能够确保数据可以被快速、方便地跨系统转移，可扩展性更高。 能够快速简单部署、维护与集成。 安全和隐私机制使用的更加广泛。 好了，关于\b物联网和万维物联网的基本介绍就到这里了，本文将主要以一种生动有趣的方式着重介绍下WoT的6种连接场景。 二、WoT的连接场景故事继续，为了改变每年都被别人“撒狗粮”情况，歪马决定改变现状。歪马从小比较喜欢小动物，尤其是聪明温顺的狗狗，这回歪马决定养一只狗狗陪伴自己。这样每次被“撒狗粮”时，可以真真切切的撒回去（不管你觉不觉得这逻辑可爱，笔者觉得挺可爱的）。 歪马养了一只短腿小柯基，并为其起名为大屁，因为柯基一扭一扭的屁股甚是可爱。下面我将带着歪马和大屁一起先介绍下WoT的第一种连接场景。 2.1 场景1：通过Web服务进行设备的控制第一个要说的连接场景是通过Web服务进行设备的控制。 身为IT男的歪马和我们大家一样常常从早忙到晚，不能按时回家，这可苦了他的爱犬大屁，因为大屁经常是吃了上顿没下顿。但歪马又不能不限量地给大屁留狗粮，因为这有可能导致大屁进食过量，健康产生问题。 为了解决大屁吃的既准时又不会过量的问题，歪马花费了不少精力，专门开发了一套基于微信的程序，这样无论身在地球上哪个角落，只要能上网，就不会饿着大屁了。 歪马给大屁注册了一个微信号，需要喂食时，歪马会给大屁发送一条“@大屁 过来吃饭啦”的消息。家中的电脑收到后，就会启动一个扬声器。扬声器中会播放歪马呼唤大屁进食的录音，这样大屁听到声音后就会跑过来，坐在狗粮盆前面等着。此时，一个马达启动，打开粮箱上的活门，里面的狗粮会顺着管子落到大屁的盆里。并且在程序内可以设定每次投放的狗粮量，这样也能保证大屁不会变成一条肥狗啦。 说了这么多，大家可能很懵？故事还不错，但这和IoT/WoT有啥关系呢？又该如何理解这一场景呢？ 现在让我们一起来抽象下。 首先，我们考虑下在歪马家里用于喂狗的这个装置包括哪些东西，我们将其想象成一个整体——自动喂狗装置。 自动化喂狗装置组成部分： 电脑：具有Web服务器功能，可以连接到互联网，可以监听事件，用于接受指令。 \b扬声器：用于播放歪马呼唤大屁进食的录音。 狗粮倾倒装置：启动后可以漏出狗粮，并且可以定量投放，\b投放完毕后关闭。 好了，如上，已经有了一个自动化喂狗装置。这个喂狗装置具有Web服务器功能，能够直接连接到互联网，歪马可以通过连接到互联网的设备（如手机或电脑设备上的浏览器或原生应用）向喂狗装置发送命令，喂狗装置收到后就可以自动喂狗啦。 这一场景就是WoT的第一种连接场景：一个具有Web服务器功能的电子设备可以直接连接到互联网，这时，我们可以通过手机或电脑设备上的浏览器或原生应用，借助互联网（如蜂窝网，运营商网络）对\b电子设备进行控制。 连接场景图示如下： 2.2 场景2：通过本地Web服务进行设备的控制上面的连接场景应该很容易理解。下面我们再考虑下\b下面这个场景： 作为IT男的歪马非常喜爱足球，每逢世界杯比赛时，总免不了全神贯注地观看比赛直播。他为自己在卧室里准备了一个大大的液晶电视，这样每当有球赛的时候就能舒舒服服地观看比赛了。如果看比赛的时候，大屁饿了，他又不想错过直播去给大屁倒狗粮，那么很简单他可以打开电脑或者拿出手机，和在公司上班时一样，远程投放狗粮。 但是，\b事情总会有例外，正值世界杯比赛的某个周末，歪马所在小区的网络故障，没法正常使用了。那么大家觉得歪马的喂狗装置还能不能用呢？ 答案当然是肯定的，作为程序员的歪马深知代码鲁棒性的重要性。所以他设计这套系统已经考虑到这种情况了。在没有联网的情况下，也可以支持本地局域网运行，所以只要家里还有电，喂狗装置和他的手机/电脑处于同一个本地网络，那么他依然可以通过手机/电脑进行喂狗装置的控制。这也就是我们所要介绍的第二种连接场景：一个具有Web服务器功能的电子设备，在没有连接到互联网的情况下，我们可以使用手机或者电脑，通过本地网络对电子设备进行控制。 连接场景图示如下： 2.3 场景3：使用蓝牙遥控器进行设备的控制有点时候拿出手机/电脑再进行控制多少有些麻烦，相对而言我们使用的电视遥控器反而更加简单。但是电视之类的遥控器，因为是红外设备，需要对准，而歪马又不能保证能够随时对准喂狗装置的所在。 于是歪马想到了一个点子，他给喂狗装置添加了蓝牙设备，并且使用蓝牙设备制作了一款遥控器，这样只要两个蓝牙设备配对后，在房间内的任意位置（一定范围内）都可以进行设备的控制了。 怎么样，歪马是不是很厉害，他上面所做的这一改变就是\bWoT的第三种连接场景：如果设备存在某种限制不能连接到互联网，那么其可以通过蓝牙等设备进行连接，这样即可通过遥控器对设备进行控制。（当然，红外设备也是可以的，下面我们要介绍的场景与其类似）。 连接场景图示如下： 2.4 场景4：使用感应器进行设备的控制解决了大屁吃饭的问题后，\b还有一个同样重要的问题，那就是喝水的问题。 夏天天气热，狗狗又非常怕热，歪马每天上班都会给大屁倒满满一盆的水，但是回家之后，总会被喝的精光。换个能盛更多水的大盆又怕夏天容易滋生细菌。 为了解决大屁喝水的问题，歪马想到了一个好点子，\b他买了一个水位感应器安装在了水盆内，当大屁把水喝的精光时，水位感应器感应到没有水后，会向水箱发送一个没水的信号，水箱中的控制代理接收到信号后，会打开水箱自动向水盆注入3/4的水。如此一来，歪马只要定期向水箱中添加纯净水就行了，大屁也能放心地喝水啦。 使用感应器进行设备的控制即为WoT的第四种连接场景：利用感应器探测到某一条件到达指定值时，\b设备检测到这一变化后，可以做出相应的动作。 连接场景图示如下： 2.5 场景5：使用网关进行中转场景4中的智能水箱中使用的控制代理属于比较旧的设备，而感应器有时候又不是那么灵敏，可能要等水没有一段时间后才会加水。 于是歪马在想，如果也能够远程进行水箱的控制就好了。由于\b水箱的控制代理和感应器没法直接连接到互联网，于是他在本地网络和互联网之间加入了网关，通过网关来进行中转。这样即使是感应器这样的设备也也能够通过网关连接到互联网，能够实时将水箱中的剩余水量上报到服务器中。歪马可以直接远程查看，当歪马远程喂食的时候\b，如果发现水盆中水量不多时，可以直接定量加满即可。 上面这种使用网关进行中转的方式即为WoT的第五种连接场景：如果存在不能直接连接到互联网的设备或者使用其他协议的设备时，可以通过在本地网络和互联网之间添加网关，借助网关来进行中转。本地设备有状态发生变化时，可以通过网关转换后进行上报。远程有新的指令达到时，也可以通过网关转换后下达给指定设备。 连接场景图示如下： 2.6 场景6：使用云来管理设备机会总是会降临到有准备的人头上。 虽然歪马从来没有想过为大屁开发的这款智能喂狗装置会给自己带来什么。但这款喂狗装置被商界人士得知后，有人联系歪马，想要进行投资量产。歪马当然欣然接受了合作。于是和合作公司开始讨论喂狗装置如何量产，还有哪些功能需要优化。 其中就有这样一个问题，如果设备被量产的话，不可能每个人的喂狗装置都和自己的控制设备直接连接，这时候就需要有一个云服务器来进行云端存储。每个人的喂狗装置通过用户自己的账号，连接到云端，喂狗装置的各部件会实时将自身的状态同步到云端。用户打开控制设备后，会同步各部件的状态。用户可以通过控制设备下发指令，指令通过云端进行中转，然后下发到喂狗装置。这样做还有一个好处，如果喂狗装置出现临时断线等情况时，控制设备所发送的指令也会在云端临时存储，在装置接入后继续下达指令。 上面这种情况即为WoT的第六种连接场景：云端就绪的设备直接连接到云端，其自身的状态会在云端做个镜像，这个镜像会充当一个代理，用于接收远程控制设备的指令。 连接场景图示如下： 三、多场景共存上面分别介绍了WoT的6种独立连接场景，\b其实这些连接场景是可以共存的，汇总到一起后如下图所示： 好了，WoT的连接场景介绍完毕了。最后问一句\b，你觉得歪马这狗粮撒的如何？ 致谢感谢奇舞团小伙伴李冬杰对本文的审校与意见。 参考文献 英国IT男因工作繁忙写程序远程喂狗 WoT技术架构（草案） [书]从物联到万联","categories":[],"tags":[{"name":"WoT","slug":"WoT","permalink":"http://verymuch.com/tags/WoT/"}]},{"title":"W3C标准导读之【标准化过程】","slug":"W3C标准导读之标准化过程","date":"2018-08-19T13:40:37.000Z","updated":"2018-08-27T13:07:01.950Z","comments":true,"path":"2018/08/19/W3C标准导读之标准化过程/","link":"","permalink":"http://verymuch.com/2018/08/19/W3C标准导读之标准化过程/","excerpt":"本文作者：高峰，360奇舞团前端工程师，W3C性能工作组成员，同时参与WOT工作组的学习。 一、引言W3C的标准很多，你看或不看，它都在那，有增无减。既然如此，那我们为什么要读标准呢？笔者认为可能有以下4点原因：","text":"本文作者：高峰，360奇舞团前端工程师，W3C性能工作组成员，同时参与WOT工作组的学习。 一、引言W3C的标准很多，你看或不看，它都在那，有增无减。既然如此，那我们为什么要读标准呢？笔者认为可能有以下4点原因： 有一颗贡献标准的心，想要通过自己的努力为标准作出贡献； 对知识内容有执着的追求，想通过标准来彻底了解某些知识点； 熟悉标准已经成为我们应聘时的加分项甚至是基本项，我们不得不学； 当然，我们还可以通过学习W3C标准来提升英语阅读能力以及写作缜密性。 或许你阅读标准的理由不是上面之一，但我们总归是要开始读标准了，不是吗？开始之前，我们准确地了解下W3C是什么。 万维网联盟（World Wide Web Consortium，以下简称W3C）创建于1994年，是Web技术领域最具权威和影响力的国际中立性技术标准机构。它的使命是开发促进万维网发展、确保万维网互操作性的通用协议，从而尽展万维网的全部潜能。 W3C一共有36个工作组（截止至2018年8月21日，本文书写时间），已经制定了200多个标准。如此多的工作组是如何有序而又保证质量地完成如此多的标准制定的呢？正所谓没有规矩不成方圆，如此庞大的工作必然需要一个准则，所以W3C制定了流程文档1。该文档描述了W3C的组织结构以及为完成W3C自身使命而履行的职责和职能相关的流程。 流程文档的主要受众是标准制定相关成员，但是其中也有一部分内容有助于作为读者的我们理清阅读的思路，笔者即将这一部分提取出来，以供大家阅读。 那么，我们先从简单了解Web技术标准化的过程概览开始吧。 二、Web技术标准化过程概览通常情况下，W3C标准的标准化过程包括以下几步： 首先，有人开始对某个特定的话题产生兴趣。 当这个特定话题的关注度越来越高时，W3C主任会宣布为一个或多个兴趣组以及工作组开发提案章程。W3C成员审查提案章程。 当W3C内部有人支持在某个被关注的主题上投入资源时，W3C主任会批准成立工作组，该小组正式开始工作。 工作组章程包含了每个小组期望的可交付成果，工作组会按照这一期望建立标准和指南。 这些标准和指南需要经过反复的修订和审核，要接受W3C成员和大众的审核，且要满足实现和互操作性方面的要求。 最后，顾问委员会审查成熟的技术报告，如果通过则发布为标准 上述是标准产生的一个简要过程，具体的过程包括标准化过程中所涉及的组以及标准所经历的版本（或成熟度等级）下面会详细介绍。我们先从标准化过程中所涉及的组开始。 三、W3C中的组上面的标准化流程概览中提到了很多参与者，下面我们来具体介绍下，W3C标准制作过程中所涉及的各个组，主要包括以下5个。 顾问委员会 顾问委员会（Advisory Committee，简称AC）由来自各个成员组织2的代表组成，每个组织一个代表（参见AC列表3）。 他们主要负责以下工作： 在每次的顾问委员会会议上审查W3C的计划; 审查W3C主任（W3C Director）给出的正式提案，包括章程提案、提案标准以及提案的流程文档。 推选董事会（Advisory Board）成员而非董事会主席 推选技术架构组的大多数参与者 董事会 董事会（Advisory Board，简称AB）创建于1998年3月，它会就战略、管理、法律事务、流程和冲突解决等问题向团队提供持续指导。也通过记录顾问委员会会议之间提出的问题，征求成员们对此类问题的意见以及提出解决这些问题的行动，为成员们提供服务。 与顾问委员会的主要不同在于董事会在W3C内没有决策权，它的作用是仅限于咨询。 技术架构组 技术架构组（Technical Architecture Group，简称TAG）创建于2001年2月，主要任务是管理Web架构，可以分为以下三个方面： 建立Web架构原则相关共识，并形成文档，在必要的时候对这些原则进行解释和阐明。 解决涉及TAG的通用Web架构问题; 帮助协调W3C内外部跨技术架构的开发。 工作组 工作组（Working Group）是某一Web技术的具体制定者，通常会产生一系列的可交付成果（例如标准跟踪技术报告、软件、测试套件以及其他组可交付成果的审查）。 兴趣组 兴趣小组的主要目标是将有意评估潜在Web技术和策略的人员聚集在一起，便于他们交流想法。 四、技术报告的成熟度等级说完标准化过程中所涉及的组，我们再来了解一下标准所经历的版本，用流程文档中的话说是技术报告的成熟度等级。技术报告即为上述提到的工作组所产生的标准或指南等，可以在技术报告页4查看已发布的技术报告。 W3C的技术报告的成熟度划分为如下6个等级。 工作草案（Working Draft，简称WD） 工作草案是W3C发布的文档，供W3C成员，公众和其他技术组织审查。大多数工作草案都旨在推进成为标准，如果不再想推进成标准，则应当发布为工作组笔记。 值得一提的是，工作组草案不一定代表整个工作组的共识，并且也不代表W3C已经认可，因为现阶段W3C或其成员仅是同意其在某个通用技术领域成立工作组。 候选标准（Candidate Recommendation，简称CR） 如果工作草案满足了对应工作组的技术要求或者没有再进行实质性的修改（#如何区分实质性的改动，见下文#），并且已经通过广泛的审查（工作草案中提到的审查，加粗部分），则可以发布成为候选标准。发布为候选标准则意味着： 告诉广大社区，是时候进行最后的审查了 收集实现方案 由顾问委员会开始正式审查，这时这一标准可能有三个结果：推荐为W3C标准、返回工作组继续完善或者废弃。 注：候选标准已经有望成为标准，这一阶段如果再有改动，需要给出改动的原因。 提案标准（Proposed Recommendation，简称PR） 提案标准表示该文档已经被W3C主任所接受并认为其质量足以成为正式的W3C标准。进入这一阶段后会给顾问委员会设定一个具体的审查截止日期。这一阶段不能再有实质性的改动了，如果有的话只能再发布一个新的工作草案和候选标准。 正式标准（W3C Recommendation，简称REC） W3C正式标准是一份规范、一套指南或要求，已达成广泛的共识，并且获得了W3C成员和主任的认可。W3C会推荐其作为Web标准进行实施。 虽然经过了重重的努力和审查才形成了每一份标准，但是人无完人，标准也可能会有一定的缺陷。随着科技的进步，正式的标准有可能会演变成以下4种： 修订标准：工作组可能会对标准进行编辑或者其他细微的改动，W3C会发布一个新的修订版本。 编辑标准：该标准添加了不包含新特性的实质性改动时，并且该标准已经不属于现有的活跃工作组，由W3C团队完成整个制作过程。 过时标准：当一个标准缺乏足够的市场相关性来推进其实施，但其本身没有本质的问题需要被废弃时，就会变成一个过时标准。如果过时标准重新获得了足够的市场相关性，W3C可以将其恢复到推荐状态。 被取代的标准：当一个标准被W3C推荐用一个更新后的版本取代时，该标准则变为被取代的标准。 废弃标准（Rescinded Recommendation） 废弃标准是W3C不再认可、同时认为其不太可能再恢复到标准状态的标准。 工作组/兴趣组笔记（Working Group Note/Interest Group Note，简称笔记） 工作组/兴趣组笔记主要是为了记录有用但不会成为标准的文档，或者是没能成为标准时所要放弃的工作。 此外，工作组和兴趣小组可能还会提供“编辑草案”。需要知道的是，编辑草案没有任何官方声明，没有在组内达成共识，也没有W3C的认可。这一版本会因为小组成员的讨论而持续变动。 如何区分实质性改动和编辑性改动？前面提到了实质性改以及与其对应的编辑性改动，那么如何区分一个改动究竟是哪种改动呢？ 标准的改动可以分为以下四类。其中前两类是编辑性改动，后两类是实质性改动。 无文字内容改动：包括修复损坏的链接、样式文件或无效标记。 不影响一致性的改动：实现者不会将其理解成架构、互操作性要求或者实现方案更改的改动。 可能影响一致性的改动 符合要求的数据、处理器或者其他代理在新版本中不再符合要求。 不符合要求的数据、处理器或者其他代理在新版本中符合要求。 清除了规范中含糊不清的或不明确的部分。 新特性：添加了一个新功能或者元素等。 五、完整的开发流程上面介绍完了标准化过程中所涉及的组、标准所经历的版本，相信大家从中已经能对标准的开发流程有一定的了解了。下面我们再图文并茂地完整地梳理一遍标准的开发流程。 一份技术报告推进成标准的过程，主要遵循下面这些步骤，可以结合下图查看： 发布初版工作草案 发布0个及以上的修订版工作草案 发布候选标准 发布提案标准 发布W3C标准 可能会发布的编辑标准和修订标准 上面提到正式的标准也会存在一定的变动，对已有标准进行编辑所遵循的过程可以参见下图黑色加粗部分。 从图中可以看出，如果改动不是实质性改动，则直接发布一个修订版本。如果是实质性改动，但没有增加新特性，则可以直接发布一个新的候选标准。如果是新的特性则需要从工作草案阶段进行整个开发流程。 总结至此介绍完了关于W3C标准的标准化流程，本文谨代表笔者对于万维网联盟流程文档的理解，加之流程文档也会不断地进行更新，所以如本文与流程文档有冲突，请以文档为主。 文内链接 https://www.w3.org/2018/Process-20180201/#tag-participation https://www.w3.org/Consortium/Member/List https://www.w3.org/Member/ACList https://www.w3.org/TR/ 参考链接 万维网联盟流程文档","categories":[],"tags":[]},{"title":"CSS性能优化的8个技巧","slug":"CSS性能优化的8个技巧","date":"2018-07-22T15:49:10.000Z","updated":"2018-08-13T10:50:43.241Z","comments":true,"path":"2018/07/22/CSS性能优化的8个技巧/","link":"","permalink":"http://verymuch.com/2018/07/22/CSS性能优化的8个技巧/","excerpt":"本文作者：高峰，360奇舞团前端工程师，W3C性能工作组成员，同时参与WOT工作组的学习。 我们都知道对于网站来说，性能至关重要，CSS作为页面渲染和内容展现的重要环节，影响着用户对整个网站的第一体验。因此，与其相关的性能优化是不容忽视的。 对于性能优化我们常常在项目完成时才去考虑，经常被推迟到项目的末期，甚至到暴露出严重的性能问题时才进行性能优化，相信大多数人对此深有体会。 笔者认为，为了更多地避免这一情况，首先要重视起性能优化相关的工作，将其贯穿到整个产品设计与开发中。其次，就是了解性能相关的内容，在项目开发过程中，自然而然地进行性能优化。最后，也是最最重要的，那就是从现在开始实施优化。 推荐大家阅读下奇舞周刊之前推的《嗨，送你一张Web性能优化地图》1这篇文章，能够帮助大家对性能优化需要做的事以及需要考虑的问题形成一个整体的概念。 本文将会详细介绍CSS性能优化相关的技巧，笔者将它们分为实践型和建议型两类，共8个小技巧。实践型技巧能够快速地应用在项目中，能够很好地提升性能，也是笔者经常使用的，建议大家尽快在项目中实践。建议型技巧中，有的可能对性能影响并不显著，有的平时大家也并不会那么用，所以笔者不会着重讲述，读者们可以根据自身情况了解一下即可。","text":"本文作者：高峰，360奇舞团前端工程师，W3C性能工作组成员，同时参与WOT工作组的学习。 我们都知道对于网站来说，性能至关重要，CSS作为页面渲染和内容展现的重要环节，影响着用户对整个网站的第一体验。因此，与其相关的性能优化是不容忽视的。 对于性能优化我们常常在项目完成时才去考虑，经常被推迟到项目的末期，甚至到暴露出严重的性能问题时才进行性能优化，相信大多数人对此深有体会。 笔者认为，为了更多地避免这一情况，首先要重视起性能优化相关的工作，将其贯穿到整个产品设计与开发中。其次，就是了解性能相关的内容，在项目开发过程中，自然而然地进行性能优化。最后，也是最最重要的，那就是从现在开始实施优化。 推荐大家阅读下奇舞周刊之前推的《嗨，送你一张Web性能优化地图》1这篇文章，能够帮助大家对性能优化需要做的事以及需要考虑的问题形成一个整体的概念。 本文将会详细介绍CSS性能优化相关的技巧，笔者将它们分为实践型和建议型两类，共8个小技巧。实践型技巧能够快速地应用在项目中，能够很好地提升性能，也是笔者经常使用的，建议大家尽快在项目中实践。建议型技巧中，有的可能对性能影响并不显著，有的平时大家也并不会那么用，所以笔者不会着重讲述，读者们可以根据自身情况了解一下即可。 在正式开始之前，需要大家对于浏览器的工作原理2有些一定的了解，需要的小伙伴可以先简单了解下。 下面我们开始介绍实践型的4个优化技巧，先从首屏关键CSS开始。 1. 内联首屏关键CSS（Critical CSS）性能优化中有一个重要的指标——首次有效绘制（First Meaningful Paint，简称FMP）即指页面的首要内容（primary content）出现在屏幕上的时间。这一指标影响用户看到页面前所需等待的时间，而内联首屏关键CSS（即Critical CSS，可以称之为首屏关键CSS）能减少这一时间。 大家应该都习惯于通过link标签引用外部CSS文件。但需要知道的是，将CSS直接内联到HTML文档中能使CSS更快速地下载。而使用外部CSS文件时，需要在HTML文档下载完成后才知道所要引用的CSS文件，然后才下载它们。所以说，内联CSS能够使浏览器开始页面渲染的时间提前，因为在HTML下载完成之后就能渲染了。 既然内联CSS能够使页面渲染的开始时间提前，那么是否可以内联所有的CSS呢？答案显然是否定的，这种方式并不适用于内联较大的CSS文件。因为初始拥塞窗口3存在限制（TCP相关概念，通常是 14.6kB，压缩后大小），如果内联CSS后的文件超出了这一限制，系统就需要在服务器和浏览器之间进行更多次的往返，这样并不能提前页面渲染时间。因此，我们应当只将渲染首屏内容所需的关键CSS内联到HTML中。 既然已经知道内联首屏关键CSS能够优化性能了，那下一步就是如何确定首屏关键CSS了。显然，我们不需要手动确定哪些内容是首屏关键CSS。Github上有一个项目Critical CSS4，可以将属于首屏的关键样式提取出来，大家可以看一下该项目，结合自己的构建工具进行使用。当然为了保证正确，大家最好再亲自确认下提取出的内容是否有缺失。 不过内联CSS有一个缺点，内联之后的CSS不会进行缓存，每次都会重新下载。不过如上所说，如果我们将内联后的文件大小控制在了14.6kb以内，这似乎并不是什么大问题。 如上，我们已经介绍了为什么要内联关键CSS以及如何内联，那么剩下的CSS我们怎么处理好呢？建议使用外部CSS引入剩余CSS，这样能够启用缓存，除此之外还可以异步加载它们。 2. 异步加载CSSCSS会阻塞渲染，在CSS文件请求、下载、解析完成之前，浏览器将不会渲染任何已处理的内容。有时，这种阻塞是必须的，因为我们并不希望在所需的CSS加载之前，浏览器就开始渲染页面。那么将首屏关键CSS内联后，剩余的CSS内容的阻塞渲染就不是必需的了，可以使用外部CSS，并且异步加载。 那么如何实现CSS的异步加载呢？有以下四种方式可以实现浏览器异步加载CSS。 第一种方式是使用JavaScript动态创建样式表link元素，并插入到DOM中。 123456// 创建link标签const myCSS = document.createElement( \"link\" );myCSS.rel = \"stylesheet\";myCSS.href = \"mystyles.css\";// 插入到header的最后位置document.head.insertBefore( myCSS, document.head.childNodes[ document.head.childNodes.length - 1 ].nextSibling ); 第二种方式是将link元素的media属性设置为用户浏览器不匹配的媒体类型（或媒体查询），如media=&quot;print&quot;，甚至可以是完全不存在的类型media=&quot;noexist&quot;。对浏览器来说，如果样式表不适用于当前媒体类型，其优先级会被放低，会在不阻塞页面渲染的情况下再进行下载。 当然，这么做\b只是为了实现CSS的异步加载，\b别忘了在文件加载完成之后，将media的值设为screen或all，从而让浏览器开始解析CSS。 1&lt;link rel=\"stylesheet\" href=\"mystyles.css\" media=\"noexist\" onload=\"this.media='all'\"&gt; 与第二种方式相似，我们还可以通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将rel改回去。 1&lt;link rel=\"alternate stylesheet\" href=\"mystyles.css\" onload=\"this.rel='stylesheet'\"&gt; 上述的三种方法都较为古老。现在，rel=”preload”5这一Web标准指出了如何异步加载资源，包括CSS类资源。 1&lt;link rel=\"preload\" href=\"mystyles.css\" as=\"style\" onload=\"this.rel='stylesheet'\"&gt; 注意，as是必须的。忽略as属性，或者错误的as属性会使preload等同于XHR请求，浏览器不知道加载的是什么内容，因此此类资源加载优先级会非常低。as的可选值可以参考上述标准文档。 看起来，rel=&quot;preload&quot;\u001d的用法和上面两种没什么区别，都是通过更改某些属性，使得浏览器异步加载CSS文件但不解析，直到加载完成并将修改还原，然后开始解析。 但是它们之间其实有一个很重要的不同点，那就是使用preload，比使用不匹配的media方法能够更早地开始加载CSS。所以尽管这一标准的支持度还不完善，仍建议优先使用该方法。 该标准现在已经是候选标准，相信浏览器会逐渐支持该标准。\b在各浏览器的支持度如下图所示。 从上图可以看出这一方法\b在现在的浏览器中支持度不算乐观，不过我们可以通过loadCSS6进行polyfill，所以支持不支持，这都不是事儿。 3. 文件压缩性能优化时有一个最容易想到，也最常使用的方法，那就是文件压缩，这一方案往往效果显著。 文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现地尤为明显。相信大家都早已习惯对CSS进行压缩，现在的构建工具，如webpack、gulp/grunt、rollup等也都支持CSS压缩功能。压缩后的文件能够明显减小，可以大大降低了浏览器的加载时间。 4. 去除无用CSS虽然文件压缩能够降低文件大小。但CSS文件压缩通常只会去除无用的空格，这样就限制了CSS文件的压缩比例。那是否还有其他手段来精简CSS呢？答案显然是肯定的，如果压缩后的文件仍然超出了预期的大小，我们可以试着找到并删除代码中无用的CSS。 一般情况下，会存在这两种无用的CSS代码：一种是不同元素或者其他情况下的重复代码，一种是整个页面内没有生效的CSS代码。对于前者，在编写的代码时候，我们应该尽可能地提取公共类，减少重复。对于后者，在不同开发者进行代码维护的过程中，总会产生不再使用的CSS的代码，当然一个人编写时也有可能出现这一问题。而这些无用的CSS代码不仅会增加浏览器的下载量，还会增加浏览器的解析时间，这对性能来说是很大的消耗。所以我们需要找到并去除这些无用代码。 当然，如果手动删除这些无用CSS是很低效的。我们可以借助Uncss7库来进行。Uncss可以用来移除样式表中的无用CSS，并且支持多文件和JavaScript注入的CSS。 前面已经说完了实践型的4个优化技巧，下面我们介绍下建议型的4个技巧。 1. 有选择地使用选择器大多数朋友应该都知道CSS选择器的匹配是从右向左进行的，这一策略导致了不同种类的选择器之间的性能也存在差异。相比于#markdown-content-h3，显然使用#markdown .content h3时，浏览器生成渲染树（render-tree）所要花费的时间更多。因为后者需要先找到DOM中的所有h3元素，再过滤掉祖先元素不是.content的，最后过滤掉.content的祖先不是#markdown的。试想，如果嵌套的层级更多，页面中的元素更多，那么匹配所要花费的时间代价自然更高。 不过现代浏览器在这一方面做了很多优化，不同选择器的性能差别并不明显，甚至可以说差别甚微。此外不同选择器在不同浏览器中的性能表现8也不完全统一，在编写CSS的时候无法兼顾每种浏览器。鉴于这两点原因，我们在使用选择器时，只需要记住以下几点，其他的可以全凭喜好。 保持简单，不要使用嵌套过多过于复杂的选择器。 通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。 不要使用类选择器和ID选择器修饰元素标签，如h3#markdown-content，这样多此一举，还会降低效率。 不要为了追求速度而放弃可读性与可维护性。 如果大家对于上面这几点还存在疑问，笔者建议大家选择以下几种CSS方法论之一（BEM9，OOCSS10，SUIT11，SMACSS12，ITCSS13，Enduring CSS14等）作为CSS编写规范。使用统一的方法论能够帮助大家形成统一的风格，减少命名冲突，也能避免上述的问题，总之好处多多，如果你还没有使用，就赶快用起来吧。 Tips：为什么CSS选择器是从右向左匹配的？CSS中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器不匹配时提升效率。从右向左匹配就是为了达成这一目的的，通过这一策略能够使得CSS选择器在不匹配的时候效率更高。这样想来，在匹配时多耗费一些性能也能够想的通了。 2. 减少使用昂贵的属性在浏览器绘制屏幕时，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价。当页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写CSS时，我们应该尽量减少使用昂贵属性，如box-shadow/border-radius/filter/透明度/:nth-child等。 当然，并不是让大家不要使用这些属性，因为这些应该都是我们经常使用的属性。之所以提这一点，是让大家对此有一个了解。当有两种方案可以选择的时候，可以优先选择没有昂贵属性或昂贵属性更少的方案，如果每次都这样的选择，网站的性能会在不知不觉中得到一定的提升。 3. 优化重排与重绘在网站的使用过程中，某些操作会导致样式的改变，这时浏览器需要检测这些改变并重新渲染，其中有些操作所耗费的性能更多。我们都知道，当FPS为60时，用户使用网站时才会感到流畅。这也就是说，我们需要在16.67ms内完成每次渲染相关的所有操作，所以我们要尽量减少耗费更多的操作。 3.1 减少重排重排会导致浏览器重新计算整个文档，重新构建渲染树，这一过程会降低浏览器的渲染速度。如下所示，有很多操作会触发重排，我们应该避免频繁触发这些操作。 改变font-size和font-family 改变元素的内外边距 通过JS改变CSS类 通过JS获取DOM元素的位置相关属性（如width/height/left等） CSS伪类激活 滚动滚动条或者改变窗口大小 此外，我们还可以通过CSS Trigger15查询哪些属性会触发重排与重绘。 值得一提的是，某些CSS属性具有更好的重排性能。如使用Flex时，比使用inline-block和float时重排更快，所以在布局时可以优先考虑Flex。 3.2 避免不必要的重绘当元素的外观（如color，background，visibility等属性）发生改变时，会触发重绘。在网站的使用过程中，重绘是无法避免的。不过，浏览器对此做了优化，它会将多次的重排、重绘操作合并为一次执行。不过我们仍需要避免不必要的重绘，如页面滚动时触发的hover事件，可以在滚动的时候禁用hover事件，这样页面在滚动时会更加流畅。 此外，我们编写的CSS中动画相关的代码越来越多，我们已经习惯于使用动画来提升用户体验。我们在编写动画时，也应当参考上述内容，减少重绘重排的触发。除此之外我们还可以通过硬件加速16和will-change17来提升动画性能，本文不对此展开详细介绍，感兴趣的小伙伴可以点击链接进行查看。 最后需要注意的是，用户的设备可能并没有想象中的那么好，至少不会有我们的开发机器那么好。我们可以借助Chrome的开发者工具进行CPU降速，然后再进行相关的测试，降速方法如下图所示。 如果需要在移动端访问的，最好将速度限制更低，因为移动端的性能往往更差。 4. 不要使用@import最后提一下，不要使用@import引入CSS，相信大家也很少使用。 不建议使用@import主要有以下两点原因。 首先，使用@import引入CSS会影响浏览器的并行下载。使用@import引用的CSS文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。这就导致浏览器无法并行下载所需的样式文件。 其次，多个@import会导致下载顺序紊乱。在IE中，@import会引发资源文件的下载顺序被打乱，即排列在@import后面的js文件先于@import下载，并且打乱甚至破坏@import自身的并行下载。 所以不要使用这一方法，使用link标签就行了。 总结至此，我们介绍完了CSS性能优化的4个实践型技巧和4个建议型技巧，在了解这些技巧之后，CSS的性能优化从现在就可以开始了。不要犹豫了，尽快开始吧。 致谢特别感谢@anjia(安佳)、@刘宇晨、@hxl(黄小璐)、@刘观宇的辛苦审校，感谢你们对于文章结构和内容提出的宝贵建议。 文内链接 https://mp.weixin.qq.com/s/C2Zx3KPNPkgj-aHnOY43Iw https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/ https://tylercipriani.com/blog/2016/09/25/the-14kb-in-the-tcp-initial-window/ https://github.com/filamentgroup/criticalCSS https://www.w3.org/TR/preload/ https://github.com/filamentgroup/loadCSS/tree/v2.0.1#loadcss https://github.com/uncss/uncss https://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/#h-H1_1 https://en.bem.info/methodology/quick-start/ http://oocss.org/ https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md https://smacss.com/ https://www.xfive.co/blog/itcss-scalable-maintainable-css-architecture/ http://ecss.io/ https://csstriggers.com/ https://www.sitepoint.com/introduction-to-hardware-acceleration-css-animations/ https://drafts.csswg.org/css-will-change/ 参考文章 Efficiently Rendering CSS How to write CSS for a great performance web application CSS performance revisited: selectors, bloat and expensive styles Avoiding Unnecessary Paints Five CSS Performance Tools to Speed up Your Website How and Why You Should Inline Your Critical CSS Render blocking css Modern Asynchronous CSS Loading Preload","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://verymuch.com/tags/CSS/"}]},{"title":"如何清除行内元素之间的HTML空白","slug":"如何清除行内元素之间的HTML空白","date":"2018-05-23T10:00:48.000Z","updated":"2018-08-13T10:50:37.603Z","comments":true,"path":"2018/05/23/如何清除行内元素之间的HTML空白/","link":"","permalink":"http://verymuch.com/2018/05/23/如何清除行内元素之间的HTML空白/","excerpt":".Resolve { width: 90%; border: 1px solid #dd4b39; color: white; } .Resolve span { display:inline-block; width: 50%; } .Resolve span:first-child { height: 40px; background: #37b8ea; } .Resolve span:last-child { height: 30px; background: #5cb767; } /* 解决方案2 */ .Resolve2 { font-size: 0; } .Resolve2 span { font-size: 14px; } /* 解决方案3 */ .Resolve3 span:last-child { margin-left: -0.333333em; } /* 解决方案4 */ .Resolve4 { letter-spacing: -0.333333em; } .Resolve4 span { letter-spacing: 0; } 前言相信大家应该都遇到过下面这个问题：“HTML源码中行内元素之间的空白显示在了屏幕上”。可能大家都有自己的小技巧来消除这些意料之外的空白。但是方法有很多，有时候不能满足于一种解法，毕竟不同的方法是有优劣的。就像我之前一直用的方法，今天总结了之后才发现还有更好的方法。废话不多说，接下来我给大家总结一下消除行内元素HTML源码空白的小技巧。 下文中以一个div中的两个span标签为例。我们将两个div内的两个span设为display:inline-block;width:50%;，会发现两个span元素并没有在同一行，这就是源码中的空白导致的。 示例代码如下： 左侧行内元素 右侧行内元素","text":".Resolve { width: 90%; border: 1px solid #dd4b39; color: white; } .Resolve span { display:inline-block; width: 50%; } .Resolve span:first-child { height: 40px; background: #37b8ea; } .Resolve span:last-child { height: 30px; background: #5cb767; } /* 解决方案2 */ .Resolve2 { font-size: 0; } .Resolve2 span { font-size: 14px; } /* 解决方案3 */ .Resolve3 span:last-child { margin-left: -0.333333em; } /* 解决方案4 */ .Resolve4 { letter-spacing: -0.333333em; } .Resolve4 span { letter-spacing: 0; } 前言相信大家应该都遇到过下面这个问题：“HTML源码中行内元素之间的空白显示在了屏幕上”。可能大家都有自己的小技巧来消除这些意料之外的空白。但是方法有很多，有时候不能满足于一种解法，毕竟不同的方法是有优劣的。就像我之前一直用的方法，今天总结了之后才发现还有更好的方法。废话不多说，接下来我给大家总结一下消除行内元素HTML源码空白的小技巧。 下文中以一个div中的两个span标签为例。我们将两个div内的两个span设为display:inline-block;width:50%;，会发现两个span元素并没有在同一行，这就是源码中的空白导致的。 示例代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 1234567891011121314151617.Resolve &#123; width: 90%; border: 1px solid #dd4b39; color: white;&#125;.Resolve span &#123; display:inline-block; width: 50%;&#125;.Resolve span:first-child &#123; height: 40px; background: #37b8ea;&#125;.Resolve span:last-child &#123; height: 30px; background: #5cb767;&#125; 解决方案1：源码中直接就写成一行相信大家看到这个解决方案的时候，会想这不是废话嘛。有时候我们就是为了代码的美观，才将两个span标签分两行显示的，写在一行根本就没解决问题好不好？ 不过，我觉得这并不是废话，之所以将其列为一种解决方案，是防止有的人不知道是什么原因导致的空白的显示。知道了这个原因，如果两个行内元素的横向宽度(此处指代码宽度)不大，写在一行也算是最快最直接的解决方法。 示例代码如下： 左侧行内元素右侧行内元素 HTML： 123&lt;div class=\"Resolve Resolve1\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt;&lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; 解决方案2：font-size: 0; （笔者一直使用的方法）问题中span标签之间的空白是因为换行符/Tab制表符/空格等产生的间隔，并且据笔者测试，得出这个距离是字体大小的1/3倍（请先记住这个值）。那么既然空格和字体大小font-size相关。那么也可以通过字体大小来消除这个空隙。 在父级元素上设置font-size: 0;，然后再在内部的span设置需要的字体大小即可。 示例代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve2\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 123456.Resolve2 &#123; font-size: 0;&#125;.Resolve2 span &#123; font-size: 14px;&#125; 这种情况在内部的行内元素字体大小比较统一时，处理起来较为方便，但如果包含的行内元素中存在多种字体大小，需要一一指定，较为繁琐。不过往往这种时候内部的多种字体大小也是单独指定。可以根据具体场景决定是否使用该方案。 解决方案3：margin-left设为负值如果行内元素为块级行内元素，则可以使用margin属性来抵消空白。在【解决方案2】中有提到行内元素之间的距离是字体大小的1/3倍。所以我们只需要将第二个span元素的margin-left设置为-0.333333em即可。 示例代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve3\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 123.Resolve3 span:last-child &#123; margin-left: -0.333333em;&#125; 不过从上面可以看出，最右边还会存在一点点的白边误差。这是由于margin-left的计算精度导致的。 解决方案4：letter-spacing消除文字间距离同方案2、方案3，我们还可以通过letter-spacing改变行内元素之间空隙的大小，将letter-spacing设为-0.333333em即可。但是与font-size一样，改变letter-spacing时会改变内部子元素的间隙，需要手动矫正。 示例代码如下： 左侧行内元素 右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve4\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt; &lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; CSS： 123456.Resolve4 &#123; letter-spacing: -0.333333em;&#125;.Resolve4 span &#123; letter-spacing: 0;&#125; 解决方案5：HTML注释（推荐使用）除了调整css样式之外，我们可以使用html注释来抵消空格，这种情况下不用额外进行css处理。此外笔者觉得还有一个好处，可以加上文字注释，告知为什么会加入注释。 推荐使用该方式，能够有效保持代码整齐，并且不用额外添加css样式。 示例代码如下： 左侧行内元素右侧行内元素 HTML： 1234&lt;div class=\"Resolve Resolve5\"&gt; &lt;span&gt;左侧行内元素&lt;/span&gt;&lt;!-- 消除行内元素换行导致的空白--&gt;&lt;span&gt;右侧行内元素&lt;/span&gt;&lt;/div&gt; 总结以上就是解决行内元素间HTML空白的5种方案，虽然这些方案都不是很理想，但是有时候在特定的情况下，我们往往需要其中之一作为解决方案。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://verymuch.com/tags/CSS/"}]},{"title":"如何在Array.forEach中实现break","slug":"如何在Array-forEach中实现break","date":"2018-02-09T01:39:23.000Z","updated":"2018-08-13T10:50:34.451Z","comments":true,"path":"2018/02/09/如何在Array-forEach中实现break/","link":"","permalink":"http://verymuch.com/2018/02/09/如何在Array-forEach中实现break/","excerpt":"使用for in遍历对象时，会遍历原型链上的可枚举实行，而这些往往会导致一些意想不到的问题。 鉴于上面这个原因，我们团队在之前的几个项目里，通过eslint禁止在代码中使用for in。虽然在大部分情况，我们都能按照约定不使用for in，但是偶尔仍会需要在forEach中中断循环的情况。 有需求就有解决方案。 遇到这个问题时，笔者最简单的思路就是，在forEach外层设置标志位为false，然后在需要break时，将标志位置为true，循环内判断true则直接返回。这样做虽然能够减少循环内部的逻辑处理，但是还是会空跑整个循环，造成资源浪费。 既然自己想的方法是最简单的，并且存在弊端，那么就搜搜其他大神的有哪些思路吧。于是乎就有了以下的总结：","text":"使用for in遍历对象时，会遍历原型链上的可枚举实行，而这些往往会导致一些意想不到的问题。 鉴于上面这个原因，我们团队在之前的几个项目里，通过eslint禁止在代码中使用for in。虽然在大部分情况，我们都能按照约定不使用for in，但是偶尔仍会需要在forEach中中断循环的情况。 有需求就有解决方案。 遇到这个问题时，笔者最简单的思路就是，在forEach外层设置标志位为false，然后在需要break时，将标志位置为true，循环内判断true则直接返回。这样做虽然能够减少循环内部的逻辑处理，但是还是会空跑整个循环，造成资源浪费。 既然自己想的方法是最简单的，并且存在弊端，那么就搜搜其他大神的有哪些思路吧。于是乎就有了以下的总结： 当需要在for in中使用break时，可以采用以下几种方案： 1. throw法抛出一个错误，但是需要注意的是要抛出一个可以与别的错误区别开的错误，这样不会干扰别的代码抛出的错误 12345678910var BreakException = &#123;&#125;;try &#123; [1, 2, 3].forEach(function(v) &#123; console.log(v); //只输出1,2 if (v === 2) throw BreakException; &#125;);&#125; catch (e) &#123; if (e !== BreakException) throw e;&#125; 此法有点丑陋，加了不少代码 2. 空跑循环在外层加一个标识，如果此标识为true，接下来的循环空跑，如下： （空跑循环，也就是笔者自己想到的思路，不过笔者还是Low一点的。） 12345678910111213var breakFlag = false;[1, 2, 3].forEach(function(v) &#123; if (breakFlag === true) &#123; return false; &#125; if (v === 2) &#123; breakFlag = true &#125; console.log(v) //只输出1,2&#125;) 这个方法在外层加了一个变量，为了不污染外层的环境，我们可以使用forEach的第二个参数context，把标识放在这里（高就高在了这里）。 12345678910[1, 2, 3].forEach(function(v) &#123; if (this.breakFlag === true) &#123; return false; &#125; if (v === 2) &#123; this.breakFlag = true &#125; console.log(v) //只输出1,2&#125;, &#123;&#125;); 注意，forEach的第二个参数context，只有在使用非箭头函数时有效，如果是箭头函数，无法改变context的指向。 1234567891011[1, 2, 3].forEach((v) =&gt; &#123; if (this.breakFlag === true) &#123; return false; &#125; if (v === 2) &#123; console.log(this) // 运行会发现，结果并不是&#123;test: 'test'&#125; this.breakFlag = true &#125; console.log(v) //只输出1,2&#125;, &#123;test: 'test'&#125;); 当然，上述这种方法不可避免的导致了不必要的运行,有点浪费cpu的感觉 3. 神奇改数组大法下面出场的这位选手，稍微有点技术含量，笔者还是问了大佬才知道的，一定是我太过愚钝了。 1234567var array = [1, 2, 3, 4, 5];array.forEach(function(item, index) &#123; if (item === 2) &#123; array = array.concat(array.splice(index, array.length - index)); &#125; console.log(item); //只输出1,2&#125;); 这种方法相当于在item === 2的时候，改变了原数组引用的值，但是将array指向了一个新的引用，值保持不变。 4. 最应该使用的every前面啰嗦了这么多，真正的主角登场，*最推荐的方式是在需要break的场景下，使用every或者some every: 碰到return false的时候，循环中止 some: 碰到return ture的时候，循环中止 两者的代码分别如下： 123456789var a = [1, 2, 3, 4, 5]a.every(function(item, index, arry) &#123; console.log(item); //返回1,2 if (item === 2) &#123; return false &#125; else &#123; return true &#125;&#125;) 123456789var a = [1, 2, 3, 4, 5]a.some(function(item, index, arry) &#123; console.log(item); //返回1,2 if (item === 2) &#123; return true &#125; else &#123; return false &#125;&#125;) 5. 参考内容 http://jser.me/2014/04/02/%E5%A6%82%E4%BD%95%E5%9C%A8Array.forEach%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%87%8Cbreak.html","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://verymuch.com/tags/Javascript/"}]},{"title":"Data URL简介与使用","slug":"Data-URL简介与使用","date":"2017-12-14T00:34:41.000Z","updated":"2018-08-13T10:50:27.008Z","comments":true,"path":"2017/12/14/Data-URL简介与使用/","link":"","permalink":"http://verymuch.com/2017/12/14/Data-URL简介与使用/","excerpt":"1. 简介Data URL，是以data:模式为前缀的URL，允许内容的创建者将较小的文件嵌入到文档中。与常规的URL使用场合类似（下面会具体介绍可以将Data URL用在哪些地方）。 Data URL由data:前缀、MIME类型（表明数据类型）、base64标志位（如果是文本，则可选）以及数据本身四部分组成。 语法格式如下： 1data:[&lt;mediatype&gt;][;base64],data mediatype是一个MIME（Multipurpose Internet Mail Extension）类型字符串，如image/jpeg表示一个JPEG图片文件。如果省略，默认值为text/plain;charset=US-ASCII。","text":"1. 简介Data URL，是以data:模式为前缀的URL，允许内容的创建者将较小的文件嵌入到文档中。与常规的URL使用场合类似（下面会具体介绍可以将Data URL用在哪些地方）。 Data URL由data:前缀、MIME类型（表明数据类型）、base64标志位（如果是文本，则可选）以及数据本身四部分组成。 语法格式如下： 1data:[&lt;mediatype&gt;][;base64],data mediatype是一个MIME（Multipurpose Internet Mail Extension）类型字符串，如image/jpeg表示一个JPEG图片文件。如果省略，默认值为text/plain;charset=US-ASCII。 2. Data URL的优缺点 Data URL的优势 和传统的外部资源引用，Data URL有着以下优势： 当访问外部资源很麻烦或受限时，可以将外部资源转为Data URL引用(这个比较鸡肋) 当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时，这是需要返回一个可用的URL（场景较少） 当图片的体积太小，占用一个HTTP会话不是很值得时（雪碧图可以出场了） Data URL的缺点 虽然Data URL允许使用者将文件嵌入到文档中，这在某些场景下较为合适，但是Data URL也有一些缺点： 体积更大：Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3 不会缓存：Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。 3. 如何获取base64编码 Linux/Mac OS X下可以使用uuencode命令 1uuencode -m &lt;源文件&gt; &lt;转码后标识&gt; 如执行uuencode -m hello-base64 hello，会得到如下结果： 123begin-base64 644 helloaGVsbG8gYmFzZTY0 // 此处为base64编码，对应文本内容为 'hello base64'==== 使用原生Web API编码/解码 Javascript中有两个函数负责编码和解码base64字符串，分别是atob和btoa。 atob(): 负责解码已经使用base64编码了的字符串。 btoa(): 将二进制字符串转为base64编码的ASCII字符串。 两者都只针对Data URL中的data进行处理。 12btoa('hello base64') // \"aGVsbG8gYmFzZTY0\"atob('aGVsbG8gYmFzZTY0') // \"hello base64\" Canvas的toDataURL方法 Canvas提供了toDataURL方法，用于获取canvas绘制内容，将其转为base64格式。 如下所示，文本框中的内容即为canvas中绘制内容的base64格式。 var canvas = document.getElementById('testCanvas'); if (canvas.getContext) { var ctx = canvas.getContext('2d'); // 设置字体 ctx.font = \"Bold 20px Arial\"; // 设置对齐方式 ctx.textAlign = \"left\"; // 设置填充颜色 ctx.fillStyle = \"#000\"; // 设置字体内容，以及在画布上的位置 ctx.fillText(\"hello base64\", 10, 30); // 绘制空心字 ctx.strokeText(\"hello base64\", 10, 80); // 获取 Data URL document.getElementById('testCanvas-content').value = canvas.toDataURL(); } Html: 12&lt;canvas id=\"testCanvas\" width=\"200\" height=\"100\"&gt;&lt;/canvas&gt;&lt;textarea id=\"testCanvas-content\"&gt;&lt;/textarea&gt; JS: 12345678910111213141516var canvas = document.getElementById('testCanvas');if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); // 设置字体 ctx.font = \"Bold 20px Arial\"; // 设置对齐方式 ctx.textAlign = \"left\"; // 设置填充颜色 ctx.fillStyle = \"#000\"; // 设置字体内容，以及在画布上的位置 ctx.fillText(\"hello base64\", 10, 30); // 绘制空心字 ctx.strokeText(\"hello base64\", 10, 80); // 获取 Data URL document.getElementById('testCanvas-content').value = canvas.toDataURL();&#125; 使用FileReader API的readAsDataURL方法 FileReader API提供的readAsDataURL方法能够返回一个基于base64编码的Data URL。 如下所示，选择文件后返回Data URL。 var reader = new FileReader() reader.onload = function(e) { var textarea = document.getElementById('testReadAsDataURL-content'); textarea.value = reader.result } document.getElementById('testReadAsDataURL').onchange = function(e) { var file = e.target.files[0] reader.readAsDataURL(file) } Html: 1234&lt;div class=\"demo-area\"&gt; &lt;input type=\"file\" id=\"testReadAsDataURL\"&gt; &lt;textarea id=\"testReadAsDataURL-content\"&gt;&lt;/textarea&gt;&lt;/div&gt; JS: 123456789var reader = new FileReader()reader.onload = function(e) &#123; var textarea = document.getElementById('testReadAsDataURL-content'); textarea.value = reader.result&#125;document.getElementById('testReadAsDataURL').onchange = function(e) &#123; var file = e.target.files[0] reader.readAsDataURL(file)&#125; 4. Data URL能用在何处呢？最开始已经说了Data URL，是以data:模式为前缀的URL，使用场合与常规URL相同，即常规URL能够使用的场合，Data URL也可以使用。如：浏览器地址栏、link中引入css文件、script中引入js文件、img src中引入图片、video中引入视频、iframe中引入网页、css background url引入背景。 在浏览器地址栏中使用Data URL 在浏览器地址栏中使用Data URL，打开上述canvas中绘制的内容 注意：chrome 从56开始将Data URL标记为“不安全”，从60开始屏蔽从页面打开的 Data URI 网址，可以右键新标签打开。详情 document.getElementById('setDataURLInHref').href = document.getElementById('testCanvas-content').value Html: 1&lt;a href=\"base64内容\" target=\"_blank\" id=\"setDataURLInHref\"&gt;&lt;/a&gt; 在script/img/video/iframe等标签的src属性内使用Data URL 以在script中使用Data URL为例： 点击加入script标签 var scriptDataURL = `data:text/javascript;base64,YWxlcnQoJ+WcqHNjcmlwdOS4reS9v+eUqERhdGEgVVJMJykK` // 对应文本为：alert('在script中使用Data URL') $('#setDataURLInScriptBtn').click(function() { $('').attr('src', scriptDataURL).appendTo($('body')) }) JS: 12345var scriptDataURL = `data:text/javascript;base64,YWxlcnQoJ+WcqHNjcmlwdOS4reS9v+eUqERhdGEgVVJMJykK`// 对应文本为：alert('在script中使用Data URL')$('#setDataURLInScriptBtn').click(function() &#123; $('&lt;script&gt;').attr('src', scriptDataURL).appendTo($('body'))&#125;) 在&lt;link&gt;标签的href中使用Data URL 点击将文字的颜色设为红色 var linkDataURL = `data:text/css;base64,I3NldERhdGFVUkxJbkxpbmtCdG57Y29sb3I6IHJlZDt9Cg==` // 对应内容为：setDataURLInLinkBtn{color: red;} $('#setDataURLInLinkBtn').click(function() { $('').attr('href', linkDataURL).appendTo($('head')) }) JS: 12345var linkDataURL = `data:text/css;base64,I3NldERhdGFVUkxJbkxpbmtCdG57Y29sb3I6IHJlZDt9Cg==`// 对应内容为：setDataURLInLinkBtn&#123;color: red;&#125;$('#setDataURLInLinkBtn').click(function() &#123; $('&lt;link rel=\"stylesheet\" type =\"text/css\"&gt;').attr('href', linkDataURL).appendTo($('head'))&#125;) 在css样式background的url中使用Data URL const bgDataURL = $('#testCanvas-content')[0].value $('#setDataURLInBG').css('background-image', `url(${bgDataURL})`) JS: 12const bgDataURL = $('#testCanvas-content')[0].value$('#setDataURLInBG').css('background-image', `url($&#123;bgDataURL&#125;)`) 5. 参考链接 MDN Data URLs","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"http://verymuch.com/tags/Web/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-01-07T00:40:48.000Z","updated":"2017-01-10T11:04:50.000Z","comments":true,"path":"2017/01/07/hello-world/","link":"","permalink":"http://verymuch.com/2017/01/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}